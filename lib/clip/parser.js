// Generated by CoffeeScript 1.6.2
var ActionExpression, ActionsExpression, BaseParser, CollectionExpression, FnExpression, GroupExpression, JsExpression, ModifierExpression, OptionsExpression, ParamsExpression, Parser, RefExpression, RefPathExpression, ScriptExpression, StringExpression, TokenCodes, Tokenizer,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Tokenizer = require("./tokenizer");

TokenCodes = Tokenizer.codes;

BaseParser = require("../base/parser");

FnExpression = require("./expressions/fn");

JsExpression = require("./expressions/js");

RefExpression = require("./expressions/ref");

GroupExpression = require("./expressions/group");

ParamsExpression = require("./expressions/params");

ScriptExpression = require("./expressions/script");

ActionExpression = require("./expressions/action");

StringExpression = require("./expressions/string");

ActionsExpression = require("./expressions/actions");

OptionsExpression = require("./expressions/options");

RefPathExpression = require("./expressions/refPath");

ModifierExpression = require("./expressions/modifier");

CollectionExpression = require("../base/collectionExpression");

/*
 action:
*/


Parser = (function(_super) {
  __extends(Parser, _super);

  /*
  */


  function Parser() {
    Parser.__super__.constructor.call(this, new Tokenizer());
  }

  /*
  */


  Parser.prototype._parse = function() {
    switch (this._nextCode()) {
      case TokenCodes.VAR:
        return this._parseActionsOrOptions();
      case TokenCodes.LB:
        return this._parseMultiOptions();
      default:
        return this._parseReference();
    }
  };

  /*
  */


  Parser.prototype._parseActionsOrOptions = function() {
    var actions, pn;

    actions = [];
    if (!(pn = this._t.peekNext()) || pn[0] !== TokenCodes.COLON) {
      return this._parseActionOptions();
    }
    while (this._t.current) {
      actions.push(this._parseAction());
      if (this._currentCode() === TokenCodes.SEMI_COLON) {
        this._nextCode();
      }
    }
    return new ActionsExpression(actions);
  };

  /*
  */


  Parser.prototype._parseAction = function() {
    var name;

    name = this._currentString();
    this._expectNextCode(TokenCodes.COLON);
    this._nextCode();
    return new ActionExpression(name, this._parseActionOptions());
  };

  /*
  */


  Parser.prototype._parseActionOptions = function() {
    switch (this._currentCode()) {
      case TokenCodes.LB:
        return this._parseMultiOptions();
      default:
        return this._parseReference();
    }
  };

  /*
  */


  Parser.prototype._parseMultiOptions = function() {
    var c, ops, options;

    c = this._currentCode();
    options = [];
    while (c && (c = this._currentCode()) !== TokenCodes.RB) {
      this._nextCode();
      ops = {
        name: this._currentString()
      };
      this._expectNextCode(TokenCodes.COLON);
      this._nextCode();
      ops.expression = this._parseActionOptions();
      options.push(ops);
    }
    this._nextCode();
    return new OptionsExpression(options);
  };

  /*
  */


  Parser.prototype._parseReference = function() {
    var c, expressions, modifiers;

    expressions = [];
    modifiers = [];
    while (c = this._currentCode()) {
      if (c === TokenCodes.VAR) {
        expressions.push(this._parseRef());
        c = this._currentCode();
      }
      if (c === TokenCodes.LP) {
        expressions.push(this._parseGroup());
        c = this._currentCode();
      }
      if (c === TokenCodes.LB) {
        expressions.push(this._parseActionOptions());
        c = this._currentCode();
      }
      if (c === TokenCodes.STRING) {
        expressions.push(new StringExpression(this._currentString()));
        c = this._nextCode();
      }
      while (c === TokenCodes.PIPE) {
        this._nextCode();
        expressions.push(this._parsePipe(expressions.pop()));
        c = this._currentCode();
      }
      if (~[TokenCodes.RP, TokenCodes.RB].indexOf(c)) {
        break;
      }
      if (!c || ~[TokenCodes.SEMI_COLON, TokenCodes.COMA].indexOf(c)) {
        break;
      }
      expressions.push(new JsExpression(this._currentString()));
      this._nextCode();
    }
    if (this._currentCode() === TokenCodes.SEMI_COLON) {
      this._nextCode();
    }
    return new ScriptExpression(new CollectionExpression(expressions));
  };

  /*
   filter item.name > 5, test;
  */


  Parser.prototype._parsePipe = function(expressions) {
    var name, params;

    name = this._currentString();
    params = [];
    this._nextCode();
    return new ModifierExpression(name, this._parseParams(), expressions);
  };

  /*
  */


  Parser.prototype._parseParams = function() {
    return new ParamsExpression(this._parseParams2());
  };

  /*
  */


  Parser.prototype._parseParams2 = function() {
    var c, params;

    this._expectCurrentCode(TokenCodes.LP);
    params = [];
    while (c = this._nextCode()) {
      if (c === TokenCodes.RP) {
        break;
      }
      params.push(this._parseReference());
      c = this._currentCode();
      if (c !== TokenCodes.COMA) {
        break;
      }
    }
    this._nextCode();
    return params;
  };

  /*
  */


  Parser.prototype._parseGroup = function() {
    return new GroupExpression(this._parseParams2());
  };

  /*
  */


  Parser.prototype._parseRef = function() {
    var assign, c, castAs, name, refs;

    c = this._currentCode();
    refs = [];
    assign = null;
    while (c === TokenCodes.VAR) {
      name = this._currentString();
      if ((c = this._nextCode()) === TokenCodes.LP) {
        refs.push(new FnExpression(name, this._parseParams()));
        c = this._currentCode();
      } else {
        refs.push(new RefExpression(name));
      }
      if (c === TokenCodes.DOT) {
        c = this._nextCode();
      }
    }
    if (c === TokenCodes.AS) {
      this._nextCode();
      castAs = this._currentString();
      this._nextCode();
    }
    if (c === TokenCodes.ASSIGN) {
      this._nextCode();
      assign = this._parseReference();
    }
    return new RefPathExpression(refs, castAs, assign);
  };

  return Parser;

})(BaseParser);

module.exports = Parser;
