// Generated by CoffeeScript 1.6.2
(function() {
  var Parser, TokenCodes, Tokenizer;

  Tokenizer = require("./tokenizer");

  TokenCodes = Tokenizer.codes;

  /*
   action:
  */


  Parser = (function() {
    /*
    */
    function Parser() {
      this._t = new Tokenizer();
    }

    /*
    */


    Parser.prototype.parse = function(source) {
      this._t.source(source);
      return this._parse();
    };

    /*
    */


    Parser.prototype._parse = function() {
      switch (this._nextCode()) {
        case TokenCodes.WORD:
          return this._parseAction();
        default:
          return this._error();
      }
    };

    /*
    */


    Parser.prototype._parseAction = function() {
      var actionName;

      actionName = this._currentString();
      this._expectNextCode(TokenCodes.COLON);
      return this._parseActionOptions();
    };

    /*
    */


    Parser.prototype._parseActionOptions = function() {
      switch (this._nextCode()) {
        case TokenCodes.WS:
          return this._parseActionOptions();
        case TokenCodes.LB:
          return this._parseOptions();
        case TokenCodes.WORD:
          return this._parseReference();
        case TokenCodes.STRING:
          return this._parseString();
        default:
          return this._error();
      }
    };

    /*
    */


    Parser.prototype._parseReference = function() {
      var buffer, c, refs;

      this._t.putBack();
      c = this._currentCode();
      refs = [];
      buffer = [];
      while ((c = this._nextCode()) && !~[TokenCodes.RB, TokenCodes.COMA, TokenCodes.LB].indexOf(c)) {
        if (c === TokenCodes.WORD) {
          buffer.push(this._parseRef());
        }
        if (this._currentCode() === TokenCodes.WS) {
          continue;
        }
        buffer.push(this._currentString());
      }
      return console.log(buffer);
    };

    /*
    */


    Parser.prototype._parseRef = function() {
      var c, name, refs;

      c = this._currentCode();
      refs = [];
      while (c === TokenCodes.WORD) {
        name = this._t.current[1];
        if ((c = this._nextCode()) === TokenCodes.LP) {
          refs.push(name + this._parseParams());
        } else {
          refs.push(name);
        }
        if (this._currentCode() === TokenCodes.DOT) {
          c = this._nextCode();
        }
      }
      return refs;
    };

    /*
    */


    Parser.prototype._parseParams = function() {
      var buffer, c;

      c = this._currentCode();
      buffer = [];
      while (c && c === TokenCodes.LP) {
        buffer.push(this._t.current[1]);
        if ((c = this._nextCode()) === TokenCodes.LP) {
          buffer.push(this._parseParams());
        } else if (c === TokenCodes.RP) {
          buffer.push(this._t.current[1]);
          this._nextCode();
          break;
        }
      }
      return buffer.join("");
    };

    /*
    */


    Parser.prototype._expectNextCode = function(code) {
      if (this._t.next()[0] !== code) {
        return this._error();
      }
    };

    /*
    */


    Parser.prototype._nextCode = function() {
      var _ref;

      return (_ref = this._t.next()) != null ? _ref[0] : void 0;
    };

    /*
    */


    Parser.prototype._currentCode = function() {
      return this._t.current[0];
    };

    /*
    */


    Parser.prototype._currentString = function() {
      return this._t.current[1];
    };

    Parser.prototype._error = function() {
      throw new Error("unexpected token " + (TokenCodes.key(this._t.current[0])) + " '" + this._t.current[1] + "' in '" + (this._t.source()) + "'");
    };

    return Parser;

  })();

  module.exports = Parser;

}).call(this);
