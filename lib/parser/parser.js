module.exports = (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleIndices = { Start: 0 },
        peg$startRuleIndex   = 0,

        peg$consts = [
          function(children) { return new RootNodeExpression(children); },
          peg$FAILED,
          "<!DOCTYPE",
          { type: "literal", value: "<!DOCTYPE", description: "\"<!DOCTYPE\"" },
          [],
          /^[^>]/,
          { type: "class", value: "[^>]", description: "[^>]" },
          ">",
          { type: "literal", value: ">", description: "\">\"" },
          function(info) {
                return new DocTypeExpression(info.join(""));
              },
          function(children) { return new ArrayExpression(new ParametersExpression(trimTextExpressions(children))); },
          "<!--",
          { type: "literal", value: "<!--", description: "\"<!--\"" },
          void 0,
          "-->",
          { type: "literal", value: "-->", description: "\"-->\"" },
          function(v) { return v; },
          function(value) {
              return new CommentNodeExpression(trimEnds(value.join("")));
            },
          "<",
          { type: "literal", value: "<", description: "\"<\"" },
          "area",
          { type: "literal", value: "area", description: "\"area\"" },
          "base",
          { type: "literal", value: "base", description: "\"base\"" },
          "br",
          { type: "literal", value: "br", description: "\"br\"" },
          "col",
          { type: "literal", value: "col", description: "\"col\"" },
          "command",
          { type: "literal", value: "command", description: "\"command\"" },
          "embed",
          { type: "literal", value: "embed", description: "\"embed\"" },
          "hr",
          { type: "literal", value: "hr", description: "\"hr\"" },
          "img",
          { type: "literal", value: "img", description: "\"img\"" },
          "input",
          { type: "literal", value: "input", description: "\"input\"" },
          "keygen",
          { type: "literal", value: "keygen", description: "\"keygen\"" },
          "link",
          { type: "literal", value: "link", description: "\"link\"" },
          "meta",
          { type: "literal", value: "meta", description: "\"meta\"" },
          "param",
          { type: "literal", value: "param", description: "\"param\"" },
          "source",
          { type: "literal", value: "source", description: "\"source\"" },
          "track",
          { type: "literal", value: "track", description: "\"track\"" },
          "wbr",
          { type: "literal", value: "wbr", description: "\"wbr\"" },
          null,
          "/>",
          { type: "literal", value: "/>", description: "\"/>\"" },
          function(nodeName, attributes, endTag) {


              if (endTag && nodeName != endTag.name) {
                expected("</" + nodeName + ">");
              }

              return new ElementNodeExpression(nodeName, attributes);
            },
          "</",
          { type: "literal", value: "</", description: "\"</\"" },
          function(name) {
                return {
                  name: name
                };
              },
          function(startTag, children, endTag) {

              if (startTag.name != endTag.name) {
                expected("</" + startTag.name + ">");
              }

              return new ElementNodeExpression(startTag.name, startTag.attributes, children);
            },
          function(value) {
                return new TextNodeExpression(trimNewLineChars(value.join("")));
              },
          "{{",
          { type: "literal", value: "{{", description: "\"{{\"" },
          function() {
                return text();
              },
          function(info) { return info; },
          function(info) { return new ElementNodeExpression(info.name, info.attributes); },
          function(name, attrs) {
                return {
                  name: name,
                  attributes: attrs
                };
              },
          function(attributes) {
                var attrs = {};

                for (var i = 0, n = attributes.length; i < n; i++) {
                  var attr = attributes[i];
                  attrs[attr.name] = attr.value || true;
                }

                return new HashExpression(attrs);
            },
          /^[a-zA-Z0-9:_.\-]/,
          { type: "class", value: "[a-zA-Z0-9:_.\\-]", description: "[a-zA-Z0-9:_.\\-]" },
          function(word) { return word.join(""); },
          "=",
          { type: "literal", value: "=", description: "\"=\"" },
          function(name, values) {
                return {
                  name: name,
                  value: values
                };
              },
          function(name) {
                return {
                  name: name,
                  value: new LiteralExpression(true)
                };
              },
          "\"",
          { type: "literal", value: "\"", description: "\"\\\"\"" },
          /^[^"]/,
          { type: "class", value: "[^\"]", description: "[^\"]" },
          function() { return new StringExpression(trimNewLineChars(text())); },
          function(values) { return attrValues(values); },
          "'",
          { type: "literal", value: "'", description: "\"'\"" },
          /^[^']/,
          { type: "class", value: "[^']", description: "[^']" },
          function(binding) { return attrValues([binding]); },
          "{{#",
          { type: "literal", value: "{{#", description: "\"{{#\"" },
          function(blockBinding) { return blockBinding; },
          function(scripts, fragment, child) {
                return new BlockBindingExpression(scripts, fragment, child);
              },
          "{{/",
          { type: "literal", value: "{{/", description: "\"{{/\"" },
          function(blockBinding) { return new RootNodeExpression(blockBinding); },
          "{{/}}",
          { type: "literal", value: "{{/}}", description: "\"{{/}}\"" },
          function() { return void 0; },
          "}}",
          { type: "literal", value: "}}", description: "\"}}\"" },
          function(scripts) {
                return new BlockBindingExpression(scripts);
              },
          function(scripts) {
                return scripts;
              },
          function(scriptName) {
                var hash = {};
                hash[scriptName] = new ScriptExpression(new LiteralExpression(true));
                return new HashExpression(hash);
              },
          function(scripts) {
                for (var k in scripts) {
                  scripts[k] = new ScriptExpression(scripts[k]);
                }
                return new HashExpression(scripts);
              },
          ",",
          { type: "literal", value: ",", description: "\",\"" },
          function(value, ascripts) {

                var scripts = {
                  value: new ScriptExpression(value)
                };

                ascripts = ascripts.length ? ascripts[0][1] : [];
                for (var i = 0, n = ascripts.length; i < n; i++) {
                  scripts[ascripts[i].key] = new ScriptExpression(ascripts[i].value);
                }

                return new HashExpression(scripts);
              },
          "?",
          { type: "literal", value: "?", description: "\"?\"" },
          ":",
          { type: "literal", value: ":", description: "\":\"" },
          function(condition, left, right) {
                return new TernaryConditionExpression(condition, left, right);
              },
          "(",
          { type: "literal", value: "(", description: "\"(\"" },
          ")",
          { type: "literal", value: ")", description: "\")\"" },
          function(params) {
                return params;
              },
          "()",
          { type: "literal", value: "()", description: "\"()\"" },
          function() { return []; },
          function(param1, rest) {
                return [param1].concat(rest.map(function(v) {
                  return v[1];
                }));
              },
          function(left, right) {
                return new AssignmentExpression(left, right);
              },
          "&&",
          { type: "literal", value: "&&", description: "\"&&\"" },
          "||",
          { type: "literal", value: "||", description: "\"||\"" },
          "===",
          { type: "literal", value: "===", description: "\"===\"" },
          "==",
          { type: "literal", value: "==", description: "\"==\"" },
          "!==",
          { type: "literal", value: "!==", description: "\"!==\"" },
          "!=",
          { type: "literal", value: "!=", description: "\"!=\"" },
          ">==",
          { type: "literal", value: ">==", description: "\">==\"" },
          ">=",
          { type: "literal", value: ">=", description: "\">=\"" },
          "<==",
          { type: "literal", value: "<==", description: "\"<==\"" },
          "<=",
          { type: "literal", value: "<=", description: "\"<=\"" },
          "+",
          { type: "literal", value: "+", description: "\"+\"" },
          "-",
          { type: "literal", value: "-", description: "\"-\"" },
          "%",
          { type: "literal", value: "%", description: "\"%\"" },
          "*",
          { type: "literal", value: "*", description: "\"*\"" },
          "/",
          { type: "literal", value: "/", description: "\"/\"" },
          function(left, operator, right) {
                return new OperatorExpression(operator, left, right);
              },
          function(value) { return value; },
          function(expression, modifiers) {

                for (var i = 0, n = modifiers.length; i < n; i++) {
                  expression = new ModifierExpression(modifiers[i].name, new ParametersExpression([expression].concat(modifiers[i].parameters)));
                }

                return expression;
              },
          "|",
          { type: "literal", value: "|", description: "\"|\"" },
          function(name, parameters) {
              return {
                name: name,
                parameters: parameters || []
              };
            },
          function(context) { return context; },
          "!",
          { type: "literal", value: "!", description: "\"!\"" },
          function(not, value) {
                return new NotExpression(not, value);
              },
          /^[0-9]/,
          { type: "class", value: "[0-9]", description: "[0-9]" },
          function(value) {
                return new LiteralExpression(parseFloat(text()));
              },
          ".",
          { type: "literal", value: ".", description: "\".\"" },
          function(group) { return new GroupExpression(group); },
          function(expression) {
                return new LiteralExpression(expression.value);
              },
          "true",
          { type: "literal", value: "true", description: "\"true\"" },
          "false",
          { type: "literal", value: "false", description: "\"false\"" },
          function(value) {
                return {
                  type: "boolean",
                  value: value === "true"
                };
              },
          "undefined",
          { type: "literal", value: "undefined", description: "\"undefined\"" },
          function() { return { type: "undefined", value: void 0 }; },
          "NaN",
          { type: "literal", value: "NaN", description: "\"NaN\"" },
          function() { return { type: "nan", value: NaN }; },
          "Infinity",
          { type: "literal", value: "Infinity", description: "\"Infinity\"" },
          function() { return { type: "infinity", value: Infinity }; },
          "null",
          { type: "literal", value: "null", description: "\"null\"" },
          "NULL",
          { type: "literal", value: "NULL", description: "\"NULL\"" },
          function() { return { type: "null", value: null }; },
          function(reference, parameters) {
                return new CallExpression(reference, new ParametersExpression(parameters));
              },
          "^",
          { type: "literal", value: "^", description: "\"^\"" },
          "~>",
          { type: "literal", value: "~>", description: "\"~>\"" },
          "<~>",
          { type: "literal", value: "<~>", description: "\"<~>\"" },
          "~",
          { type: "literal", value: "~", description: "\"~\"" },
          "<~",
          { type: "literal", value: "<~", description: "\"<~\"" },
          function(bindingType, reference, path) {
                path = [reference].concat(path.map(function(p) { return p[1]; }));
                return new ReferenceExpression(path, bindingType);
              },
          /^[a-zA-Z_$0-9]/,
          { type: "class", value: "[a-zA-Z_$0-9]", description: "[a-zA-Z_$0-9]" },
          function(name) { return text(); },
          "{",
          { type: "literal", value: "{", description: "\"{\"" },
          "}",
          { type: "literal", value: "}", description: "\"}\"" },
          function(values) {
                return new HashExpression(values);
              },
          function(values) {
                var s = {};
                for (var i = 0, n = values.length; i < n; i++) {
                  s[values[i].key] = values[i].value;
                }
                return s;
              },
          function(firstValue, additionalValues) {
                return [
                  firstValue
                ].concat(additionalValues.length ? additionalValues[0][1] : []);
              },
          function(key, value) {
                return {
                  key: key,
                  value: value || new LiteralExpression(void 0)
                };
              },
          function(key) { return key.value; },
          function(key) { return key; },
          { type: "other", description: "string" },
          function(chars) {
                return new StringExpression(chars.join(""));
              },
          "\\",
          { type: "literal", value: "\\", description: "\"\\\\\"" },
          function() { return text(); },
          "\\\"",
          { type: "literal", value: "\\\"", description: "\"\\\\\\\"\"" },
          "\\'",
          { type: "literal", value: "\\'", description: "\"\\\\'\"" },
          { type: "any", description: "any character" },
          /^[a-zA-Z]/,
          { type: "class", value: "[a-zA-Z]", description: "[a-zA-Z]" },
          function(chars) { return chars.join(""); },
          /^[ \n\r\t]/,
          { type: "class", value: "[ \\n\\r\\t]", description: "[ \\n\\r\\t]" },
          /^[\n\r\t]/,
          { type: "class", value: "[\\n\\r\\t]", description: "[\\n\\r\\t]" }
        ],

        peg$bytecode = [
          peg$decode("7!"),
          peg$decode("!7#+' 4!6 !! %"),
          peg$decode("!.\"\"\"2\"3#+q$7Z+g% $0%\"\"1!3&+,$,)&0%\"\"1!3&\"\"\" !+B%7Z+8%.'\"\"2'3(+(%4%6)%!\"%$%# !$$# !$## !$\"# !\"# !"),
          peg$decode("! $7%*5 \"7'*/ \"7$*) \"7(*# \"72,;&7%*5 \"7'*/ \"7$*) \"7(*# \"72\"+' 4!6*!! %"),
          peg$decode("!7Z+\xC7$.+\"\"2+3,+\xB7% $!!8..\"\"2.3/9*$$\"\" -\"# !+2$7X+(%4\"60\"! %$\"# !\"# !+T$,Q&!!8..\"\"2.3/9*$$\"\" -\"# !+2$7X+(%4\"60\"! %$\"# !\"# !\"\"\" !+B%..\"\"2.3/+2%7Z+(%4%61%!\"%$%# !$$# !$## !$\"# !\"# !*# \"7\""),
          peg$decode("!.2\"\"2233+\u0134$.4\"\"2435*\xD1 \".6\"\"2637*\xC5 \".8\"\"2839*\xB9 \".:\"\"2:3;*\xAD \".<\"\"2<3=*\xA1 \".>\"\"2>3?*\x95 \".@\"\"2@3A*\x89 \".B\"\"2B3C*} \".D\"\"2D3E*q \".F\"\"2F3G*e \".H\"\"2H3I*Y \".J\"\"2J3K*M \".L\"\"2L3M*A \".N\"\"2N3O*5 \".P\"\"2P3Q*) \".R\"\"2R3S+p%7-+f%.'\"\"2'3(*) \".U\"\"2U3V*# \" T+D%7Z+:%7&*# \" T+*%4&6W&#$# %$&# !$%# !$$# !$## !$\"# !\"# !"),
          peg$decode("!.X\"\"2X3Y+\xFC$.4\"\"2435*\xD1 \".6\"\"2637*\xC5 \".8\"\"2839*\xB9 \".:\"\"2:3;*\xAD \".<\"\"2<3=*\xA1 \".>\"\"2>3?*\x95 \".@\"\"2@3A*\x89 \".B\"\"2B3C*} \".D\"\"2D3E*q \".F\"\"2F3G*e \".H\"\"2H3I*Y \".J\"\"2J3K*M \".L\"\"2L3M*A \".N\"\"2N3O*5 \".P\"\"2P3Q*) \".R\"\"2R3S+8%.'\"\"2'3(+(%4#6Z#!!%$## !$\"# !\"# !"),
          peg$decode("!7*+>$7#+4%7.+*%4#6[##\"! %$## !$\"# !\"# !*# \"7+"),
          peg$decode("! $7)+&$,#&7)\"\"\" !+' 4!6\\!! %"),
          peg$decode("!!8.2\"\"2233*) \".]\"\"2]3^9*$$\"\" -\"# !+1$7X+'%4\"6_\" %$\"# !\"# !"),
          peg$decode("!7Z+\\$.2\"\"2233+L%7,+B%.'\"\"2'3(+2%7Z+(%4%6`%!\"%$%# !$$# !$## !$\"# !\"# !"),
          peg$decode("!7Z+\\$.2\"\"2233+L%7,+B%.U\"\"2U3V+2%7Z+(%4%6a%!\"%$%# !$$# !$## !$\"# !\"# !"),
          peg$decode("!7/+3$7-+)%4\"6b\"\"! %$\"# !\"# !"),
          peg$decode("!7Z+D$ $70,#&70\"+2%7Z+(%4#6c#!!%$## !$\"# !\"# !"),
          peg$decode("!.X\"\"2X3Y+B$7/+8%.'\"\"2'3(+(%4#6Z#!!%$## !$\"# !\"# !"),
          peg$decode("!7Z+M$ $0d\"\"1!3e+,$,)&0d\"\"1!3e\"\"\" !+(%4\"6f\"! %$\"# !\"# !"),
          peg$decode("!7/+W$7Z+M%.g\"\"2g3h+=%7Z+3%71+)%4%6i%\"$ %$%# !$$# !$## !$\"# !\"# !*/ \"!7/+' 4!6j!! %"),
          peg$decode("!.k\"\"2k3l+\u0146$ $76*\x9B \"! $!!8.]\"\"2]3^9*$$\"\" -\"# !+3$0m\"\"1!3n+#%'\"%$\"# !\"# !+U$,R&!!8.]\"\"2]3^9*$$\"\" -\"# !+3$0m\"\"1!3n+#%'\"%$\"# !\"# !\"\"\" !+& 4!6o! %,\xA1&76*\x9B \"! $!!8.]\"\"2]3^9*$$\"\" -\"# !+3$0m\"\"1!3n+#%'\"%$\"# !\"# !+U$,R&!!8.]\"\"2]3^9*$$\"\" -\"# !+3$0m\"\"1!3n+#%'\"%$\"# !\"# !\"\"\" !+& 4!6o! %\"+8%.k\"\"2k3l+(%4#6p#!!%$## !$\"# !\"# !*\u0169 \"!.q\"\"2q3r+\u0146$ $76*\x9B \"! $!!8.]\"\"2]3^9*$$\"\" -\"# !+3$0s\"\"1!3t+#%'\"%$\"# !\"# !+U$,R&!!8.]\"\"2]3^9*$$\"\" -\"# !+3$0s\"\"1!3t+#%'\"%$\"# !\"# !\"\"\" !+& 4!6o! %,\xA1&76*\x9B \"! $!!8.]\"\"2]3^9*$$\"\" -\"# !+3$0s\"\"1!3t+#%'\"%$\"# !\"# !+U$,R&!!8.]\"\"2]3^9*$$\"\" -\"# !+3$0s\"\"1!3t+#%'\"%$\"# !\"# !\"\"\" !+& 4!6o! %\"+8%.q\"\"2q3r+(%4#6p#!!%$## !$\"# !\"# !*/ \"!76+' 4!6u!! %"),
          peg$decode("!.v\"\"2v3w+2$73+(%4\"6x\"! %$\"# !\"# !*# \"75"),
          peg$decode("!77+R$7Z+H%7!+>%7Z+4%74+*%4%6y%#$\" %$%# !$$# !$## !$\"# !\"# !"),
          peg$decode("!.z\"\"2z3{+2$73+(%4\"6|\"! %$\"# !\"# !*B \"!.}\"\"2}3~+1$7Z+'%4\"6\" %$\"# !\"# !"),
          peg$decode("!.]\"\"2]3^+V$7Z+L%78+B%7Z+8%.\x80\"\"2\x803\x81+(%4%6\x82%!\"%$%# !$$# !$## !$\"# !\"# !"),
          peg$decode("!.]\"\"2]3^+V$7Z+L%78+B%7Z+8%.\x80\"\"2\x803\x81+(%4%6\x83%!\"%$%# !$$# !$## !$\"# !\"# !"),
          peg$decode("!7Z+L$7O+B%7Z+8%.\x80\"\"2\x803\x81+(%4$6\x84$!\"%$$# !$## !$\"# !\"# !*M \"!78+B$7Z+8%.\x80\"\"2\x803\x81+(%4#6\x83#!\"%$## !$\"# !\"# !"),
          peg$decode("!7Q+' 4!6\x85!! %*\x90 \"!7Z+\x85$79+{%7Z+q% $!.\x86\"\"2\x863\x87+-$7R+#%'\"%$\"# !\"# !,>&!.\x86\"\"2\x863\x87+-$7R+#%'\"%$\"# !\"# !\"+)%4$6\x88$\"\" %$$# !$## !$\"# !\"# !"),
          peg$decode("!7<+^$.\x89\"\"2\x893\x8A+N%79+D%.\x8B\"\"2\x8B3\x8C+4%79+*%4%6\x8D%#$\" %$%# !$$# !$## !$\"# !\"# !*# \"7<"),
          peg$decode("!.\x8E\"\"2\x8E3\x8F+B$7;+8%.\x90\"\"2\x903\x91+(%4#6\x92#!!%$## !$\"# !\"# !*4 \"!.\x93\"\"2\x933\x94+& 4!6\x95! %"),
          peg$decode("!79+q$ $!.\x86\"\"2\x863\x87+-$79+#%'\"%$\"# !\"# !,>&!.\x86\"\"2\x863\x87+-$79+#%'\"%$\"# !\"# !\"+)%4\"6\x96\"\"! %$\"# !\"# !"),
          peg$decode("!7A+C$.g\"\"2g3h+3%7<+)%4#6\x97#\"\" %$## !$\"# !\"# !*# \"7="),
          peg$decode("!7>+\u0104$.\x98\"\"2\x983\x99*\xDD \".\x9A\"\"2\x9A3\x9B*\xD1 \".\x9C\"\"2\x9C3\x9D*\xC5 \".\x9E\"\"2\x9E3\x9F*\xB9 \".\xA0\"\"2\xA03\xA1*\xAD \".\xA2\"\"2\xA23\xA3*\xA1 \".\xA4\"\"2\xA43\xA5*\x95 \".\xA6\"\"2\xA63\xA7*\x89 \".'\"\"2'3(*} \".\xA8\"\"2\xA83\xA9*q \".\xAA\"\"2\xAA3\xAB*e \".2\"\"2233*Y \".\xAC\"\"2\xAC3\xAD*M \".\xAE\"\"2\xAE3\xAF*A \".\xB0\"\"2\xB03\xB1*5 \".\xB2\"\"2\xB23\xB3*) \".\xB4\"\"2\xB43\xB5+4%7=+*%4#6\xB6##\"! %$## !$\"# !\"# !*# \"7>"),
          peg$decode("!7Z+<$7?+2%7Z+(%4#6\xB7#!!%$## !$\"# !\"# !"),
          peg$decode("!7B+;$ $7@,#&7@\"+)%4\"6\xB8\"\"! %$\"# !\"# !*) \"7M*# \"7A"),
          peg$decode("!.\xB9\"\"2\xB93\xBA+W$7Z+M%7O+C%7:*# \" T+3%7Z+)%4%6\xBB%\"\"!%$%# !$$# !$## !$\"# !\"# !"),
          peg$decode("!7Z+<$7C+2%7Z+(%4#6\xBC#!!%$## !$\"# !\"# !"),
          peg$decode("!.\xBD\"\"2\xBD3\xBE*) \".\xAE\"\"2\xAE3\xAF+3$7B+)%4\"6\xBF\"\"! %$\"# !\"# !*/ \"7G*) \"7M*# \"7A"),
          peg$decode("7F*5 \"7P*/ \"7D*) \"7U*# \"7N"),
          peg$decode("!!.\xAE\"\"2\xAE3\xAF*# \" T+i$! $0\xC0\"\"1!3\xC1+,$,)&0\xC0\"\"1!3\xC1\"\"\" !+3$7E*# \" T+#%'\"%$\"# !\"# !*# \"7E+#%'\"%$\"# !\"# !+' 4!6\xC2!! %"),
          peg$decode("!.\xC3\"\"2\xC33\xC4+H$ $0\xC0\"\"1!3\xC1+,$,)&0\xC0\"\"1!3\xC1\"\"\" !+#%'\"%$\"# !\"# !"),
          peg$decode("!.\x8E\"\"2\x8E3\x8F+B$79+8%.\x90\"\"2\x903\x91+(%4#6\xC5#!!%$## !$\"# !\"# !"),
          peg$decode("!7H*5 \"7I*/ \"7L*) \"7J*# \"7K+' 4!6\xC6!! %"),
          peg$decode("!.\xC7\"\"2\xC73\xC8*) \".\xC9\"\"2\xC93\xCA+' 4!6\xCB!! %"),
          peg$decode("!.\xCC\"\"2\xCC3\xCD+& 4!6\xCE! %"),
          peg$decode("!.\xCF\"\"2\xCF3\xD0+& 4!6\xD1! %"),
          peg$decode("!.\xD2\"\"2\xD23\xD3+& 4!6\xD4! %"),
          peg$decode("!.\xD5\"\"2\xD53\xD6*) \".\xD7\"\"2\xD73\xD8+& 4!6\xD9! %"),
          peg$decode("!7A+3$7:+)%4\"6\xDA\"\"! %$\"# !\"# !"),
          peg$decode("!.\xDB\"\"2\xDB3\xDC*M \".\xDD\"\"2\xDD3\xDE*A \".\xDF\"\"2\xDF3\xE0*5 \".\xE1\"\"2\xE13\xE2*) \".\xE3\"\"2\xE33\xE4*# \" T+\x90$7Z+\x86%7O+|% $!.\xC3\"\"2\xC33\xC4+-$7O+#%'\"%$\"# !\"# !,>&!.\xC3\"\"2\xC33\xC4+-$7O+#%'\"%$\"# !\"# !\"+4%7Z+*%4%6\xE5%#$\"!%$%# !$$# !$## !$\"# !\"# !"),
          peg$decode("! $0\xE6\"\"1!3\xE7+,$,)&0\xE6\"\"1!3\xE7\"\"\" !+' 4!6\xE8!! %"),
          peg$decode("!.\xE9\"\"2\xE93\xEA+\\$7Z+R%7Q*# \" T+B%7Z+8%.\xEB\"\"2\xEB3\xEC+(%4%6\xED%!\"%$%# !$$# !$## !$\"# !\"# !"),
          peg$decode("!7R+' 4!6\xEE!! %"),
          peg$decode("!7S+q$ $!.\x86\"\"2\x863\x87+-$7R+#%'\"%$\"# !\"# !,>&!.\x86\"\"2\x863\x87+-$7R+#%'\"%$\"# !\"# !\"+)%4\"6\xEF\"\"! %$\"# !\"# !"),
          peg$decode("!7Z+]$7T+S%7Z+I%.\x8B\"\"2\x8B3\x8C+9%79*# \" T+)%4%6\xF0%\"# %$%# !$$# !$## !$\"# !\"# !"),
          peg$decode("!7U+' 4!6\xF1!! %*/ \"!7O+' 4!6\xF2!! %"),
          peg$decode("8!.k\"\"2k3l+J$ $7V,#&7V\"+8%.k\"\"2k3l+(%4#6\xF4#!!%$## !$\"# !\"# !*[ \"!.q\"\"2q3r+J$ $7W,#&7W\"+8%.q\"\"2q3r+(%4#6\xF4#!!%$## !$\"# !\"# !9*\" 3\xF3"),
          peg$decode("!!8.k\"\"2k3l*) \".\xF5\"\"2\xF53\xF69*$$\"\" -\"# !+1$7X+'%4\"6\xF7\" %$\"# !\"# !*) \".\xF8\"\"2\xF83\xF9"),
          peg$decode("!!8.q\"\"2q3r*) \".\xF5\"\"2\xF53\xF69*$$\"\" -\"# !+1$7X+'%4\"6\xF7\" %$\"# !\"# !*) \".\xFA\"\"2\xFA3\xFB"),
          peg$decode("-\"\"1!3\xFC"),
          peg$decode("! $0\xFD\"\"1!3\xFE+,$,)&0\xFD\"\"1!3\xFE\"\"\" !+' 4!6\xFF!! %"),
          peg$decode(" $0\u0100\"\"1!3\u0101,)&0\u0100\"\"1!3\u0101\""),
          peg$decode(" $0\u0102\"\"1!3\u0103,)&0\u0102\"\"1!3\u0103\"")
        ],

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleIndices)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleIndex = peg$startRuleIndices[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$decode(s) {
      var bc = new Array(s.length), i;

      for (i = 0; i < s.length; i++) {
        bc[i] = s.charCodeAt(i) - 32;
      }

      return bc;
    }

    function peg$parseRule(index) {
      var bc    = peg$bytecode[index],
          ip    = 0,
          ips   = [],
          end   = bc.length,
          ends  = [],
          stack = [],
          params, i;

      function protect(object) {
        return Object.prototype.toString.apply(object) === "[object Array]" ? [] : object;
      }

      while (true) {
        while (ip < end) {
          switch (bc[ip]) {
            case 0:
              stack.push(protect(peg$consts[bc[ip + 1]]));
              ip += 2;
              break;

            case 1:
              stack.push(peg$currPos);
              ip++;
              break;

            case 2:
              stack.pop();
              ip++;
              break;

            case 3:
              peg$currPos = stack.pop();
              ip++;
              break;

            case 4:
              stack.length -= bc[ip + 1];
              ip += 2;
              break;

            case 5:
              stack.splice(-2, 1);
              ip++;
              break;

            case 6:
              stack[stack.length - 2].push(stack.pop());
              ip++;
              break;

            case 7:
              stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
              ip += 2;
              break;

            case 8:
              stack.pop();
              stack.push(input.substring(stack[stack.length - 1], peg$currPos));
              ip++;
              break;

            case 9:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (stack[stack.length - 1]) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 10:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (stack[stack.length - 1] === peg$FAILED) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 11:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (stack[stack.length - 1] !== peg$FAILED) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 12:
              if (stack[stack.length - 1] !== peg$FAILED) {
                ends.push(end);
                ips.push(ip);

                end = ip + 2 + bc[ip + 1];
                ip += 2;
              } else {
                ip += 2 + bc[ip + 1];
              }

              break;

            case 13:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (input.length > peg$currPos) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 14:
              ends.push(end);
              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
                end = ip + 4 + bc[ip + 2];
                ip += 4;
              } else {
                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                ip += 4 + bc[ip + 2];
              }

              break;

            case 15:
              ends.push(end);
              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
                end = ip + 4 + bc[ip + 2];
                ip += 4;
              } else {
                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                ip += 4 + bc[ip + 2];
              }

              break;

            case 16:
              ends.push(end);
              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

              if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
                end = ip + 4 + bc[ip + 2];
                ip += 4;
              } else {
                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                ip += 4 + bc[ip + 2];
              }

              break;

            case 17:
              stack.push(input.substr(peg$currPos, bc[ip + 1]));
              peg$currPos += bc[ip + 1];
              ip += 2;
              break;

            case 18:
              stack.push(peg$consts[bc[ip + 1]]);
              peg$currPos += peg$consts[bc[ip + 1]].length;
              ip += 2;
              break;

            case 19:
              stack.push(peg$FAILED);
              if (peg$silentFails === 0) {
                peg$fail(peg$consts[bc[ip + 1]]);
              }
              ip += 2;
              break;

            case 20:
              peg$reportedPos = stack[stack.length - 1 - bc[ip + 1]];
              ip += 2;
              break;

            case 21:
              peg$reportedPos = peg$currPos;
              ip++;
              break;

            case 22:
              params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);
              for (i = 0; i < bc[ip + 3]; i++) {
                params[i] = stack[stack.length - 1 - params[i]];
              }

              stack.splice(
                stack.length - bc[ip + 2],
                bc[ip + 2],
                peg$consts[bc[ip + 1]].apply(null, params)
              );

              ip += 4 + bc[ip + 3];
              break;

            case 23:
              stack.push(peg$parseRule(bc[ip + 1]));
              ip += 2;
              break;

            case 24:
              peg$silentFails++;
              ip++;
              break;

            case 25:
              peg$silentFails--;
              ip++;
              break;

            default:
              throw new Error("Invalid opcode: " + bc[ip] + ".");
          }
        }

        if (ends.length > 0) {
          end = ends.pop();
          ip = ips.pop();
        } else {
          break;
        }
      }

      return stack[0];
    }


    /*jshint laxcomma:false */

    var DoctypeExpression          = require("./ast/doctype");
    var RootNodeExpression         = require("./ast/rootNode");
    var TextNodeExpression         = require("./ast/textNode");
    var CommentNodeExpression      = require("./ast/commentNode");
    var ElementNodeExpression      = require("./ast/elementNode");
    var BlockBindingExpression     = require("./ast/blockBinding");
    var DocTypeExpression          = require("./ast/doctype");
    var TernaryConditionExpression = require("./ast/ternaryCondition");
    var AssignmentExpression       = require("./ast/assignment");
    var OperatorExpression         = require("./ast/operator");
    var NotExpression              = require("./ast/not");
    var LiteralExpression          = require("./ast/literal");
    var StringExpression           = require("./ast/string");
    var ReferenceExpression        = require("./ast/reference");
    var HashExpression             = require("./ast/hash");
    var ScriptExpression           = require("./ast/script");
    var CallExpression             = require("./ast/call");
    var ModifierExpression         = require("./ast/modifier");
    var ArrayExpression            = require("./ast/array");
    var ParametersExpression       = require("./ast/parameters");
    var GroupExpression            = require("./ast/group");

    function trimWhitespace(ws) {
      return trimNewLineChars(ws).replace(/(^\s+)|(\s+$)/, "");
    }

    function trimEnds(ws) {
      return ws.replace(/(^\s+)|(\s+$)/, "").replace(/[\r\n]/g, "\\n");
    }

    function trimNewLineChars(ws) {
      return ws.replace(/[ \r\n\t]+/g, " ");
    }

    function trimmedText() {
      return trimWhitespace(text());
    }

    function singleOrArrayExpression(values) {
      return values.length === 1 ? values[0] : new ArrayExpression(new ParametersExpression(values));
    }

    function attrValues(values) {

      values = values.filter(function(v) {
        return !/^[\n\t\r]+$/.test(v.value);
      });

      if (!values.length) {
        return new LiteralExpression(true);
      }

      if (values.length === 1 && values[0].type === "string") {
        return values[0];
      } else {
        return new ArrayExpression(new ParametersExpression(values));
      }
    }

    function trimTextExpressions(expressions) {

      function _trim(exprs) {
        var expr;
        for (var i = exprs.length; i--;) {
          expr = exprs[i];
          if (expr.type == "textNode" && !/\S/.test(expr.value) && !expr.decoded) {
            exprs.splice(i, 1);
          } else {
            break;
          }
        }
        return exprs;
      }

      return _trim(_trim(expressions.reverse()).reverse());
    }



    peg$result = peg$parseRule(peg$startRuleIndex);

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})();