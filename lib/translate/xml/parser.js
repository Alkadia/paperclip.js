// Generated by CoffeeScript 1.6.2
var AttributeExpression, AttributesExpression, BaseParser, BindingExpression, ChildrenExpression, NodeExpression, Parser, StringExpression, TextBindingExpression, TextExpression, TextStringExpression, TokenCodes, Tokenizer, bindingParser,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BaseParser = require("../base/parser");

Tokenizer = require("./tokenizer");

TokenCodes = Tokenizer.Codes;

bindingParser = require("../binding/parser");

NodeExpression = require("./expressions/node");

TextExpression = require("./expressions/text");

StringExpression = require("./expressions/string");

BindingExpression = require("./expressions/binding");

ChildrenExpression = require("./expressions/children");

AttributeExpression = require("./expressions/attribute");

AttributesExpression = require("./expressions/attributes");

TextStringExpression = require("./expressions/textString");

TextBindingExpression = require("./expressions/textBinding");

Parser = (function(_super) {
  __extends(Parser, _super);

  /*
  */


  function Parser() {
    Parser.__super__.constructor.call(this);
    this._t = new Tokenizer();
  }

  /*
  */


  Parser.prototype._parse = function() {
    var expressions, i;

    expressions = [];
    i = 0;
    this._nextCode();
    while (this._t.current && i++ < 20) {
      expressions.push(this._parseExpression());
    }
    return new ChildrenExpression(expressions);
  };

  /*
  */


  Parser.prototype._parseExpression = function() {
    var cchar;

    if ((cchar = this._currentCode()) === TokenCodes.LT) {
      return this._parseNode();
    } else {
      return this._parseText();
    }
  };

  /*
  */


  Parser.prototype._parseNode = function() {
    var attributes, cchar, children, name;

    name = this._nextString();
    this._nextCode();
    attributes = this._parseAttributes();
    children = [];
    while ((cchar = this._currentCode()) && cchar) {
      if (cchar === TokenCodes.GT) {
        this._nextCode();
        children = this._parseChildren(name);
        break;
      } else if (cchar === TokenCodes.ETNC) {
        this._nextCode();
        break;
      } else {
        this._nextCode();
      }
    }
    return new NodeExpression(name, attributes, children);
  };

  /*
  */


  Parser.prototype._parseAttributes = function() {
    var attrs, ccode;

    attrs = [];
    while (ccode = this._currentCode()) {
      if ((TokenCodes.GT | TokenCodes.ETNC) & ccode) {
        break;
      }
      if (ccode === TokenCodes.WS) {
        this._nextCode();
        continue;
      }
      attrs.push(this._parseAttribute());
    }
    return attrs;
  };

  /*
  */


  Parser.prototype._parseChildren = function(nodeName) {
    var ccode, children;

    children = [];
    while ((ccode = this._currentCode()) && ccode) {
      if ((TokenCodes.GT | TokenCodes.EBLOCK) & ccode) {
        break;
      }
      if (ccode === TokenCodes.ETAG) {
        this._nextCode();
        break;
      }
      if (ccode === TokenCodes.WS) {
        this._nextCode();
        continue;
      }
      children.push(this._parseExpression());
    }
    return children;
  };

  /*
  */


  Parser.prototype._parseAttribute = function() {
    var name, value;

    name = this._currentString();
    if (this._nextCode() === TokenCodes.EQ) {
      this._nextCode();
      value = this._parseAttributeValue();
    }
    return new AttributeExpression(name, value);
  };

  /*
  */


  Parser.prototype._parseAttributeValue = function() {
    var ret;

    this._nextCode();
    ret = this._parseTextUntil(TokenCodes.QUOTE);
    this._nextCode();
    return ret;
  };

  /*
  */


  Parser.prototype._parseText = function() {
    return this._parseTextUntil(TokenCodes.EBLOCK | TokenCodes.LT | TokenCodes.ETAG);
  };

  /*
  */


  Parser.prototype._parseTextUntil = function(scode) {
    var ccode, items, str;

    items = [];
    while (!((ccode = this._currentCode()) & scode) && ccode) {
      if (ccode === TokenCodes.LM) {
        items.push(this._parseTextBinding());
      } else {
        str = this._parseTextString(TokenCodes.LM | scode);
        if (str) {
          items.push(str);
        }
      }
    }
    return new TextExpression(items);
  };

  /*
  */


  Parser.prototype._parseTextString = function(scode) {
    var buffer, ccode;

    buffer = [];
    while (!((ccode = this._currentCode()) & scode) && ccode) {
      buffer.push(this._currentString());
      this._nextCode();
    }
    if (buffer.join("").match(/^\s$/)) {
      return null;
    }
    return new TextStringExpression(new StringExpression(buffer.join("").replace(/^\s+/, "").replace(/\s$/, "")));
  };

  /*
  */


  Parser.prototype._parseTextBinding = function() {
    var buffer, ccode, children, hasChildren, script;

    this._nextCode();
    if (this._currentCode() === TokenCodes.HASH) {
      hasChildren = true;
      this._nextCode();
    }
    buffer = [];
    children = [];
    while (((ccode = this._currentCode()) !== TokenCodes.RM) && ccode) {
      buffer.push(this._currentString());
      this._nextCode();
    }
    script = bindingParser.parse(buffer.join(""));
    this._nextCode();
    if (hasChildren) {
      while ((ccode = this._currentCode()) !== TokenCodes.EBLOCK && ccode) {
        children.push(this._parseExpression());
      }
      this._nextCode();
    }
    return new BindingExpression(script, children);
  };

  return Parser;

})(BaseParser);

module.exports = Parser;
