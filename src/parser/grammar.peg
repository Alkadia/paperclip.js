
Start
  = ChildNodes

ChildNodes
  = (Text/Binding/Element)*

Element
  = startTag:StartTag children:ChildNodes endTag:EndTag {

    if (startTag.name != endTag.name) {
      expected("</" + startTag.name + ">");
    }

    return {
      type: "element",
      name: startTag.name,
      children: children
    };
  }
  / StartTag
  / StartEndTag



Text
  = value:TextCharacter+ {
    return {
      type: "text",
      value: value.join("")
    }
  }

TextCharacter
  = !("<"/"{{") SourceCharacter {
      return text()
    }
  


StartTag
  = "<" info:TagInfo ">" { return info; }

StartEndTag
  = "<" info:TagInfo "/>" { return info; }

TagInfo
  = name:TagName Zs* attributes:Attribute* {
      return {
        name: name,
        attributes: attributes
      };
    }

EndTag
  = "</" name:TagName ">" {
      return {
        name: name
      };
    }


TagName
  = Zs* word:Word { return word; }

Attribute
  = name:TagName "=" string:StringLiteral {
      return {
        name: name,
        value: string.value
      };
    }
  / name:TagName {
      return {
        name: name
      }
    }

Zs 
  = [\u0020\u00A0\u1680\u2000-\u200A\u202F\u205F\u3000]

Binding
  = "{" script:Scripts "}" {
    return {
      type: "binding",
      scripts: script
    };
  }

Scripts
  = scripts:Object {
    var s = {};
    for (i = 0, n = scripts.value.length; i < n; i++) {
      s[scripts.value[i].key] = scripts.value[i];
    }
    return s;
  }
  / "{" script:Script "}" {
    return {
      value: script
    };
  }

Script
  = Zs* expression:Expression Zs* {
    return expression;
  }

Expression
  = Zs* expression:(Group / Object / Operation / StringLiteral) Zs* {
    return expression;
  }

Operation
  = Operatable

Equation
  = first:Multiplicative

Multiplicative
  =

Additive
  = 

Operatable
  = Reference
  / Number

Number
  = value:("-"? ([0-9]+DecimalNumber? / DecimalNumber)) { return { type: "number", value: parseFloat(text()) }; }
  
DecimalNumber
  = "." [0-9]+

Group
  = "(" Expression ")"

Reference
  = name:[a-z]+ { 
    return {
      type: "reference",
      value: name[0]
    }
  }

Object
  = "{" Zs* values:ObjectValues? Zs* "}" {
      return {
        type: "object",
        value: values
      }
    }

ObjectValues 
  = firstValue:ObjectValue additionalValues:("," ObjectValues)* {
    return [
      firstValue
    ].concat(additionalValues.length ? additionalValues[0][1] : []);
  }

ObjectValue
  = key:ObjectKey ":" value:Expression {
    return {
      key: key.value,
      value: value.value
    }
  }

ObjectKey
  = Zs* key:(StringLiteral/Reference) { return key; }


StringLiteral "string"
  = '"' chars:DoubleStringCharacter* '"' {
      return { type: "string", value: chars.join("") };
    }
  / "'" chars:SingleStringCharacter* "'" {
      return { type: "string", value: chars.join("") };
    }


DoubleStringCharacter
  = !('"' / "\\") SourceCharacter { return text(); }
  / '\\"'


SingleStringCharacter
  = !("'" / "\\") SourceCharacter { return text(); }
  / "\\'"

SourceCharacter
  = .

Word
  = chars:[a-z]+ { return chars.join(""); }


