{
  var StringExpression = require("./ast/string");
}

Start
  = ChildNodes

DocType
  = "<!DOCTYPE" _ info:[^>]+ _ ">" { 
      return {
        type: "doctype", 
        value: info.join("")
      }
    }

ChildNodes
  = (TextNode/BindingBlock/CommentNode/ElementNode)*  

CommentNode
  = _ "<!--" value:(!"-->" v:SourceCharacter { return v; })+ "-->" _ {
    return {
      type: "commentNode",
      value: value.join("")
    }
  }
  / DocType

ElementNode
  = startTag:StartTag children:ChildNodes endTag:EndTag _ {

    if (startTag.name != endTag.name) {
      expected("</" + startTag.name + ">");
    }

    return {
      type: "elementNode",
      name: startTag.name,
      attributes: startTag.attributes,
      children: children
    };
  }
  / StartTag
  / StartEndTag

TextNode
  = value:TextCharacter+ {
      return {
        type: "textNode",
        value: value.join("")
      }
    }

TextCharacter
  = !("<"/"{{") SourceCharacter {
      return text()
    }
  
StartTag
  = _ "<" info:TagInfo ">" _ { return info; }

StartEndTag
  = _ "<" info:TagInfo "/>" _ { return info; }

TagInfo
  = name:TagName _ attributes:Attribute* _ {
      return {
        name: name,
        attributes: attributes
      };
    }

EndTag
  = "</" name:TagName ">" {
      return {
        name: name
      };
    }


TagName
  = _ word:[a-zA-Z0-9:_-]+ { return text(); }

Attribute
  = name:TagName _ "=" _ values:AttributeValues {
      return {
        name: name,
        value: values
      };
    }
  / name:TagName {
      return {
        name: name
      }
    }


AttributeValues
  = '"' values:(Binding/(!"{{" [^"])+ { return text(); })* '"' { return values.length > 1 ? values : values[0]; }
  / "'" values:(Binding/(!"{{" [^'])+ { return text(); })* "'" { return values.length > 1 ? values : values[0]; }
  / Binding



BindingBlock
  = "{{#" bindingBlock:StartBindingBlock { return bindingBlock; }
  / Binding


StartBindingBlock
  = scripts:Scripts "}}" _ fragment:ChildNodes _ child:ChildBindingBlock {
    return {
      type: "bindingBlock",
      scripts: scripts,
      fragment: fragment,
      child: child
    }
  }

ChildBindingBlock
  = "{{/" bindingBlock:StartBindingBlock { return bindingBlock; }
  / "{{/}}" _ { return void 0; }

Binding
  = "{{" _ script:Scripts _ "}}" {
      return {
        type: "binding",
        scripts: script
      };
    }

Scripts
  = scripts:HashValues {
        var s = {};
      for (i = 0, n = scripts.length; i < n; i++) {
        s[scripts[i].key] = scripts[i].value;
      }
      return s;
    }
  / script:Script {
      return {
        value: script
      };
    }

Script
  = _ expression:TerneryConditional _ {
    return expression;
  }

Expression 
  = TerneryConditional

TerneryConditional
  = condition:Assignment "?" left:TerneryConditional ":" right:TerneryConditional {
      return {
        type: "condition",
        condition: condition,
        left: left,
        right: right
      }
    }
  / Assignment



Parameters
  = "(" params:InnerParameters ")" {
      return params;
    }
  / "()" { return []; }

InnerParameters
  = param1:Expression rest:("," Expression)* {
      return [param1].concat(rest.map(function (v) {
        return v[1];
      }));
    }

Assignment
  = left:ObjectReference "=" right:Assignment {
      return {
        type: "=",
        reference: left,
        value: right
      };
    }
  / Operation

Operation 
  = left:Operatable operator: ("&&" / "||" / "===" / "==" / "!==" / "!=" / ">==" / ">=" / ">" / "<==" / "<=" / "<" / "+" / "-" / "%" / "*" / "/") right:Operation {
      return {
        type: operator,
        left: left,
        right: right
      }
    }
  / Operatable


Operatable 
  = _ value:Not modifiers:("|" Modifier)*_ { 
      value.modifiers = modifiers.map(function (modifier) {
        return modifier[1];
      });
      return value; 
    }

Modifier
  = call:(FunctionCall/Object) _ {
    return {
      type: "call",
      reference: call.reference || call,
      parameters: call.parameters || []
    };
  }
  

ObjectReference
  = _ context:Object path:("." ReferenceName)* _ {
      context.path = path.map(function (p) { return p[1] })
      return context;
    }

Not
  = not:"!" value:Not {
      return { 
        type: "!",
        value: value
      }
    }
  / Reserved / FunctionCall / ObjectReference



Object
  = Group/Hash/Number/StringLiteral/Reference


Number
  = value:("-"? ([0-9]+DecimalNumber? / DecimalNumber)) { return { type: "number", value: parseFloat(text()) }; }
  
DecimalNumber
  = "." [0-9]+

Group
  = "(" group:Expression ")" { return group; }

Reserved
  = Boolean
  / Undefined
  / Null
  / NaN
  / Infinity

Boolean 
  = value:("true"/"false") {
      return {
        type: "boolean",
        value: value === "true"
      }
    }

Undefined 
  = "undefined" { return { type: "undefined", value: void 0 }; }

NaN 
  = "NaN" { return { type: "nan", value: NaN }; }

Infinity 
  = "Infinity" { return { type: "infinity", value: Infinity }; }

Null
  = ("null"/"NULL") { return { type: "null", value: null }; }

FunctionCall
  = reference:ObjectReference parameters:Parameters {
      return {
        type: "call",
        reference: reference,
        parameters: parameters
      };
    }

Reference
  = bindingType:("~>"/"<~>"/"~"/"<~")? _ reference:ReferenceName {
      return {
        type: "reference",
        bindingType: bindingType,
        value: reference
      }
    }


ReferenceName
  = name:[a-zA-Z_$0-9]+ { return text(); }

Hash
  = "{" _ values:HashValues? _ "}" {
      return {
        type: "object",
        value: values
      }
    }

HashValues 
  = firstValue:HashValue additionalValues:("," HashValues)* {
      return [
        firstValue
      ].concat(additionalValues.length ? additionalValues[0][1] : []);
    }

HashValue
  = _ key:HashKey _":" value:Expression? {
      return {
        key: key,
        value: value || void 0
      }
    }

HashKey
  = key:StringLiteral { return key.value; }
  / key:ReferenceName { return key; } 



StringLiteral "string"
  = '"' chars:DoubleStringCharacter* '"' {
      return { type: "string", value: chars.join("") };
    }
  / "'" chars:SingleStringCharacter* "'" {
      return { type: "string", value: chars.join("") };
    }


DoubleStringCharacter
  = !('"' / "\\") SourceCharacter { return text(); }
  / '\\"'


SingleStringCharacter
  = !("'" / "\\") SourceCharacter { return text(); }
  / "\\'"

SourceCharacter
  = .

Word
  = chars:[a-zA-Z]+ { return chars.join(""); }

_ 
  = [ \n\r\t]*

