{
  var DoctypeExpression        = require("./ast/doctype"),
  RootNodeExpression           = require("./ast/rootNode"),
  TextNodeExpression           = require("./ast/textNode"),
  CommentNodeExpression        = require("./ast/commentNode"),
  ElementNodeExpression        = require("./ast/elementNode"),
  BlockBindingExpression       = require("./ast/blockBinding"),
  TextBindingExpression        = require("./ast/textBinding"),
  TernaryConditionExpression   = require("./ast/ternaryCondition"),
  AssignmentExpression         = require("./ast/assignment"),
  OperatorExpression           = require("./ast/operator"),
  NotExpression                = require("./ast/not"),
  LiteralExpression            = require("./ast/literal"),
  StringExpression             = require("./ast/string"),
  ReferenceExpression          = require("./ast/reference"),
  HashExpression               = require("./ast/hash"),
  ScriptExpression             = require("./ast/script"),
  CallExpression               = require("./ast/call"),
  ModifierExpression           = require("./ast/modifier"),
  PropertyExpression           = require("./ast/property");
}

Start
  = children:ChildNodes { return new RootNodeExpression(children); }

DocType
  = "<!DOCTYPE" _ info:[^>]+ _ ">" { 
      return {
        type: "doctype", 
        value: info.join("")
      }
    }

ChildNodes
  = (TextNode/BlockBinding/CommentNode/ElementNode)*  

CommentNode
  = _ "<!--" value:(!"-->" v:SourceCharacter { return v; })+ "-->" _ {
    return new CommentNodeExpression(value.join(""));
  }
  / DocType

ElementNode
  = startTag:StartTag children:ChildNodes endTag:EndTag _ {

    if (startTag.name != endTag.name) {
      expected("</" + startTag.name + ">");
    }

    return new ElementNodeExpression(startTag.name, startTag.attributes, children);
  }
  / StartEndTag

TextNode
  = value:TextCharacter+ {
      return new TextNodeExpression(value.join(""))
    }

TextCharacter
  = !("<"/"{{") SourceCharacter {
      return text()
    }
  
StartTag
  = _ "<" info:TagInfo ">" _ { return info; }

StartEndTag
  = _ "<" info:TagInfo "/>" _ { return new ElementNodeExpression(info.name, info.attributes); }

TagInfo
  = name:TagName _ attributes:Attribute* _ {
      return {
        name: name,
        attributes: attributes
      };
    }

EndTag
  = "</" name:TagName ">" {
      return {
        name: name
      };
    }


TagName
  = _ word:[a-zA-Z0-9:_-]+ { return text(); }

Attribute
  = name:TagName _ "=" _ values:AttributeValues {
      return {
        name: name,
        value: values
      };
    }
  / name:TagName {
      return {
        name: name
      }
    }


AttributeValues
  = '"' values:(TextBinding/(!"{{" [^"])+ { return text(); })* '"' { return values.length > 1 ? values : values[0]; }
  / "'" values:(TextBinding/(!"{{" [^'])+ { return text(); })* "'" { return values.length > 1 ? values : values[0]; }
  / TextBinding



BlockBinding
  = "{{#" blockBinding:StartBlockBinding { return blockBinding; }
  / TextBinding


StartBlockBinding
  = scripts:Scripts "}}" _ fragment:ChildNodes _ child:ChildBlockBinding {
      return new BlockBindingExpression(scripts, fragment, child);
  }

ChildBlockBinding
  = "{{/" blockBinding:StartBlockBinding { return blockBinding; }
  / "{{/}}" _ { return void 0; }

TextBinding
  = "{{" _ scripts:Scripts _ "}}" {
      return new TextBindingExpression(scripts);
    }

Scripts
  = scripts:HashValues {
        var s = {};
      for (i = 0, n = scripts.length; i < n; i++) {
        s[scripts[i].key] = scripts[i].value;
      }
      return s;
    }
  / script:Script {
      return new ScriptExpression(script);
    }

Script
  = _ expression:TernaryConditional _ {
    return expression;
  }

Expression 
  = TernaryConditional

TernaryConditional
  = condition:Assignment "?" left:TernaryConditional ":" right:TernaryConditional {
      return new TernaryConditionExpression(condition, left, right);
    }
  / Assignment



Parameters
  = "(" params:InnerParameters ")" {
      return params;
    }
  / "()" { return []; }

InnerParameters
  = param1:Expression rest:("," Expression)* {
      return [param1].concat(rest.map(function (v) {
        return v[1];
      }));
    }

Assignment
  = left:ObjectReference "=" right:Assignment {
      return new AssignmentExpression(left, right);
    }
  / Operation

Operation 
  = left:Operatable operator: ("&&" / "||" / "===" / "==" / "!==" / "!=" / ">==" / ">=" / ">" / "<==" / "<=" / "<" / "+" / "-" / "%" / "*" / "/") right:Operation {
      return new OperatorExpression(operator, left, right);
    }
  / Operatable


Operatable
  = _ value:Modifiers _ { return value; }

Modifiers
  = expression:Not modifiers:Modifier* {

      for (var i = 0, n = modifiers.length; i < n; i++) {
        expression = new ModifierExpression(expression, modifiers[i].reference, modifiers[i].parameters);
      }

      return expression;
    }
  / (FunctionCall/ObjectReference)

Modifier 
  = "|" _ call:(FunctionCall/ObjectReference) _ {
    return {
      reference: call.reference || call,
      parameters: call.parameters || []
    }
  }


ObjectReference
  = _ context:Object path:("." ReferenceName)* _ {
      if (!path.length) return context;
      return new PropertyExpression(context, path.map(function (p) { return p[1] }));
    }

Not
  = not:"!" value:Not {
      return new NotExpression(value);
    }
  / Reserved/FunctionCall/ObjectReference

Object
  = Group/Hash/Number/StringLiteral/Reference

Number
  = value:("-"? ([0-9]+DecimalNumber? / DecimalNumber)) { 
      return new LiteralExpression(parseFloat(text()));
    }
  
DecimalNumber
  = "." [0-9]+

Group
  = "(" group:Expression ")" { return group; }

Reserved
  = expression:(Boolean / Undefined / Null / NaN / Infinity) {
      return new LiteralExpression(expression.value);
    }

Boolean 
  = value:("true"/"false") {
      return {
        type: "boolean",
        value: value === "true"
      }
    }

Undefined 
  = "undefined" { return { type: "undefined", value: void 0 }; }

NaN 
  = "NaN" { return { type: "nan", value: NaN }; }

Infinity 
  = "Infinity" { return { type: "infinity", value: Infinity }; }

Null
  = ("null"/"NULL") { return { type: "null", value: null }; }

FunctionCall
  = reference:ObjectReference parameters:Parameters {
      return new CallExpression(reference, parameters);
    }

Reference
  = bindingType:("~>"/"<~>"/"~"/"<~")? _ reference:ReferenceName {
      return new ReferenceExpression(reference, bindingType);
    }

ReferenceName
  = name:[a-zA-Z_$0-9]+ { return text(); }

Hash
  = "{" _ values:HashValues? _ "}" {
      return new HashExpression(values);
    }

HashValues 
  = firstValue:HashValue additionalValues:("," HashValues)* {
      return [
        firstValue
      ].concat(additionalValues.length ? additionalValues[0][1] : []);
    }

HashValue
  = _ key:HashKey _":" value:Expression? {
      return {
        key: key,
        value: value || void 0
      }
    }

HashKey
  = key:StringLiteral { return key.value; }
  / key:ReferenceName { return key; } 



StringLiteral "string"
  = '"' chars:DoubleStringCharacter* '"' {
      return new StringExpression(chars.join(""));
    }
  / "'" chars:SingleStringCharacter* "'" {
      return new StringExpression(chars.join(""));
    }


DoubleStringCharacter
  = !('"' / "\\") SourceCharacter { return text(); }
  / '\\"'


SingleStringCharacter
  = !("'" / "\\") SourceCharacter { return text(); }
  / "\\'"

SourceCharacter
  = .

Word
  = chars:[a-zA-Z]+ { return chars.join(""); }

_ 
  = [ \n\r\t]*

