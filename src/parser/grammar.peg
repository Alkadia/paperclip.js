
Start
  = ChildNodes

ChildNodes
  = (Text/Binding/Element)*

Element
  = startTag:StartTag children:ChildNodes endTag:EndTag {

    if (startTag.name != endTag.name) {
      expected("</" + startTag.name + ">");
    }

    return {
      type: "element",
      name: startTag.name,
      children: children
    };
  }
  / StartTag
  / StartEndTag



Text
  = value:TextCharacter+ {
    return {
      type: "text",
      value: value.join("")
    }
  }

TextCharacter
  = !("<"/"{{") SourceCharacter {
      return text()
    }
  

StartTag
  = "<" info:TagInfo ">" { return info; }

StartEndTag
  = "<" info:TagInfo "/>" { return info; }

TagInfo
  = name:TagName _ attributes:Attribute* {
      return {
        name: name,
        attributes: attributes
      };
    }

EndTag
  = "</" name:TagName ">" {
      return {
        name: name
      };
    }


TagName
  = _ word:Word { return word; }

Attribute
  = name:TagName "=" string:StringLiteral {
      return {
        name: name,
        value: string.value
      };
    }
  / name:TagName {
      return {
        name: name
      }
    }

Binding
  = "{" script:Scripts "}" {
    return {
      type: "binding",
      scripts: script
    };
  }

Scripts
  = scripts:Object {
    var s = {};
    for (i = 0, n = scripts.value.length; i < n; i++) {
      s[scripts.value[i].key] = scripts.value[i];
    }
    return s;
  }
  / "{" script:Script "}" {
    return {
      value: script
    };
  }

Script
  = _ expression:TerneryConditional _ {
    return expression;
  }

TerneryConditional
  = condition:Expression "?" left:TerneryConditional ":" right:Expression {
    return {
      type: "condition",
      condition: condition,
      left: left,
      right: right
    }
  }
  / Expression


Expression
  = _ expression:(Group / Object / Operation / Operatable) _ {
    return expression;
  }

Operation
  = Comparison

Comparison
  = left:Additive operator:("&&"/"||"/"=="/"==="/">"/">="/">=="/"<"/"<="/"<==") right:Comparison {
    return {
      type: operator,
      left: left,
      right: right
    }
  }
  / Additive

Additive
  = left:Modulative operation:("+"/"-") right:Additive {
    return {
      type: operation,
      left: left,
      right: right
    }
  }
  / Modulative

Modulative
  = left:Multiplicative operation:"%" right:Modulative {
    return {
      type: operation,
      left: left,
      right: right
    }
  }
  / Multiplicative

Multiplicative
  = left:Operatable operation:("*"/"/") right:Multiplicative {
    return {
      type: operation,
      left: left,
      right: right
    }
  }
  / Operatable

Operatable 
  = _ value:(Group/Object/Reserved/Reference/Number/StringLiteral) _ { return value; }

Number
  = value:("-"? ([0-9]+DecimalNumber? / DecimalNumber)) { return { type: "number", value: parseFloat(text()) }; }
  
DecimalNumber
  = "." [0-9]+

Group
  = "(" group:Expression ")" { return group; }

Reserved
  = Boolean
  / Undefined
  / Null

Boolean 
  = value:("true"/"false") {
    return {
      type: "boolean",
      value: value === "true"
    }
  }

Undefined 
  = "undefined" { return { type: "undefined", value: void 0 }; }

Null
  = ("null"/"NULL") { return { type: "null", value: null }; }

Reference
  = name:[a-z]+ { 
    return {
      type: "reference",
      value: text()
    }
  }

Object
  = "{" _ values:ObjectValues? _ "}" {
      return {
        type: "object",
        value: values
      }
    }

ObjectValues 
  = firstValue:ObjectValue additionalValues:("," ObjectValues)* {
    return [
      firstValue
    ].concat(additionalValues.length ? additionalValues[0][1] : []);
  }

ObjectValue
  = key:ObjectKey ":" value:Expression {
    return {
      key: key.value,
      value: value.value
    }
  }

ObjectKey
  = _ key:(StringLiteral/Reference) { return key; }


StringLiteral "string"
  = '"' chars:DoubleStringCharacter* '"' {
      return { type: "string", value: chars.join("") };
    }
  / "'" chars:SingleStringCharacter* "'" {
      return { type: "string", value: chars.join("") };
    }


DoubleStringCharacter
  = !('"' / "\\") SourceCharacter { return text(); }
  / '\\"'


SingleStringCharacter
  = !("'" / "\\") SourceCharacter { return text(); }
  / "\\'"

SourceCharacter
  = .

Word
  = chars:[a-z]+ { return chars.join(""); }

Zs 
  = [\u0020\u00A0\u1680\u2000-\u200A\u202F\u205F\u3000]

_ 
  = Zs*

