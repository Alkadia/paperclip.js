
Start
  = ChildNodes

ChildNodes
  = (Text/Binding/Element)*

Element
  = startTag:StartTag children:ChildNodes endTag:EndTag {

    if (startTag.name != endTag.name) {
      expected("</" + startTag.name + ">");
    }

    return {
      type: "element",
      name: startTag.name,
      attributes: startTag.attributes,
      children: children
    };
  }
  / StartTag
  / StartEndTag



Text
  = value:TextCharacter+ {
      return {
        type: "text",
        value: value.join("")
      }
    }

TextCharacter
  = !("<"/"{{") SourceCharacter {
      return text()
    }
  

StartTag
  = "<" info:TagInfo ">" { return info; }

StartEndTag
  = "<" info:TagInfo "/>" { return info; }

TagInfo
  = name:TagName _ attributes:Attribute* {
      return {
        name: name,
        attributes: attributes
      };
    }

EndTag
  = "</" name:TagName ">" {
      return {
        name: name
      };
    }


TagName
  = _ word:[a-zA-Z0-9:_-]+ { return text(); }

Attribute
  = name:TagName "=" value:StringLiteral {
      return {
        name: name,
        value: value.value
      };
    }
  / name:TagName {
      return {
        name: name
      }
    }

Binding
  = "{" script:Scripts "}" {
      return {
        type: "binding",
        scripts: script
      };
    }

Scripts
  = scripts:Hash {
      var s = {};
      for (i = 0, n = scripts.value.length; i < n; i++) {
        s[scripts.value[i].key] = scripts.value[i];
      }
      return s;
    }
  / "{" script:Script "}" {
      return {
        value: script
      };
    }

Script
  = _ expression:TerneryConditional _ {
    return expression;
  }

TerneryConditional
  = condition:Expression "?" left:TerneryConditional ":" right:Expression {
      return {
        type: "condition",
        condition: condition,
        left: left,
        right: right
      }
    }
  / Expression


Parameters
  = "(" param1:Expression rest:("," Expression)* ")" {
      return [param1].concat(rest.map(function (v) {
        return v[1];
      }));
    }
  / "()" { return []; }


Expression
  = Assignment

Assignment
  = left:ObjectReference "=" right:Assignment {
      return {
        type: "=",
        reference: left,
        value: right
      };
    }
  / Comparison

Comparison
  = left:Additive operator:("&&" / "||" / "===" / "==" / ">==" / ">=" / ">" / "<==" / "<=" / "<") right:Comparison {
      return {
        type: operator,
        left: left,
        right: right
      }
    }
  / Additive

Additive
  = left:Modulative operation:("+"/"-") right:Additive {
      return {
        type: operation,
        left: left,
        right: right
      };
    }
  / Modulative

Modulative
  = left:Multiplicative operation:"%" right:Modulative {
      return {
        type: operation,
        left: left,
        right: right
      }
    }
  / Multiplicative

Multiplicative
  = left:Operatable operation:("*"/"/") right:Multiplicative {
      return {
        type: operation,
        left: left,
        right: right
      }
    }
  / Operatable


Operatable 
  = _ value:(Group/Hash/Reserved/FunctionCall/ObjectReference) modifiers:("|" Modifier)*_ { 
      value.modifiers = modifiers.map(function (modifier) {
        return modifier[1];
      });
      return value; 
    }

Modifier
  = call:(FunctionCall/Object) {
    return {
      type: "call",
      reference: call.reference || call,
      parameters: call.parameters || []
    };
  }
  

ObjectReference
  = _ context:Object path:("." ReferenceName)* _ {
      context.path = path.map(function (p) { return p[1] })
      return context;
    }

Object
  = Group/Hash/Hash/Number/StringLiteral/Reference


Number
  = value:("-"? ([0-9]+DecimalNumber? / DecimalNumber)) { return { type: "number", value: parseFloat(text()) }; }
  
DecimalNumber
  = "." [0-9]+

Group
  = "(" group:Expression ")" { return group; }

Reserved
  = Boolean
  / Undefined
  / Null
  / NaN
  / Infinity

Boolean 
  = value:("true"/"false") {
      return {
        type: "boolean",
        value: value === "true"
      }
    }

Undefined 
  = "undefined" { return { type: "undefined", value: void 0 }; }

NaN 
  = "NaN" { return { type: "nan", value: NaN }; }

Infinity 
  = "Infinity" { return { type: "infinity", value: Infinity }; }

Null
  = ("null"/"NULL") { return { type: "null", value: null }; }

FunctionCall
  = reference:ObjectReference parameters:Parameters {
      return {
        type: "call",
        reference: reference,
        parameters: parameters
      };
    }

Reference
  = bindingType:("~>"/"<~>"/"~"/"<~")? _ reference:ReferenceName {
      return {
        type: "reference",
        bindingType: bindingType,
        value: reference
      }
    }


ReferenceName
  = name:[a-zA-Z]+ { return text(); }

Hash
  = "{" _ values:HashValues? _ "}" {
      return {
        type: "object",
        value: values
      }
    }

HashValues 
  = firstValue:HashValue additionalValues:("," HashValues)* {
      return [
        firstValue
      ].concat(additionalValues.length ? additionalValues[0][1] : []);
    }

HashValue
  = key:HashKey ":" value:Expression {
      return {
        key: key,
        value: value
      }
    }

HashKey
  = _ key:StringLiteral { return key.value; }
  / _ key:ReferenceName { return key; } 



StringLiteral "string"
  = '"' chars:DoubleStringCharacter* '"' {
      return { type: "string", value: chars.join("") };
    }
  / "'" chars:SingleStringCharacter* "'" {
      return { type: "string", value: chars.join("") };
    }


DoubleStringCharacter
  = !('"' / "\\") SourceCharacter { return text(); }
  / '\\"'


SingleStringCharacter
  = !("'" / "\\") SourceCharacter { return text(); }
  / "\\'"

SourceCharacter
  = .

Word
  = chars:[a-zA-Z]+ { return chars.join(""); }

_ 
  = [ \n\r\t]*

