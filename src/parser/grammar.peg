{
  var StringExpression = require("./ast/string");
}

Start
  = ChildNodes

ChildNodes
  = _ children:(TextNode/BindingBlock/CommentNode/ElementNode)* _  { 
    ws = /^[\s\n\r\t]+$/

    // trim
    while (children.length && children[0].type == "textNode" && ws.test(children[0].value)) 
      children.splice(0, 1);
    

    while (children.length && children[children.length-1].type === "textNode" && ws.test(children[children.length-1].value))
      children.splice(children.length-1, 1);
    
    return children;
  }

CommentNode
  = "<!--" value:(!"-->" v:SourceCharacter { return v; })+ "-->" {
    return {
      type: "commentNode",
      value: value.join("")
    }
  }

ElementNode
  = startTag:StartTag children:ChildNodes endTag:EndTag {

    if (startTag.name != endTag.name) {
      expected("</" + startTag.name + ">");
    }

    return {
      type: "elementNode",
      name: startTag.name,
      attributes: startTag.attributes,
      children: children
    };
  }
  / StartTag
  / StartEndTag

TextNode
  = value:TextCharacter+ {
      return {
        type: "textNode",
        value: value.join("")
      }
    }

TextCharacter
  = !("<"/"{{") SourceCharacter {
      return text()
    }
  
StartTag
  = "<" info:TagInfo ">" { return info; }

StartEndTag
  = "<" info:TagInfo "/>" { return info; }

TagInfo
  = name:TagName _ attributes:Attribute* _ {
      return {
        name: name,
        attributes: attributes
      };
    }

EndTag
  = "</" name:TagName ">" {
      return {
        name: name
      };
    }


TagName
  = _ word:[a-zA-Z0-9:_-]+ { return text(); }

Attribute
  = name:TagName "=" values:AttributeValues {
      return {
        name: name,
        value: values
      };
    }
  / name:TagName {
      return {
        name: name
      }
    }


AttributeValues
  = '"' values:(Binding/(!"{{" [^"])+ { return text(); })* '"' { return values; }
  / "'" values:(Binding/(!"{{" [^'])+ { return text(); })* "'" { return values; }



BindingBlock
  = "{{#" bindingBlock:StartBindingBlock { return bindingBlock; }
  / Binding


StartBindingBlock
  = scripts:Scripts "}}" fragment:ChildNodes child:ChildBindingBlock {
    return {
      type: "bindingBlock",
      scripts: scripts,
      fragment: fragment,
      child: child
    }
  }

ChildBindingBlock
  = "{{/" bindingBlock:StartBindingBlock { return bindingBlock; }
  / "{{/}}" { return void 0; }

Binding
  = "{{" script:Scripts "}}" {
      return {
        type: "binding",
        scripts: script
      };
    }

Scripts
  = scripts:HashValues {
        var s = {};
      for (i = 0, n = scripts.length; i < n; i++) {
        s[scripts[i].key] = scripts[i].value;
      }
      return s;
    }
  / script:Script {
      return {
        value: script
      };
    }

Script
  = _ expression:TerneryConditional _ {
    return expression;
  }

TerneryConditional
  = condition:Expression "?" left:TerneryConditional ":" right:Expression {
      return {
        type: "condition",
        condition: condition,
        left: left,
        right: right
      }
    }
  / Expression


Parameters
  = "(" params:InnerParameters ")" {
      return params;
    }
  / "()" { return []; }

InnerParameters
  = param1:Expression rest:("," Expression)* {
      return [param1].concat(rest.map(function (v) {
        return v[1];
      }));
    }

Expression
  = Assignment

Assignment
  = left:ObjectReference "=" right:Assignment {
      return {
        type: "=",
        reference: left,
        value: right
      };
    }
  / Comparison

Comparison
  = left:Additive operator:("&&" / "||" / "===" / "==" / "!==" / "!=" / ">==" / ">=" / ">" / "<==" / "<=" / "<") right:Comparison {
      return {
        type: operator,
        left: left,
        right: right
      }
    }
  / Additive

Additive
  = left:Modulative operation:("+"/"-") right:Additive {
      return {
        type: operation,
        left: left,
        right: right
      };
    }
  / Modulative

Modulative
  = left:Multiplicative operation:"%" right:Modulative {
      return {
        type: operation,
        left: left,
        right: right
      }
    }
  / Multiplicative

Multiplicative
  = left:Operatable operation:("*"/"/") right:Multiplicative {
      return {
        type: operation,
        left: left,
        right: right
      }
    }
  / Operatable


Operatable 
  = _ value:Not modifiers:("|" Modifier)*_ { 
      value.modifiers = modifiers.map(function (modifier) {
        return modifier[1];
      });
      return value; 
    }

Modifier
  = call:(FunctionCall/Object) {
    return {
      type: "call",
      reference: call.reference || call,
      parameters: call.parameters || []
    };
  }
  

ObjectReference
  = _ context:Object path:("." ReferenceName)* _ {
      context.path = path.map(function (p) { return p[1] })
      return context;
    }

Not
  = "!" value:Not {
      return { 
        type: "!",
        value: value
      }
    }
  / Reserved / FunctionCall / ObjectReference



Object
  = Group/Hash/Hash/Number/StringLiteral/Reference


Number
  = value:("-"? ([0-9]+DecimalNumber? / DecimalNumber)) { return { type: "number", value: parseFloat(text()) }; }
  
DecimalNumber
  = "." [0-9]+

Group
  = "(" group:Expression ")" { return group; }

Reserved
  = Boolean
  / Undefined
  / Null
  / NaN
  / Infinity

Boolean 
  = value:("true"/"false") {
      return {
        type: "boolean",
        value: value === "true"
      }
    }

Undefined 
  = "undefined" { return { type: "undefined", value: void 0 }; }

NaN 
  = "NaN" { return { type: "nan", value: NaN }; }

Infinity 
  = "Infinity" { return { type: "infinity", value: Infinity }; }

Null
  = ("null"/"NULL") { return { type: "null", value: null }; }

FunctionCall
  = reference:ObjectReference parameters:Parameters {
      return {
        type: "call",
        reference: reference,
        parameters: parameters
      };
    }

Reference
  = bindingType:("~>"/"<~>"/"~"/"<~")? _ reference:ReferenceName {
      return {
        type: "reference",
        bindingType: bindingType,
        value: reference
      }
    }


ReferenceName
  = name:[a-zA-Z]+ { return text(); }

Hash
  = "{" _ values:HashValues? _ "}" {
      return {
        type: "object",
        value: values
      }
    }

HashValues 
  = firstValue:HashValue additionalValues:("," HashValues)* {
      return [
        firstValue
      ].concat(additionalValues.length ? additionalValues[0][1] : []);
    }

HashValue
  = key:HashKey ":" value:Expression? {
      return {
        key: key,
        value: value || void 0
      }
    }

HashKey
  = _ key:StringLiteral { return key.value; }
  / _ key:ReferenceName { return key; } 



StringLiteral "string"
  = '"' chars:DoubleStringCharacter* '"' {
      return { type: "string", value: chars.join("") };
    }
  / "'" chars:SingleStringCharacter* "'" {
      return { type: "string", value: chars.join("") };
    }


DoubleStringCharacter
  = !('"' / "\\") SourceCharacter { return text(); }
  / '\\"'


SingleStringCharacter
  = !("'" / "\\") SourceCharacter { return text(); }
  / "\\'"

SourceCharacter
  = .

Word
  = chars:[a-zA-Z]+ { return chars.join(""); }

_ 
  = [ \n\r\t]*

