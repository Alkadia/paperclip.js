
Start
  = ChildNodes

ChildNodes
  = (Text/Binding/Element)*

Element
  = startTag:StartTag children:ChildNodes endTag:EndTag {

    if (startTag.name != endTag.name) {
      expected("</" + startTag.name + ">");
    }

    return {
      type: "element",
      name: startTag.name,
      attributes: startTag.attributes,
      children: children
    };
  }
  / StartTag
  / StartEndTag



Text
  = value:TextCharacter+ {
      return {
        type: "text",
        value: value.join("")
      }
    }

TextCharacter
  = !("<"/"{{") SourceCharacter {
      return text()
    }
  

StartTag
  = "<" info:TagInfo ">" { return info; }

StartEndTag
  = "<" info:TagInfo "/>" { return info; }

TagInfo
  = name:TagName _ attributes:Attribute* {
      return {
        name: name,
        attributes: attributes
      };
    }

EndTag
  = "</" name:TagName ">" {
      return {
        name: name
      };
    }


TagName
  = _ word:[a-zA-Z0-9:_-]+ { return text(); }

Attribute
  = name:TagName "=" value:StringLiteral {
      return {
        name: name,
        value: value.value
      };
    }
  / name:TagName {
      return {
        name: name
      }
    }

Binding
  = "{" script:Scripts "}" {
      return {
        type: "binding",
        scripts: script
      };
    }

Scripts
  = scripts:Object {
      var s = {};
      for (i = 0, n = scripts.value.length; i < n; i++) {
        s[scripts.value[i].key] = scripts.value[i];
      }
      return s;
    }
  / "{" script:Script "}" {
      return {
        value: script
      };
    }

Script
  = _ expression:TerneryConditional _ {
    return expression;
  }

TerneryConditional
  = condition:Expression "?" left:TerneryConditional ":" right:Expression {
      return {
        type: "condition",
        condition: condition,
        left: left,
        right: right
      }
    }
  / Expression


Parameters
  = "(" param1:Expression rest:("," Expression)* ")" {
      return 
    }
  / "()"



Expression
  = _ expression:(Group / Object / Operation / Operatable) _ {
      return expression;
    }

Operation
  = Assignment

Assignment
  = left:Reference "=" right:Assignment {
      return {
        type: "=",
        reference: left,
        value: right
      };
    }
  / Comparison

Comparison
  = left:Additive operator:("&&" / "||" / "===" / "==" / ">==" / ">=" / ">" / "<==" / "<=" / "<") right:Comparison {
      return {
        type: operator,
        left: left,
        right: right
      }
    }
  / Additive

Additive
  = left:Modulative operation:("+"/"-") right:Additive {
      return {
        type: operation,
        left: left,
        right: right
      };
    }
  / Modulative

Modulative
  = left:Multiplicative operation:"%" right:Modulative {
      return {
        type: operation,
        left: left,
        right: right
      }
    }
  / Multiplicative

Multiplicative
  = left:Operatable operation:("*"/"/") right:Multiplicative {
      return {
        type: operation,
        left: left,
        right: right
      }
    }
  / Operatable

Operatable 
  = _ value:(Group/Object/Reserved/Reference/Number/StringLiteral) modifiers:("|" Modifier)*_ { 
      return value; 
    }


Modifier
  = Operatable Parameters? {
    return {
      type: "modifier",
      parameters: "parameters"
    }
  }

Number
  = value:("-"? ([0-9]+DecimalNumber? / DecimalNumber)) { return { type: "number", value: parseFloat(text()) }; }
  
DecimalNumber
  = "." [0-9]+

Group
  = "(" group:Expression ")" { return group; }

Reserved
  = Boolean
  / Undefined
  / Null

Boolean 
  = value:("true"/"false") {
      return {
        type: "boolean",
        value: value === "true"
      }
    }

Undefined 
  = "undefined" { return { type: "undefined", value: void 0 }; }

Null
  = ("null"/"NULL") { return { type: "null", value: null }; }

Reference
  = bindingType:("~>"/"<~>"/"~"/"<~")? reference:ReferencePath {
      return {
        type: "reference",
        bindingType: bindingType,
        path: reference
      }
    }

ReferencePath
  = left:ReferenceName "." right:ReferencePath {
      return [left].concat(right);
    }
  / name:ReferenceName {
      return [name];
    }

ReferenceName
  = name:[a-zA-Z]+ { return text(); }

Object
  = "{" _ values:ObjectValues? _ "}" {
      return {
        type: "object",
        value: values
      }
    }

ObjectValues 
  = firstValue:ObjectValue additionalValues:("," ObjectValues)* {
      return [
        firstValue
      ].concat(additionalValues.length ? additionalValues[0][1] : []);
    }

ObjectValue
  = key:ObjectKey ":" value:Expression {
      return {
        key: key,
        value: value
      }
    }

ObjectKey
  = _ key:StringLiteral { return key.value; }
  / _ key:ReferenceName { return key; } 



StringLiteral "string"
  = '"' chars:DoubleStringCharacter* '"' {
      return { type: "string", value: chars.join("") };
    }
  / "'" chars:SingleStringCharacter* "'" {
      return { type: "string", value: chars.join("") };
    }


DoubleStringCharacter
  = !('"' / "\\") SourceCharacter { return text(); }
  / '\\"'


SingleStringCharacter
  = !("'" / "\\") SourceCharacter { return text(); }
  / "\\'"

SourceCharacter
  = .

Word
  = chars:[a-zA-Z]+ { return chars.join(""); }

Zs 
  = [\u0020\u00A0\u1680\u2000-\u200A\u202F\u205F\u3000]

_ 
  = Zs*

