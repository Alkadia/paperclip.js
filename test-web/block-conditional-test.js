;(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var Clip, paper;

Clip = require("./clip");

paper = require("./paper");

module.exports = paper;

if (typeof window !== "undefined") {
  window.paperclip = module.exports;
}

},{"./clip":3,"./paper":30}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var Clip, ClippedBuffer, ClippedBufferPart, bindable,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

bindable = require("bindable");

Clip = require("./index");

/*
  watches for any changes in the template data
*/


ClippedBufferPart = (function() {
  /*
  */
  function ClippedBufferPart(clippedBuffer, script) {
    this.clippedBuffer = clippedBuffer;
    this.script = script;
    this._onUpdated = __bind(this._onUpdated, this);
    this.clip = new Clip({
      script: this.script
    });
    this.clip.bind("value").to(this._onUpdated);
  }

  /*
  */


  ClippedBufferPart.prototype.dispose = function() {
    return this.clip.dispose();
  };

  /*
  */


  ClippedBufferPart.prototype.update = function() {
    this.clip.reset(this.clippedBuffer._data);
    this.clip.update();
    return this.value = this.clip.get("value");
  };

  /*
  */


  ClippedBufferPart.prototype._onUpdated = function(value) {
    this.value = value;
    if (this.clippedBuffer._updating) {
      return;
    }
    return this.clippedBuffer.update();
  };

  /*
  */


  ClippedBufferPart.prototype.toString = function() {
    var _ref;

    return String((_ref = this.value) != null ? _ref : "");
  };

  return ClippedBufferPart;

})();

/*
 Keeps track of each template block. E.g: hello {{craig}}, how are you?
*/


ClippedBuffer = (function(_super) {
  __extends(ClippedBuffer, _super);

  /*
  */


  function ClippedBuffer(buffer) {
    var binding, bufferPart, _i, _len;

    ClippedBuffer.__super__.constructor.call(this);
    this.buffer = [];
    this.bindings = [];
    this._data = {};
    for (_i = 0, _len = buffer.length; _i < _len; _i++) {
      bufferPart = buffer[_i];
      if (bufferPart.fn) {
        this.buffer.push(binding = new ClippedBufferPart(this, bufferPart));
        this.bindings.push(binding);
      } else {
        this.buffer.push(bufferPart);
      }
    }
  }

  /*
  */


  ClippedBuffer.prototype.reset = function(data) {
    if (data == null) {
      data = {};
    }
    this._data = data;
    this.update();
    return this;
  };

  /*
  */


  ClippedBuffer.prototype.dispose = function() {
    var binding, _i, _len, _ref;

    _ref = this.bindings;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      binding = _ref[_i];
      binding.dispose();
    }
    return this.bindings = [];
  };

  /*
   updates the current text by stringifying the buffer
  */


  ClippedBuffer.prototype.update = function() {
    var binding, _i, _len, _ref;

    this._updating = true;
    _ref = this.bindings;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      binding = _ref[_i];
      binding.update();
    }
    this.set("text", this.text = this.render());
    return this._updating = false;
  };

  /*
   stringifies the buffer
  */


  ClippedBuffer.prototype.render = function() {
    return this.buffer.join("");
  };

  /*
  */


  ClippedBuffer.prototype.toString = function() {
    return this.text;
  };

  return ClippedBuffer;

})(bindable.Object);

module.exports = ClippedBuffer;

},{"./index":3,"bindable":84}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var Clip, ClipScript, ClipScripts, PropertyChain, bindable, dref, events, type,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

dref = require("dref");

events = require("events");

bindable = require("bindable");

type = require("type-component");

/*
 Reads a property chain
*/


PropertyChain = (function() {
  /*
  */
  PropertyChain.prototype.__isPropertyChain = true;

  /*
  */


  function PropertyChain(watcher) {
    this.watcher = watcher;
    this._commands = [];
    this.clip = this.watcher.clip;
  }

  /*
  */


  PropertyChain.prototype.ref = function(path) {
    this._commands.push({
      ref: path
    });
    return this;
  };

  /*
  */


  PropertyChain.prototype.castAs = function(name) {
    this.watcher.cast[name] = this;
    return this;
  };

  /*
  */


  PropertyChain.prototype.path = function() {
    var c, path, _i, _len, _ref;

    path = [];
    _ref = this._commands;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      path.push(c.ref);
    }
    return path.join(".");
  };

  /*
  */


  PropertyChain.prototype.self = function(path) {
    this._self = true;
    this.ref(path);
    return this;
  };

  /*
  */


  PropertyChain.prototype.call = function(path, args) {
    this._commands.push({
      ref: path,
      args: args
    });
    return this;
  };

  /*
  */


  PropertyChain.prototype.exec = function() {
    this.currentValue = this.value();
    return this;
  };

  /*
  */


  PropertyChain.prototype.value = function(value) {
    var command, cv, hasValue, i, n, pv, _i, _len, _ref;

    hasValue = arguments.length;
    cv = this._self ? this.clip : this.clip.data;
    n = this._commands.length;
    _ref = this._commands;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      command = _ref[i];
      if (cv.__isBindable) {
        this.watcher._watch(command.ref, cv);
      }
      if (i === n - 1 && hasValue) {
        if (cv.set) {
          cv.set(command.ref, value);
        } else {
          dref.set(cv, command.ref, value);
        }
      }
      pv = cv;
      cv = cv.get ? cv.get(command.ref) : dref.get(cv, command.ref);
      if (command.args) {
        if (cv && typeof cv === "function") {
          cv = cv != null ? cv.apply(pv, command.args) : void 0;
        } else {
          cv = void 0;
        }
      }
      if (!cv) {
        break;
      }
    }
    return cv;
  };

  return PropertyChain;

})();

/*
*/


ClipScript = (function(_super) {
  __extends(ClipScript, _super);

  /*
  */


  function ClipScript(script, clip) {
    this.script = script;
    this.clip = clip;
    this._debounceUpdate = __bind(this._debounceUpdate, this);
    this.update = __bind(this.update, this);
    this.options = this.clip.options;
    this._watching = {};
    this.cast = {};
  }

  /*
  */


  ClipScript.prototype.dispose = function() {
    var key;

    for (key in this._watching) {
      this._watching[key].dispose();
    }
    return this._watching = {};
  };

  /*
  */


  ClipScript.prototype.update = function() {
    var newValue;

    newValue = this.script.fn.call(this);
    if (newValue === this.value) {
      return newValue;
    }
    this._updated = true;
    this.emit("change", this.value = newValue);
    return newValue;
  };

  /*
  */


  ClipScript.prototype.watch = function() {
    this.__watch = true;
    this.update();
    return this;
  };

  /*
  */


  ClipScript.prototype.unwatch = function() {
    var key;

    this.__watch = false;
    for (key in this._watching) {
      this._watching[key].dispose();
    }
    this._watching = {};
    return this;
  };

  /*
  */


  ClipScript.prototype.references = function() {
    return this.script.refs || [];
  };

  /*
  */


  ClipScript.prototype.ref = function(path) {
    return new PropertyChain(this).ref(path);
  };

  ClipScript.prototype.self = function(path) {
    return new PropertyChain(this).self(path);
  };

  ClipScript.prototype.call = function(path, args) {
    return new PropertyChain(this).call(path, args);
  };

  ClipScript.prototype.castAs = function(name) {
    return new PropertyChain(this).castAs(name);
  };

  /*
   watches
  */


  ClipScript.prototype._watch = function(path, target) {
    var binding, lockUpdate,
      _this = this;

    if (!this.__watch) {
      return;
    }
    if (this._watching[path]) {
      if (this._watching[path].target === target) {
        return;
      }
      this._watching[path].dispose();
    }
    lockUpdate = true;
    this._watching[path] = {
      target: target,
      binding: binding = target.bind(path).to(function(value, oldValue) {
        if (value != null ? value.__isBindable : void 0) {
          _this._watchBindable(value, oldValue);
        } else if (type(value) === "function") {
          _this._spyFunction(path, value, target);
        }
        if (lockUpdate) {
          return;
        }
        return _this.update();
      }).now(),
      dispose: function() {
        return binding.dispose();
      }
    };
    return lockUpdate = false;
  };

  /*
   watches a bindable object for any changes, then updates this binding asynchronously This is important
   for such a case: {{ someObject | someComputer() }}
  */


  ClipScript.prototype._watchBindable = function(value, oldValue) {
    var onChange,
      _this = this;

    value.on("change", onChange = function() {
      if (!_this._updated) {
        return;
      }
      return _this._debounceUpdate();
    });
    return {
      disposeBinding: function() {
        return value.off("change", onChange);
      }
    };
  };

  /* 
   temporarily overwrites an existing, referenced function, and finds *all* the references
   called within the given function. This is needed incase a function is called inline, and *might*
   be updated. For example:
  
   getSum = () -> @get("someNum") + @get("anotherNum")
  
   and 
  
   {{ getSum() }}
  
   _spyFunction would find the references to "someNum", and "anotherSum", and listen for *those* to change,
   then re-call getSum()
  */


  ClipScript.prototype._spyFunction = function(path, fn, target) {
    var oldFn, ref, self, _i, _len, _ref;

    oldFn = fn;
    if (fn.__isCallSpy) {
      return;
    }
    self = this;
    target = (typeof target.owner === "function" ? target.owner(path) : void 0) || target;
    if (fn.refs) {
      _ref = fn.refs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ref = _ref[_i];
        this._watch(ref, target);
      }
    } else {

    }
    /*
    fn = () ->
      refs   = []
      oldGet = @get
    
      # override this.get temporarily
      @get = (key) ->
        refs.push(key) if key and key.length
        oldGet.call @, key
    
      # call the old function
      ret = oldFn.apply @, arguments
    
      # reset the old this.get function
      @get = oldGet
    
      oldFn.refs = refs
    
      #reset the old function
      @set path, oldFn
    
      ret
    
    # set callspy to the overridden function, since _spyFunction
    # will be called again after it's overridden. We want to prevent an infinite loop!
    fn.__isCallSpy = true
    
    # override the old function *temporarily*
    target.set path, fn
    */

  };

  /*
  */


  ClipScript.prototype._debounceUpdate = function() {
    clearTimeout(this._debounceTimeout);
    return this._debounceTimeout = setTimeout(this.update, 0);
  };

  return ClipScript;

})(events.EventEmitter);

ClipScripts = (function() {
  /*
  */
  function ClipScripts(clip, scripts) {
    this.clip = clip;
    this._scripts = {};
    this.names = [];
    this._bindScripts(scripts);
  }

  /*
  */


  ClipScripts.prototype.watch = function() {
    var key;

    for (key in this._scripts) {
      this._scripts[key].watch();
    }
    return this;
  };

  /*
  */


  ClipScripts.prototype.unwatch = function() {
    var key;

    for (key in this._scripts) {
      this._scripts[key].unwatch();
    }
    return this;
  };

  /*
  */


  ClipScripts.prototype.update = function() {
    var key;

    for (key in this._scripts) {
      this._scripts[key].update();
    }
    return this;
  };

  /*
  */


  ClipScripts.prototype.dispose = function() {
    var key;

    for (key in this._scripts) {
      this._scripts[key].dispose();
    }
    return this._scripts = {};
  };

  /*
  */


  ClipScripts.prototype.get = function(name) {
    return this._scripts[name];
  };

  /*
  */


  ClipScripts.prototype._bindScripts = function(scripts) {
    var scriptName, _results;

    if (scripts.fn) {
      return this._bindScript("value", scripts);
    } else {
      _results = [];
      for (scriptName in scripts) {
        _results.push(this._bindScript(scriptName, scripts[scriptName]));
      }
      return _results;
    }
  };

  /*
  */


  ClipScripts.prototype._bindScript = function(name, script, watch) {
    var clipScript,
      _this = this;

    this.names.push(name);
    clipScript = new ClipScript(script, this.clip);
    this._scripts[name] = clipScript;
    return clipScript.on("change", function(value) {
      return _this.clip.set(name, value);
    });
  };

  return ClipScripts;

})();

Clip = (function() {
  /*
  */
  function Clip(options) {
    var scripts;

    this.options = options;
    this._self = new bindable.Object();
    this.reset(options.data, false);
    scripts = this.options.scripts || this.options.script;
    if (scripts) {
      this.scripts = new ClipScripts(this, scripts);
    }
    if (options.watch !== false) {
      this.watch();
    }
  }

  /*
  */


  Clip.prototype.reset = function(data, update) {
    if (data == null) {
      data = {};
    }
    if (update == null) {
      update = true;
    }
    this.data = data.__isBindable ? data : new bindable.Object(data);
    if (update) {
      this.update();
    }
    return this;
  };

  /*
  */


  Clip.prototype.watch = function() {
    this.scripts.watch();
    return this;
  };

  /*
  */


  Clip.prototype.unwatch = function() {
    return this.scripts.unwatch();
  };

  /*
  */


  Clip.prototype.update = function() {
    this.scripts.update();
    return this;
  };

  /*
  */


  Clip.prototype.dispose = function() {
    var _ref, _ref1;

    if ((_ref = this._self) != null) {
      _ref.dispose();
    }
    return (_ref1 = this.scripts) != null ? _ref1.dispose() : void 0;
  };

  Clip.prototype.script = function(name) {
    return this.scripts.get(name);
  };

  Clip.prototype.get = function() {
    var _ref;

    return (_ref = this._self).get.apply(_ref, arguments);
  };

  Clip.prototype.set = function() {
    var _ref;

    return (_ref = this._self).set.apply(_ref, arguments);
  };

  Clip.prototype.bind = function() {
    var _ref;

    return (_ref = this._self).bind.apply(_ref, arguments);
  };

  return Clip;

})();

module.exports = Clip;

},{"bindable":84,"dref":102,"events":99,"type-component":119}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var Clip, browser, paper, translate;

Clip = require("./clip");

paper = require("./paper");

browser = require("./browser");

translate = require("./translate");

module.exports = browser;

module.exports.compile = translate.compile;

paper.template.compiler = translate;

},{"./browser":1,"./clip":3,"./paper":30,"./translate":58}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var BaseBinding;

BaseBinding = (function() {
  function BaseBinding(node) {
    this.node = node;
  }

  BaseBinding.prototype.bind = function(context) {
    this.context = context;
  };

  BaseBinding.prototype.unbind = function() {};

  return BaseBinding;

})();

module.exports = BaseBinding;

},{}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var ScriptBinding,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

ScriptBinding = (function(_super) {
  __extends(ScriptBinding, _super);

  /*
  */


  function ScriptBinding(clip, scriptName) {
    this.clip = clip;
    this.scriptName = scriptName;
    this._onChange = __bind(this._onChange, this);
    this.script = clip.script(this.scriptName);
  }

  /*
  */


  ScriptBinding.prototype.bind = function(context) {
    this.context = context;
    if (this.watch !== false) {
      this.script.watch();
    }
    this._binding = this.clip.bind(this.scriptName);
    if (this._map) {
      this._binding.map(this._map);
    }
    this._binding.to(this._onChange);
    this._binding.now();
    return this;
  };

  /*
  */


  ScriptBinding.prototype.unbind = function() {
    var _ref;

    if ((_ref = this._binding) != null) {
      _ref.dispose();
    }
    this._binding = void 0;
    return this;
  };

  /*
  */


  ScriptBinding.prototype._onChange = function(value) {};

  return ScriptBinding;

})(require("./index"));

module.exports = ScriptBinding;

},{"./index":5}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var BlockBinding,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BlockBinding = (function(_super) {
  __extends(BlockBinding, _super);

  /*
  */


  function BlockBinding(options) {
    this.section = options.section;
    this.clip = options.clip;
    this.nodeFactory = options.nodeFactory;
    this.contentTemplate = options.template;
    this.scriptName = options.scriptName;
    this.childBlockTemplate = options.childBlockTemplate;
    this.script = this.clip.script(this.scriptName);
    BlockBinding.__super__.constructor.call(this, this.clip, this.scriptName);
  }

  /*
  */


  BlockBinding.prototype.bind = function(context) {
    this.context = context;
    this.clip.reset(this.context);
    return BlockBinding.__super__.bind.call(this, this.context);
  };

  /*
  */


  BlockBinding.test = function(node) {
    return false;
  };

  return BlockBinding;

})(require("../base/script"));

module.exports = BlockBinding;

},{"../base/script":6}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
/*

{{#when:condition}}
  do something
{{/}}
*/

var BlockDecor, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BlockDecor = (function(_super) {
  __extends(BlockDecor, _super);

  function BlockDecor() {
    this._onChange = __bind(this._onChange, this);    _ref = BlockDecor.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  BlockDecor.prototype._map = function(value) {
    return !!value;
  };

  /*
  */


  BlockDecor.prototype._onChange = function(value) {
    var childTemplate, _ref1;

    if ((_ref1 = this.child) != null) {
      _ref1.unbind();
    }
    this.child = void 0;
    if (value) {
      childTemplate = this.contentTemplate;
    } else {
      childTemplate = this.childBlockTemplate;
    }
    if (childTemplate) {
      this.child = childTemplate.bind(this.context);
      return this.section.replaceChildNodes(this.child.section.toFragment());
    }
  };

  return BlockDecor;

})(require("./base"));

module.exports = BlockDecor;

},{"./base":7}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var BindingCollection, Factory, bindingClasses;

BindingCollection = require("../collection");

bindingClasses = {
  html: require("./html"),
  "if": require("./conditional"),
  "else": require("./conditional"),
  elseif: require("./conditional"),
  value: require("./value")
};

Factory = (function() {
  function Factory() {}

  /*
  */


  Factory.prototype.getBindings = function(options) {
    var bd, bindings, clipScriptNames, scriptName, _i, _len;

    bindings = [];
    clipScriptNames = options.clip.scripts.names;
    for (_i = 0, _len = clipScriptNames.length; _i < _len; _i++) {
      scriptName = clipScriptNames[_i];
      if (bd = bindingClasses[scriptName]) {
        options.scriptName = scriptName;
        bindings.push(new bd(options));
      }
    }
    return bindings;
  };

  /*
  */


  Factory.prototype.register = function(name, bindingClass) {
    return bindingClasses[name] = bindingClass;
  };

  return Factory;

})();

module.exports = new Factory();

},{"../collection":13,"./conditional":8,"./html":10,"./value":11}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var HtmlDecor, type, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

type = require("type-component");

HtmlDecor = (function(_super) {
  __extends(HtmlDecor, _super);

  function HtmlDecor() {
    _ref = HtmlDecor.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  HtmlDecor.prototype._onChange = function(value, oldValue) {
    var dom, node;

    if (oldValue != null ? oldValue.__isLoader : void 0) {
      oldValue.section.hide();
    }
    if (!value) {
      return this.section.removeChildNodes();
    }
    if (value.__isLoader) {
      node = value.section.show().toFragment();
    } else if (value.nodeType != null) {
      node = value;
    } else {
      if (this.nodeFactory.name === "string") {
        node = this.nodeFactory.createTextNode(String(value));
      } else {
        dom = this.nodeFactory.createElement("div");
        dom.innerHTML = String(value);
        node = this.nodeFactory.createFragment(dom.childNodes);
      }
    }
    return this.section.replaceChildNodes(node);
  };

  return HtmlDecor;

})(require("./base"));

module.exports = HtmlDecor;

},{"./base":7,"type-component":119}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var ValueDecor, escapeHTML, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

escapeHTML = require("../../utils/escapeHTML");

ValueDecor = (function(_super) {
  __extends(ValueDecor, _super);

  function ValueDecor() {
    _ref = ValueDecor.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  ValueDecor.prototype._onChange = function(value) {
    if (value == null) {
      value = "";
    }
    return this.section.replaceChildNodes(this.nodeFactory.createTextNode(String(value)));
  };

  return ValueDecor;

})(require("./base"));

module.exports = ValueDecor;

},{"../../utils/escapeHTML":34,"./base":7}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var ClipBinding,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

ClipBinding = (function(_super) {
  __extends(ClipBinding, _super);

  /*
  */


  function ClipBinding(clip) {
    this.clip = clip;
  }

  /*
  */


  ClipBinding.prototype.bind = function(context) {
    this.context = context;
    this.clip.reset(this.context);
    return this.clip.watch();
  };

  /*
  */


  ClipBinding.prototype.unbind = function() {
    return this.clip.unwatch();
  };

  return ClipBinding;

})(require("./base"));

module.exports = ClipBinding;

},{"./base":5}],13:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var BaseBinding, Collection,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BaseBinding = require("./base/index");

Collection = (function(_super) {
  __extends(Collection, _super);

  /*
  */


  function Collection(node, _source) {
    this.node = node;
    this._source = _source != null ? _source : [];
  }

  /*
  */


  Collection.prototype.push = function() {
    var _ref;

    return (_ref = this._source).push.apply(_ref, arguments);
  };

  /*
  */


  Collection.prototype.bind = function(context) {
    var binding, _i, _len, _ref, _results;

    this.context = context;
    if (this._bound) {
      return;
    }
    this._bound = true;
    _ref = this._source;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      binding = _ref[_i];
      _results.push(binding.bind(this.context));
    }
    return _results;
  };

  /*
  */


  Collection.prototype.unbind = function() {
    var binding, _i, _len, _ref, _results;

    if (!this._bound) {
      return;
    }
    this._bound = false;
    _ref = this._source;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      binding = _ref[_i];
      _results.push(binding.unbind());
    }
    return _results;
  };

  return Collection;

})(BaseBinding);

module.exports = Collection;

},{"./base/index":5}],14:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
module.exports = {
  BaseBlockBinding: require("./block/base"),
  blockBindingFactory: require("./block/factory"),
  nodeBindingFactory: require("./node/factory"),
  BaseNodeBinding: require("./node/base"),
  BaseAttrDataBinding: require("./node/attrs/dataBind/handlers/base")
};

},{"./block/base":7,"./block/factory":9,"./node/attrs/dataBind/handlers/base":15,"./node/base":28,"./node/factory":29}],15:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var BaseDataBindHandler,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BaseDataBindHandler = (function(_super) {
  __extends(BaseDataBindHandler, _super);

  /*
  */


  function BaseDataBindHandler(node, clip, name) {
    this.node = node;
    this.clip = clip;
    this.name = name;
    BaseDataBindHandler.__super__.constructor.call(this, this.clip, this.name);
  }

  return BaseDataBindHandler;

})(require("../../../../base/script"));

module.exports = BaseDataBindHandler;

},{"../../../../base/script":6}],16:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var ChangeAttrBinding, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

ChangeAttrBinding = (function(_super) {
  __extends(ChangeAttrBinding, _super);

  function ChangeAttrBinding() {
    this._update2 = __bind(this._update2, this);    _ref = ChangeAttrBinding.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  ChangeAttrBinding.events = "keydown change input mousedown mouseup click";

  /*
  */


  ChangeAttrBinding.prototype.preventDefault = false;

  /*
  */


  ChangeAttrBinding.prototype.event = ChangeAttrBinding.events;

  /*
  */


  ChangeAttrBinding.prototype._update = function(event) {
    clearTimeout(this._changeTimeout);
    return this._changeTimeout = setTimeout(this._update2, 5);
  };

  /*
  */


  ChangeAttrBinding.prototype._update2 = function() {
    return this.script.update();
  };

  return ChangeAttrBinding;

})(require("./event"));

module.exports = ChangeAttrBinding;

},{"./event":21}],17:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var CssAttrBinding, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

CssAttrBinding = (function(_super) {
  __extends(CssAttrBinding, _super);

  function CssAttrBinding() {
    this._onChange = __bind(this._onChange, this);    _ref = CssAttrBinding.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  CssAttrBinding.prototype._onChange = function(classes) {
    var className, classesToUse, i, useClass, _ref1;

    classesToUse = ((_ref1 = this.node.getAttribute("class")) != null ? _ref1.split(" ") : void 0) || [];
    for (className in classes) {
      useClass = classes[className];
      i = classesToUse.indexOf(className);
      if (useClass) {
        if (!~i) {
          classesToUse.push(className);
        }
      } else if (~i) {
        classesToUse.splice(i, 1);
      }
    }
    return this.node.setAttribute("class", classesToUse.join(" "));
  };

  return CssAttrBinding;

})(require("./base"));

module.exports = CssAttrBinding;

},{"./base":15}],18:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var DeleteAttrBinding, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

DeleteAttrBinding = (function(_super) {
  __extends(DeleteAttrBinding, _super);

  function DeleteAttrBinding() {
    this._onEvent = __bind(this._onEvent, this);    _ref = DeleteAttrBinding.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  DeleteAttrBinding.prototype.event = "keydown";

  /*
  */


  DeleteAttrBinding.prototype.preventDefault = true;

  /*
  */


  DeleteAttrBinding.prototype._onEvent = function(event) {
    var _ref1;

    if ((_ref1 = event.keyCode) !== 8) {
      return;
    }
    return DeleteAttrBinding.__super__._onEvent.call(this, event);
  };

  return DeleteAttrBinding;

})(require("./event"));

module.exports = DeleteAttrBinding;

},{"./event":21}],19:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var DisableAttrBinding, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

DisableAttrBinding = (function(_super) {
  __extends(DisableAttrBinding, _super);

  function DisableAttrBinding() {
    _ref = DisableAttrBinding.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  DisableAttrBinding.prototype._onChange = function(value) {
    if (value) {
      return this.node.setAttribute("disabled", "disabled");
    } else {
      return this.node.removeAttribute("disabled");
    }
  };

  return DisableAttrBinding;

})(require("./base"));

module.exports = DisableAttrBinding;

},{"./base":15}],20:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var EnterAttrBinding, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

EnterAttrBinding = (function(_super) {
  __extends(EnterAttrBinding, _super);

  function EnterAttrBinding() {
    this._onEvent = __bind(this._onEvent, this);    _ref = EnterAttrBinding.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  EnterAttrBinding.prototype.event = "keydown";

  /*
  */


  EnterAttrBinding.prototype.preventDefault = true;

  /*
  */


  EnterAttrBinding.prototype._onEvent = function(event) {
    if (event.keyCode !== 13) {
      return;
    }
    return EnterAttrBinding.__super__._onEvent.call(this, event);
  };

  return EnterAttrBinding;

})(require("./event"));

module.exports = EnterAttrBinding;

},{"./event":21}],21:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var EventDecor, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

EventDecor = (function(_super) {
  __extends(EventDecor, _super);

  function EventDecor() {
    this._onEvent = __bind(this._onEvent, this);    _ref = EventDecor.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  EventDecor.prototype.watch = false;

  /*
  */


  EventDecor.prototype.propagateEvent = true;

  /*
  */


  EventDecor.prototype.preventDefault = false;

  /*
  */


  EventDecor.prototype.bind = function() {
    var ev, event, name, prop, _i, _len, _ref1;

    EventDecor.__super__.bind.apply(this, arguments);
    event = (this.event || this.name).toLowerCase();
    name = this.name.toLowerCase();
    if (name.substr(0, 2) === "on") {
      name = name.substr(2);
    }
    if (event.substr(0, 2) === "on") {
      event = event.substr(2);
    }
    if (name === "click" || name === "mouseup" || name === "mousedown" || name === "submit") {
      this.preventDefault = true;
      this.propagateEvent = false;
    }
    this._pge = "propagateEvent." + name;
    this._pde = "preventDefault." + name;
    _ref1 = [this._pge, this._pde];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      ev = _ref1[_i];
      prop = ev.split(".").shift();
      if ((this.clip.get(ev) == null) && (this.clip.get(prop) == null) && (this[prop] != null)) {
        this.clip.set(ev, this[prop]);
      }
    }
    return $(this.element).bind(event, this._onEvent);
  };

  /*
  */


  EventDecor.prototype._onEvent = function(event) {
    if (this.clip.get("propagateEvent") !== true && this.clip.get(this._pge) !== true) {
      event.stopPropagation();
    }
    if (this.clip.get("preventDefault") === true || this.clip.get(this._pde) === true) {
      event.preventDefault();
    }
    if (this.clip.get("disable")) {
      return;
    }
    this.clip.data.set("event", event);
    return this._update(event);
  };

  /*
  */


  EventDecor.prototype._update = function(event) {
    return this.script.update();
  };

  return EventDecor;

})(require("./base"));

module.exports = EventDecor;

},{"./base":15}],22:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var ChangeDecor, ModelAttrBinding, dref, type, _, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require("underscore");

ChangeDecor = require("./change");

type = require("type-component");

dref = require("dref");

ModelAttrBinding = (function(_super) {
  __extends(ModelAttrBinding, _super);

  function ModelAttrBinding() {
    this._elementValue = __bind(this._elementValue, this);
    this._onValueChange = __bind(this._onValueChange, this);
    this._onChange = __bind(this._onChange, this);
    this._onElementChange = __bind(this._onElementChange, this);    _ref = ModelAttrBinding.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  ModelAttrBinding.prototype.bind = function() {
    ModelAttrBinding.__super__.bind.call(this);
    (this.$element = $(this.element)).bind(ChangeDecor.events, this._onElementChange);
    return this._onChange(this.clip.get("model"));
  };

  /*
  */


  ModelAttrBinding.prototype._onElementChange = function(event) {
    var _this = this;

    event.stopPropagation();
    clearTimeout(this._changeTimeout);
    return this._changeTimeout = setTimeout((function() {
      var model, name, ref, value;

      value = _this._parseValue(_this._elementValue());
      name = _this._elementName();
      model = _this.clip.get("model");
      if (_this.clip.get("bothWays") !== false) {
        ref = name || (_this.refs.length ? _this.refs[0] : void 0);
        if (!name) {
          model = _this.context;
        }
        if (model) {
          if (model.set) {
            return model.set(ref, value);
          } else {
            return dref.set(model, ref, value);
          }
        }
      }
    }), 5);
  };

  /*
  */


  ModelAttrBinding.prototype.dispose = function() {
    var _ref1, _ref2;

    if ((_ref1 = this._modelBinding) != null) {
      _ref1.dispose();
    }
    return (_ref2 = this.$element) != null ? _ref2.unbind(ChangeDecor.events, this._onElementChange) : void 0;
  };

  /*
  */


  ModelAttrBinding.prototype._onChange = function(model) {
    var name, _ref1;

    name = this._elementName();
    if ((_ref1 = this._modelBinding) != null) {
      _ref1.dispose();
    }
    if (name) {
      return this._modelBinding = model != null ? model.bind(name).to(this._onValueChange).now() : void 0;
    } else {
      return this._onValueChange(model);
    }
  };

  /*
  */


  ModelAttrBinding.prototype._onValueChange = function(value) {
    return this._elementValue(this._parseValue(value));
  };

  /*
  */


  ModelAttrBinding.prototype._parseValue = function(value) {
    var v;

    if ((value == null) || value === "") {
      return void 0;
    }
    if (isNaN(v = Number(value))) {
      return value;
    } else {
      return v;
    }
  };

  /*
  */


  ModelAttrBinding.prototype._elementValue = function(value) {
    var isInput;

    if (value == null) {
      value = "";
    }
    isInput = Object.prototype.hasOwnProperty.call(this.element, "value") || /input|textarea|checkbox/.test(this.element.nodeName.toLowerCase());
    if (!arguments.length) {
      if (isInput) {
        return this._checkedOrValue();
      } else {
        return this.element.innerHTML;
      }
    }
    this.currentValue = value;
    if (isInput) {
      return this._checkedOrValue(value);
    } else {
      return this.element.innerHTML = value;
    }
  };

  /*
  */


  ModelAttrBinding.prototype._elementName = function() {
    return $(this.element).attr("name");
  };

  /*
  */


  ModelAttrBinding.prototype._checkedOrValue = function(value) {
    var isCheckbox, isRadio, isRadioOrCheckbox;

    isCheckbox = /checkbox/.test(this.element.type);
    isRadio = /radio/.test(this.element.type);
    isRadioOrCheckbox = isCheckbox || isRadio;
    if (!arguments.length) {
      if (isRadioOrCheckbox) {
        return $(this.element).val();
      } else {
        return this.element.value;
      }
    }
    if (isRadioOrCheckbox) {
      if (isRadio) {
        if (String(value) === String($(this.element).val())) {
          return $(this.element).prop("checked", true);
        }
      } else {
        return this.element.checked = value;
      }
    } else {
      return this.element.value = value;
    }
  };

  return ModelAttrBinding;

})(require("./base"));

module.exports = ModelAttrBinding;

},{"./base":15,"./change":16,"dref":102,"type-component":119,"underscore":125}],23:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var ShowAttrBinding, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

ShowAttrBinding = (function(_super) {
  __extends(ShowAttrBinding, _super);

  function ShowAttrBinding() {
    _ref = ShowAttrBinding.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  ShowAttrBinding.prototype.bind = function(context) {
    this._displayStyle = this.node.style.display;
    return ShowAttrBinding.__super__.bind.call(this, context);
  };

  /*
  */


  ShowAttrBinding.prototype._map = function(value) {
    return !!value;
  };

  /*
  */


  ShowAttrBinding.prototype._onChange = function(value) {
    return this.node.style.display = value ? this._displayStyle : "none";
  };

  return ShowAttrBinding;

})(require("./base"));

module.exports = ShowAttrBinding;

},{"./base":15}],24:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var StyleDecor, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

StyleDecor = (function(_super) {
  __extends(StyleDecor, _super);

  function StyleDecor() {
    _ref = StyleDecor.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  StyleDecor.prototype.bind = function() {
    this._currentStyles = {};
    return StyleDecor.__super__.bind.call(this);
  };

  /*
  */


  StyleDecor.prototype._onChange = function(styles) {
    var key, name, newStyles, rmStyle, style, _results;

    newStyles = {};
    rmStyle = {};
    for (name in styles) {
      style = styles[name];
      if (style !== this._currentStyles[name]) {
        newStyles[name] = this._currentStyles[name] = style || "";
      }
    }
    if (typeof window === "undefined") {
      _results = [];
      for (key in newStyles) {
        _results.push(this.node.style[key] = newStyles[key]);
      }
      return _results;
    } else {
      return $(this.node).css(newStyles);
    }
  };

  return StyleDecor;

})(require("./base"));

module.exports = StyleDecor;

},{"./base":15}],25:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var ChangeDecor, ValueAttrBinding, type, _, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require("underscore");

ChangeDecor = require("./change");

type = require("type-component");

/*
 DEPRECATED - USE MODEL
*/


ValueAttrBinding = (function(_super) {
  __extends(ValueAttrBinding, _super);

  function ValueAttrBinding() {
    this._elementValue = __bind(this._elementValue, this);
    this._onChange = __bind(this._onChange, this);
    this._onElementChange = __bind(this._onElementChange, this);    _ref = ValueAttrBinding.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  ValueAttrBinding.prototype.bind = function() {
    ValueAttrBinding.__super__.bind.call(this);
    (this.$element = $(this.element)).bind(ChangeDecor.events, this._onElementChange);
    return this._onChange(this.clip.get("value"));
  };

  /*
  */


  ValueAttrBinding.prototype._onElementChange = function(event) {
    var _this = this;

    event.stopPropagation();
    clearTimeout(this._changeTimeout);
    return this._changeTimeout = setTimeout((function() {
      var ref, value, _i, _len, _ref1, _results;

      value = _this._elementValue();
      if (_this.clip.get("bothWays")) {
        _ref1 = _this.refs;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          ref = _ref1[_i];
          _results.push(_this.context.set(ref, value));
        }
        return _results;
      }
    }), 5);
  };

  /*
  */


  ValueAttrBinding.prototype.dispose = function() {
    var _ref1;

    return (_ref1 = this.$element) != null ? _ref1.unbind(ChangeDecor.events, this._onElementChange) : void 0;
  };

  /*
  */


  ValueAttrBinding.prototype._onChange = function(value) {
    return this._elementValue(value);
  };

  /*
  */


  ValueAttrBinding.prototype._elementValue = function(value) {
    var isInput;

    if (value == null) {
      value = "";
    }
    isInput = Object.prototype.hasOwnProperty.call(this.element, "value") || /input|textarea|checkbox/.test(this.element.nodeName.toLowerCase());
    if (!arguments.length) {
      if (isInput) {
        return this._checkedOrValue();
      } else {
        return this.element.innerHTML;
      }
    }
    this.currentValue = value;
    if (isInput) {
      return this._checkedOrValue(value);
    } else {
      return this.element.innerHTML = value;
    }
  };

  /*
  */


  ValueAttrBinding.prototype._checkedOrValue = function(value) {
    var isCheckbox;

    isCheckbox = /checkbox/.test(this.element.type);
    if (!arguments.length) {
      if (isCheckbox) {
        return this.element.checked;
      } else {
        return this.element.value;
      }
    }
    if (isCheckbox) {
      return this.element.checked = value;
    } else {
      return this.element.value = value;
    }
  };

  return ValueAttrBinding;

})(require("./base"));

module.exports = ValueAttrBinding;

},{"./base":15,"./change":16,"type-component":119,"underscore":125}],26:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var AttrDataBinding, BindingCollection, Clip, dataBindingClasses,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Clip = require("../../../../../clip");

BindingCollection = require("../../../collection");

dataBindingClasses = {
  show: require("./handlers/show"),
  css: require("./handlers/css"),
  style: require("./handlers/style"),
  disable: require("./handlers/disable"),
  value: require("./handlers/value"),
  model: require("./handlers/model"),
  click: require("./handlers/event"),
  submit: require("./handlers/event"),
  mousedown: require("./handlers/event"),
  mouseup: require("./handlers/event"),
  mouseover: require("./handlers/event"),
  mouseout: require("./handlers/event"),
  keydown: require("./handlers/event"),
  keyup: require("./handlers/event"),
  enter: require("./handlers/enter"),
  "delete": require("./handlers/delete"),
  onClick: require("./handlers/event"),
  onSubmit: require("./handlers/event"),
  onMouseDown: require("./handlers/event"),
  onMouseUp: require("./handlers/event"),
  onMouseOver: require("./handlers/event"),
  onMouseOut: require("./handlers/event"),
  onKeyDown: require("./handlers/event"),
  onKeyUp: require("./handlers/event"),
  onEnter: require("./handlers/enter"),
  onChange: require("./handlers/change"),
  onDelete: require("./handlers/delete")
};

AttrDataBinding = (function(_super) {
  __extends(AttrDataBinding, _super);

  /*
  */


  AttrDataBinding.prototype.type = "attr";

  /*
  */


  function AttrDataBinding(options) {
    var bc, scriptName, _i, _len, _ref;

    AttrDataBinding.__super__.constructor.call(this, options);
    this.clip = new Clip({
      scripts: options.value[0],
      watch: false
    });
    this._bindings = new BindingCollection();
    _ref = this.clip.scripts.names;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      scriptName = _ref[_i];
      if (!(bc = dataBindingClasses[scriptName])) {
        continue;
      }
      this._bindings.push(new bc(this.node, this.clip, scriptName));
    }
  }

  /*
  */


  AttrDataBinding.prototype.bind = function(context) {
    this.context = context;
    this.clip.watch().reset(this.context);
    return this._bindings.bind();
  };

  /*
  */


  AttrDataBinding.prototype.unbind = function() {
    this.clip.unwatch();
    return this._bindings.unbind();
  };

  return AttrDataBinding;

})(require("../../base"));

module.exports = AttrDataBinding;

module.exports.register = function(name, dataBindClass) {
  return dataBindingClasses[name] = dataBindClass;
};

},{"../../../../../clip":3,"../../../collection":13,"../../base":28,"./handlers/change":16,"./handlers/css":17,"./handlers/delete":18,"./handlers/disable":19,"./handlers/enter":20,"./handlers/event":21,"./handlers/model":22,"./handlers/show":23,"./handlers/style":24,"./handlers/value":25}],27:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var AttrTextBinding, ClippedBuffer, type,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

type = require("type-component");

ClippedBuffer = require("../../../../../clip/buffer");

AttrTextBinding = (function(_super) {
  __extends(AttrTextBinding, _super);

  /*
  */


  AttrTextBinding.prototype.type = "attr";

  /*
  */


  function AttrTextBinding(options) {
    this._onChange = __bind(this._onChange, this);    AttrTextBinding.__super__.constructor.call(this, options);
    this.clippedBuffer = new ClippedBuffer(this.value);
  }

  /*
  */


  AttrTextBinding.prototype.bind = function(context) {
    this.context = context;
    return this._binding = this.clippedBuffer.reset(this.context).bind("text").to(this._onChange).now();
  };

  /*
  */


  AttrTextBinding.prototype.unbind = function() {
    var _ref;

    if ((_ref = this._binding) != null) {
      _ref.dispose();
    }
    return this._binding;
  };

  /*
  */


  AttrTextBinding.prototype._onChange = function(text) {
    if (!text.length) {
      this.node.removeAttribute(this.name);
      return;
    }
    return this.node.setAttribute(this.name, text);
  };

  /*
  */


  AttrTextBinding.prototype.test = function(binding) {
    var v, _i, _len, _ref;

    if (type(binding.value) !== "array") {
      return false;
    }
    _ref = binding.value;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      if (v.fn) {
        return true;
      }
    }
    return false;
  };

  return AttrTextBinding;

})(require("../../base"));

module.exports = AttrTextBinding;

},{"../../../../../clip/buffer":2,"../../base":28,"type-component":119}],28:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var BaseNodeBinding,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BaseNodeBinding = (function(_super) {
  __extends(BaseNodeBinding, _super);

  /*
  */


  function BaseNodeBinding(options) {
    this.name = options.name || this.name;
    this.node = options.node;
    this.value = options.value;
  }

  /*
  */


  BaseNodeBinding.prototype.bind = function(context) {
    this.context = context;
  };

  /*
  */


  BaseNodeBinding.prototype.unbind = function() {};

  return BaseNodeBinding;

})(require("../../base"));

module.exports = BaseNodeBinding;

},{"../../base":5}],29:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var NodeBindingFactory, allBindingClasses, classes, clazz, dataBind, defaultBindingClasses, nodeFactory, type, _i, _len;

allBindingClasses = {
  node: {},
  attr: {
    "default": []
  }
};

NodeBindingFactory = (function() {
  function NodeBindingFactory() {}

  /*
  */


  NodeBindingFactory.prototype.getBindings = function(options) {
    var attrName, attributes, bindable, bindables, bindingClass, bindingClasses, bindings, node, nodeName, _i, _j, _len, _len1;

    bindings = [];
    attributes = options.attributes;
    nodeName = options.nodeName;
    node = options.node;
    bindables = [
      {
        name: nodeName,
        key: nodeName,
        value: node,
        type: "node",
        node: node
      }, {
        name: nodeName,
        key: "default",
        value: node,
        type: "node",
        node: node
      }
    ];
    for (attrName in attributes) {
      bindables.push({
        node: node,
        name: attrName,
        key: attrName,
        value: attributes[attrName],
        type: "attr"
      });
      bindables.push({
        node: node,
        name: attrName,
        key: "default",
        value: attributes[attrName],
        type: "attr"
      });
    }
    for (_i = 0, _len = bindables.length; _i < _len; _i++) {
      bindable = bindables[_i];
      bindingClasses = allBindingClasses[bindable.type][bindable.key] || [];
      for (_j = 0, _len1 = bindingClasses.length; _j < _len1; _j++) {
        bindingClass = bindingClasses[_j];
        if (bindingClass.prototype.test(bindable)) {
          bindings.push(new bindingClass(bindable));
        }
      }
    }
    return bindings;
  };

  /*
  */


  NodeBindingFactory.prototype.register = function(name, bindingClass) {
    var classes, type;

    type = bindingClass.type || bindingClass.prototype.type;
    if (!/node|attr/.test(String(type))) {
      throw new Error("node binding class \"" + bindingClass.name + "\" must have a type 'node', or 'attr'");
    }
    classes = allBindingClasses[type];
    if (!bindingClass.prototype.test) {
      bindingClass.prototype.test = function() {
        return true;
      };
    }
    if (!classes[name]) {
      classes[name] = [];
    }
    classes[name].push(bindingClass);
    return this;
  };

  return NodeBindingFactory;

})();

nodeFactory = module.exports = new NodeBindingFactory();

defaultBindingClasses = {
  "default": [require("./attrs/text")],
  "data-bind": [dataBind = module.exports.dataBind = require("./attrs/dataBind")]
};

for (type in defaultBindingClasses) {
  classes = defaultBindingClasses[type];
  for (_i = 0, _len = classes.length; _i < _len; _i++) {
    clazz = classes[_i];
    nodeFactory.register(type, clazz);
  }
}

},{"./attrs/dataBind":26,"./attrs/text":27}],30:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var Clip, bindable, bindings, modifiers, nofactor, template;

Clip = require("../clip");

template = require("./template");

nofactor = require("nofactor");

modifiers = require("./modifiers");

bindings = require("./bindings");

bindable = require("bindable");

module.exports = {
  /*
  */

  Clip: Clip,
  /*
  */

  bindable: bindable,
  /*
   parses a template
  */

  template: template,
  /*
   registers a binding modifier 
   {{ message | titlecase() }}
  */

  modifier: function(name, modifier) {
    return modifiers[name] = modifier;
  },
  /*
   expose the class so that one can be registered
  */

  BaseBlockBinding: bindings.BaseBlockBinding,
  /*
  */

  BaseNodeBinding: bindings.BaseNodeBinding,
  /*
  */

  BaseAttrDataBinding: bindings.BaseAttrDataBinding,
  /*
   adds a block binding class
   {{#custom}}
   {{/}}
  */

  blockBinding: bindings.blockBindingFactory.register,
  /*
   adds a node binding shim
   <custom />
   <div custom="" />
  */

  nodeBinding: bindings.nodeBindingFactory.register,
  /*
    data-bind="{{ custom: binding }}"
  */

  attrDataBinding: bindings.nodeBindingFactory.dataBind.register
};

},{"../clip":3,"./bindings":14,"./modifiers":32,"./template":33,"bindable":84,"nofactor":116}],31:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var BindingCollection, BlockWriter, ElementWriter, FragmentWriter, Loader, TextWriter, bindable, loaf, modifiers;

modifiers = require("./modifiers");

FragmentWriter = require("./writers/fragment");

BlockWriter = require("./writers/block");

TextWriter = require("./writers/text");

ElementWriter = require("./writers/element");

BindingCollection = require("./bindings/collection");

bindable = require("bindable");

loaf = require("loaf");

Loader = (function() {
  /*
  */
  Loader.prototype.__isLoader = true;

  /*
  */


  function Loader(template) {
    this.template = template;
    this.nodeFactory = template.nodeFactory;
    this.paper = template.paper;
    this.bindings = new BindingCollection();
    this._writers = {
      fragment: new FragmentWriter(this),
      block: new BlockWriter(this),
      text: new TextWriter(this),
      element: new ElementWriter(this)
    };
  }

  /*
  */


  Loader.prototype.load = function(context) {
    var node;

    if (context == null) {
      context = {};
    }
    if (!context.__isBindable) {
      context = new bindable.Object(context);
    }
    this.context = context;
    node = this.paper(this._writers.fragment.write, this._writers.block.write, this._writers.element.write, this._writers.text.write, modifiers);
    this.section = loaf();
    this.section.append(node);
    return this;
  };

  /*
  */


  Loader.prototype.bind = function() {
    this.bindings.bind(this.context);
    return this;
  };

  /*
  */


  Loader.prototype.unbind = function() {
    this.bindings.unbind();
    return this;
  };

  /*
  */


  Loader.prototype.toString = function() {
    var div, frag;

    if (this.nodeFactory.name === "string") {
      return this.section.toString();
    }
    frag = this.section.toFragment();
    div = document.createElement("div");
    div.appendChild(frag.cloneNode(true));
    return div.innerHTML;
  };

  return Loader;

})();

module.exports = Loader;

},{"./bindings/collection":13,"./modifiers":32,"./writers/block":36,"./writers/element":37,"./writers/fragment":38,"./writers/text":39,"bindable":84,"loaf":106}],32:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
module.exports = {
  uppercase: function(value) {
    return String(value).toUpperCase();
  },
  lowercase: function(value) {
    return String(value).toLowerCase();
  },
  titlecase: function(value) {
    var str;

    str = String(value);
    return str.substr(0, 1).toUpperCase() + str.substr(1);
  },
  json: function(value, count, delimiter) {
    return JSON.stringify.apply(JSON, arguments);
  }
};

},{}],33:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var Loader, Template, nofactor, tpl;

nofactor = require("nofactor");

Loader = require("./loader");

Template = (function() {
  /*
  */
  function Template(paper, nodeFactory) {
    this.paper = paper;
    this.nodeFactory = nodeFactory;
  }

  /*
  */


  Template.prototype.bind = function(context) {
    return new Loader(this).load(context).bind();
  };

  return Template;

})();

Template.prototype.creator = module.exports = tpl = function(paperOrSrc, nodeFactory) {
  var paper;

  if (nodeFactory == null) {
    nodeFactory = nofactor["default"];
  }
  if (typeof paperOrSrc === "string") {
    if (!tpl.compiler) {
      throw new Error("template must be a function");
    }
    paper = tpl.compiler.compile(paperOrSrc, {
      "eval": true
    });
  } else {
    paper = paperOrSrc;
  }
  return new Template(paper, nodeFactory);
};

},{"./loader":31,"nofactor":116}],34:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var entities;

entities = {
  "<": "lt",
  "&": "amp",
  ">": "gt",
  "\"": "quote"
};

module.exports = function(str) {
  str = String(str);
  return str.split('').map(function(c) {
    var cc, e;

    e = entities[c];
    cc = c.charCodeAt(0);
    if (e) {
      return "&" + e + ";";
    } else if (c.match(/\s/)) {
      return c;
    } else if (cc < 32 || cc > 126) {
      return "&#" + cc + ";";
    }
    return c;
  }).join('');
};

},{}],35:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var BaseWriter;

BaseWriter = (function() {
  /*
  */
  function BaseWriter(loader) {
    this.loader = loader;
    this.nodeFactory = loader.nodeFactory;
    this.bindings = loader.bindings;
    this.template = loader.template;
  }

  return BaseWriter;

})();

module.exports = BaseWriter;

},{}],36:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var BlockWriter, Clip, ClipBinding, blockBindingFactory, loaf, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

loaf = require("loaf");

blockBindingFactory = require("../bindings/block/factory");

Clip = require("../../clip");

ClipBinding = require("../bindings/clip");

BlockWriter = (function(_super) {
  __extends(BlockWriter, _super);

  function BlockWriter() {
    this.write = __bind(this.write, this);    _ref = BlockWriter.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  BlockWriter.prototype.write = function(script, contentFactory, childBlockFactory) {
    var childTpl, clip, section, tpl, _ref1;

    tpl = contentFactory ? this.template.creator(contentFactory) : void 0;
    childTpl = childBlockFactory ? this.template.creator(childBlockFactory) : void 0;
    section = loaf(this.nodeFactory);
    clip = new Clip({
      script: script,
      watch: false
    });
    (_ref1 = this.bindings).push.apply(_ref1, blockBindingFactory.getBindings({
      section: section,
      clip: clip,
      template: tpl,
      nodeFactory: this.nodeFactory,
      childBlockTemplate: childTpl
    }));
    return section.toFragment();
  };

  return BlockWriter;

})(require("./base"));

module.exports = BlockWriter;

},{"../../clip":3,"../bindings/block/factory":9,"../bindings/clip":12,"./base":35,"loaf":106}],37:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var ElementWriter, nodeBindingFactory, type, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

nodeBindingFactory = require("../bindings/node/factory");

type = require("type-component");

ElementWriter = (function(_super) {
  __extends(ElementWriter, _super);

  function ElementWriter() {
    this.write = __bind(this.write, this);    _ref = ElementWriter.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  ElementWriter.prototype.write = function(name, attributes, children) {
    var attrName, child, element, v, _i, _len, _ref1;

    if (attributes == null) {
      attributes = {};
    }
    if (children == null) {
      children = [];
    }
    element = this.nodeFactory.createElement(name);
    for (attrName in attributes) {
      v = attributes[attrName];
      if (v.length === 1 && type(v[0]) === "string") {
        element.setAttribute(attrName, v[0]);
      }
    }
    (_ref1 = this.bindings).push.apply(_ref1, nodeBindingFactory.getBindings({
      node: element,
      nodeName: name,
      attributes: attributes
    }));
    for (_i = 0, _len = children.length; _i < _len; _i++) {
      child = children[_i];
      element.appendChild(child);
    }
    return element;
  };

  return ElementWriter;

})(require("./base"));

module.exports = ElementWriter;

},{"../bindings/node/factory":29,"./base":35,"type-component":119}],38:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var FragmentWriter, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

FragmentWriter = (function(_super) {
  __extends(FragmentWriter, _super);

  function FragmentWriter() {
    this.write = __bind(this.write, this);    _ref = FragmentWriter.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  FragmentWriter.prototype.write = function(children) {
    return this.nodeFactory.createFragment(children);
  };

  return FragmentWriter;

})(require("./base"));

module.exports = FragmentWriter;

},{"./base":35}],39:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var TextWriter, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

TextWriter = (function(_super) {
  __extends(TextWriter, _super);

  function TextWriter() {
    this.write = __bind(this.write, this);    _ref = TextWriter.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  TextWriter.prototype.write = function(text) {
    return this.nodeFactory.createTextNode(text);
  };

  return TextWriter;

})(require("./base"));

module.exports = TextWriter;

},{"./base":35}],40:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var CollectionExpression, base,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

base = require("./expression");

CollectionExpression = (function(_super) {
  __extends(CollectionExpression, _super);

  /*
  */


  CollectionExpression.prototype._type = "collection";

  /*
  */


  function CollectionExpression(items) {
    this.items = items;
    CollectionExpression.__super__.constructor.call(this);
    this.addChild.apply(this, this.items);
  }

  /*
  */


  CollectionExpression.prototype.toString = function() {
    return this.map("toString", "");
  };

  /*
  */


  CollectionExpression.prototype.map = function(method, join) {
    if (join == null) {
      join = "";
    }
    return this.items.map(function(item) {
      return item[method].call(item);
    }).join(join);
  };

  return CollectionExpression;

})(base.Expression);

module.exports = CollectionExpression;

},{"./expression":41}],41:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var Expression;

Expression = (function() {
  /*
  */
  function Expression() {
    this._children = [];
  }

  /*
  */


  Expression.prototype.addChild = function() {
    var child, _i, _len, _results;

    _results = [];
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      child = arguments[_i];
      child._parent = this;
      _results.push(this._children.push(child));
    }
    return _results;
  };

  return Expression;

})();

exports.Expression = Expression;

},{}],42:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var Parser;

Parser = (function() {
  /*
  */
  function Parser(_t) {
    this._t = _t;
  }

  /*
  */


  Parser.prototype.parse = function(source) {
    this._source = source;
    this._t.source(source);
    return this._parse();
  };

  /*
  */


  Parser.prototype._parse = function() {};

  /*
  */


  Parser.prototype._expectNextCode = function(code) {
    if (this._nextCode() !== code) {
      return this._error();
    }
  };

  /*
  */


  Parser.prototype._expectCurrentCode = function(code) {
    if (this._currentCode() !== code) {
      return this._error();
    }
  };

  /*
  */


  Parser.prototype._nextCode = function() {
    var _ref;

    return (_ref = this._t.next()) != null ? _ref[0] : void 0;
  };

  /*
  */


  Parser.prototype._nextCodeSkipWs = function() {
    while (/[\r\n\s\t]+/.test(this._nextString())) {
      true;
    }
    return this._currentCode();
  };

  /*
  */


  Parser.prototype.skipWhitespace = function() {
    var _ref;

    return (_ref = this._t).skipWhitespace.apply(_ref, arguments);
  };

  /*
  */


  Parser.prototype._nextString = function() {
    var _ref;

    return (_ref = this._t.next()) != null ? _ref[1] : void 0;
  };

  /*
  */


  Parser.prototype._currentCode = function() {
    var _ref;

    return (_ref = this._t.current) != null ? _ref[0] : void 0;
  };

  /*
  */


  Parser.prototype._currentString = function() {
    var _ref;

    return (_ref = this._t.current) != null ? _ref[1] : void 0;
  };

  Parser.prototype._error = function() {
    var buffer;

    if (!this._t.current) {
      throw new Error("\n\nUnexpected End Of File\n\n");
    }
    buffer = "\n\nUnexpected Token: " + this._t.current[1] + "\n\n";
    buffer += this._bufferPosInfo();
    throw new Error(buffer);
  };

  Parser.prototype._bufferPosInfo = function() {
    var buffer, char, epos, n, spos, _i, _ref;

    buffer = this._source + "\n";
    epos = this._t.current[2];
    spos = epos - this._t.current[1].length - 1;
    for (n = _i = 0, _ref = this._source.length; 0 <= _ref ? _i <= _ref : _i >= _ref; n = 0 <= _ref ? ++_i : --_i) {
      if (n > spos && n < epos) {
        char = "^";
      } else {
        char = "-";
      }
      buffer += char;
    }
    buffer += "\n\n";
    return buffer;
  };

  return Parser;

})();

module.exports = Parser;

},{}],43:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var Tokenizer, strscan;

strscan = require("strscanner");

/*

1. check if word. If word, then eval until /}|,/
value = parse("name")
*/


Tokenizer = (function() {
  /*
  */
  function Tokenizer() {
    this._s = strscan("", {
      skipWhitespace: true
    });
    this._pool = [];
  }

  /*
  */


  Tokenizer.prototype.peekNext = function() {
    var c, next;

    c = this.current;
    next = this.next();
    this.putBack();
    this.current = c;
    return next;
  };

  /*
  */


  Tokenizer.prototype.source = function(value) {
    if (!arguments.length) {
      return this._source;
    }
    this._s.source(this._source = value);
    return this;
  };

  Tokenizer.prototype.skipWhitespace = function(value) {
    if (!arguments.length) {
      return this._s.skipWhitespace();
    }
    return this._s.skipWhitespace(value);
  };

  /*
  */


  Tokenizer.prototype.putBack = function() {
    if (this.current) {
      return this._pool.push(this.current);
    }
  };

  /*
  */


  Tokenizer.prototype.next = function() {
    if (this._pool.length) {
      return (this.current = this._pool.pop());
    }
    if (this._s.eof()) {
      return (this.current = null);
    }
    return this._next() || this._t(-1, this._s.cchar());
  };

  /*
  */


  Tokenizer.prototype._tstring = function(code) {
    var buffer, c, ccode, cscode, skip;

    ccode = this._s.ccode();
    if (ccode === 39 || ccode === 34) {
      skip = this._s.skipWhitespace();
      this._s.skipWhitespace(false);
      buffer = [];
      while ((c = this._s.nextChar()) && !this._s.eof()) {
        cscode = this._s.ccode();
        if (cscode === 92) {
          buffer.push(this._s.nextChar());
          continue;
        }
        if (cscode === ccode) {
          break;
        }
        buffer.push(c);
      }
      this._s.skipWhitespace(skip);
      return this._t(code, buffer.join(""));
    }
    return false;
  };

  /*
  */


  Tokenizer.prototype._next = function() {};

  /*
  */


  Tokenizer.prototype._t = function(code, value) {
    var p;

    p = this._s.pos();
    this._s.nextChar();
    return this.current = [code, value, p];
  };

  return Tokenizer;

})();

module.exports = Tokenizer;

},{"strscanner":118}],44:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var FnExpression, base,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

base = require("../../base/expression");

FnExpression = (function(_super) {
  __extends(FnExpression, _super);

  /*
  */


  FnExpression.prototype._type = "fn";

  /*
  */


  function FnExpression(name, params) {
    this.name = name;
    this.params = params;
    FnExpression.__super__.constructor.call(this);
    this.addChild(this.params);
  }

  /*
  */


  FnExpression.prototype.toString = function() {
    return this.name;
  };

  return FnExpression;

})(base.Expression);

module.exports = FnExpression;

},{"../../base/expression":41}],45:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var GroupExpresion, ParamsExpression, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

ParamsExpression = require("./params");

GroupExpresion = (function(_super) {
  __extends(GroupExpresion, _super);

  function GroupExpresion() {
    _ref = GroupExpresion.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  GroupExpresion.prototype._type = "group";

  /*
  */


  GroupExpresion.prototype.toString = function() {
    return "(" + (GroupExpresion.__super__.toString.call(this)) + ")";
  };

  return GroupExpresion;

})(ParamsExpression);

module.exports = GroupExpresion;

},{"./params":50}],46:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var JSExpression, base,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

base = require("../../base/expression");

JSExpression = (function(_super) {
  __extends(JSExpression, _super);

  /*
  */


  JSExpression.prototype._type = "js";

  /*
  */


  function JSExpression(value) {
    this.value = value;
    JSExpression.__super__.constructor.call(this);
  }

  /*
  */


  JSExpression.prototype.toString = function() {
    return this.value;
  };

  return JSExpression;

})(base.Expression);

module.exports = JSExpression;

},{"../../base/expression":41}],47:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var ModifierExpression, base,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

base = require("../../base/expression");

ModifierExpression = (function(_super) {
  __extends(ModifierExpression, _super);

  /*
  */


  ModifierExpression.prototype._type = "modifier";

  /*
  */


  function ModifierExpression(name, params, expression) {
    this.name = name;
    this.params = params;
    this.expression = expression;
    ModifierExpression.__super__.constructor.call(this);
    this.addChild(this.params, this.expression);
  }

  /*
  */


  ModifierExpression.prototype.toString = function() {
    var buffer, p, params, _i, _len, _ref;

    buffer = [];
    buffer.push("modifiers");
    buffer.push("." + this.name + "(");
    params = [this.expression.toString()];
    _ref = this.params.items;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      params.push(p.toString());
    }
    buffer.push(params.join(","), ")");
    return buffer.join("");
  };

  return ModifierExpression;

})(base.Expression);

module.exports = ModifierExpression;

},{"../../base/expression":41}],48:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var OptionExpression, base,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

base = require("../../base/expression");

OptionExpression = (function(_super) {
  __extends(OptionExpression, _super);

  /*
  */


  OptionExpression.prototype._type = "option";

  /*
  */


  function OptionExpression(name, expression) {
    this.name = name;
    this.expression = expression;
    OptionExpression.__super__.constructor.call(this);
    this.addChild(expression);
  }

  OptionExpression.prototype.toString = function() {
    return "'" + this.name + "':" + this.expression;
  };

  return OptionExpression;

})(base.Expression);

module.exports = OptionExpression;

},{"../../base/expression":41}],49:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var OptionsExpression, base,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

base = require("../../base/expression");

OptionsExpression = (function(_super) {
  __extends(OptionsExpression, _super);

  /*
  */


  OptionsExpression.prototype._type = "options";

  /*
  */


  function OptionsExpression(items) {
    this.items = items;
    OptionsExpression.__super__.constructor.call(this);
    this.addChild.apply(this, items);
  }

  OptionsExpression.prototype.toString = function() {
    return "{" + (this.items.join(",")) + "}";
  };

  return OptionsExpression;

})(base.Expression);

module.exports = OptionsExpression;

},{"../../base/expression":41}],50:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var CollectionExpression, ParamsExpression, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

CollectionExpression = require("../../base/collectionExpression");

ParamsExpression = (function(_super) {
  __extends(ParamsExpression, _super);

  function ParamsExpression() {
    _ref = ParamsExpression.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  ParamsExpression.prototype._type = "params";

  /*
  */


  ParamsExpression.prototype.toString = function() {
    return this.items.map(function(item) {
      return item.toString();
    }).join(",");
  };

  return ParamsExpression;

})(CollectionExpression);

module.exports = ParamsExpression;

},{"../../base/collectionExpression":40}],51:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var RefExpression;

RefExpression = (function() {
  /*
  */
  RefExpression.prototype._type = "ref";

  /*
  */


  function RefExpression(name) {
    this._children = [];
    if (name.substr(0, 1) === "@") {
      this.self = true;
      this.name = name.substr(1);
    } else {
      this.name = name;
    }
  }

  /*
  */


  RefExpression.prototype.toString = function() {
    return this.name;
  };

  return RefExpression;

})();

module.exports = RefExpression;

},{}],52:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var CollectionExpression, RefPathExpression,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

CollectionExpression = require("../../base/collectionExpression");

RefPathExpression = (function(_super) {
  __extends(RefPathExpression, _super);

  /*
  */


  RefPathExpression.prototype._type = "refPath";

  /*
  */


  function RefPathExpression(items, castAs, assign) {
    this.castAs = castAs;
    this.assign = assign != null ? assign : "";
    RefPathExpression.__super__.constructor.call(this, items);
  }

  /*
  */


  RefPathExpression.prototype.toPathString = function() {
    return this.items.join(".");
  };

  /*
  */


  RefPathExpression.prototype.toString = function() {
    var buffer, currentChain, part, self, _i, _len, _ref;

    buffer = ["this"];
    currentChain = [];
    self = false;
    if (this.castAs) {
      buffer.push(".castAs('" + this.castAs + "')");
    }
    _ref = this.items;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      part = _ref[_i];
      if (part._type === "fn") {
        this._pushRef(buffer, currentChain, self);
        buffer.push(".call('", part.name, "', [");
        buffer.push(part.params.toString(), "])");
        currentChain = [];
        self = false;
      } else {
        currentChain.push(part.name);
        self = self || part.self;
      }
    }
    this._pushRef(buffer, currentChain, self);
    buffer.push(".value(" + this.assign + ")");
    return buffer.join("");
  };

  /*
  */


  RefPathExpression.prototype._pushRef = function(buffer, chain, self) {
    var command;

    if (chain.length) {
      command = self ? "self" : "ref";
      return buffer.push("." + command + "('", chain.join("."), "')");
    }
  };

  return RefPathExpression;

})(CollectionExpression);

module.exports = RefPathExpression;

},{"../../base/collectionExpression":40}],53:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var ActionExpression, base, findRefs, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

base = require("../../base/expression");

_ = require("underscore");

findRefs = function(expr, refs) {
  var child, _i, _len, _ref;

  if (refs == null) {
    refs = [];
  }
  if (!expr) {
    return [];
  }
  if (expr._type === "refPath") {
    refs.push(expr);
  }
  _ref = expr._children;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    findRefs(child, refs);
  }
  return refs;
};

ActionExpression = (function(_super) {
  __extends(ActionExpression, _super);

  /*
  */


  ActionExpression.prototype._type = "script";

  /*
  */


  function ActionExpression(name, options) {
    this.name = name;
    this.options = options;
    ActionExpression.__super__.constructor.call(this);
  }

  /*
  */


  ActionExpression.prototype.toString = function() {
    var refBuffer, refs;

    refs = _.uniq(findRefs(this.options).map(function(ref) {
      return "'" + (ref.toPathString()) + "'";
    }));
    refBuffer = ["[", refs.join(","), "]"].join("");
    return "{ fn: function(){ return " + (this.options ? this.options.toString() : 'true') + "; }, refs: " + refBuffer + " }";
  };

  return ActionExpression;

})(base.Expression);

module.exports = ActionExpression;

},{"../../base/expression":41,"underscore":125}],54:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var ActionsExpression, CollectionExpression,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

CollectionExpression = require("../../base/collectionExpression");

ActionsExpression = (function(_super) {
  __extends(ActionsExpression, _super);

  /*
  */


  ActionsExpression.prototype._type = "scripts";

  /*
  */


  function ActionsExpression(items) {
    ActionsExpression.__super__.constructor.call(this, items);
    this.actions = items;
  }

  /*
  */


  ActionsExpression.prototype.toString = function() {
    var action, buffer, params, _i, _len, _ref;

    buffer = ["{"];
    params = [];
    _ref = this.actions;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      action = _ref[_i];
      params.push("'" + action.name + "': " + (action.toString()));
    }
    buffer.push(params.join(","), "}");
    return buffer.join("");
  };

  return ActionsExpression;

})(CollectionExpression);

module.exports = ActionsExpression;

},{"../../base/collectionExpression":40}],55:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var StringExpression, base;

base = require("../../base/expression");

StringExpression = (function() {
  /*
  */
  StringExpression.prototype._type = "string";

  /*
  */


  function StringExpression(value) {
    this.value = value;
    this._children = [];
  }

  /*
  */


  StringExpression.prototype.toString = function() {
    return "'" + (this.value.replace(/\'/g, "\\'").replace(/\n/g, "\\n")) + "'";
  };

  return StringExpression;

})();

module.exports = StringExpression;

},{"../../base/expression":41}],56:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var BaseParser, CollectionExpression, FnExpression, GroupExpression, JsExpression, ModifierExpression, OptionExpression, OptionsExpression, ParamsExpression, Parser, RefExpression, RefPathExpression, ScriptExpression, ScriptsExpression, StringExpression, TokenCodes, Tokenizer,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Tokenizer = require("./tokenizer");

TokenCodes = Tokenizer.codes;

BaseParser = require("../base/parser");

FnExpression = require("./expressions/fn");

JsExpression = require("./expressions/js");

RefExpression = require("./expressions/ref");

GroupExpression = require("./expressions/group");

ParamsExpression = require("./expressions/params");

StringExpression = require("./expressions/string");

ScriptExpression = require("./expressions/script");

OptionExpression = require("./expressions/option");

ScriptsExpression = require("./expressions/scripts");

OptionsExpression = require("./expressions/options");

RefPathExpression = require("./expressions/refPath");

ModifierExpression = require("./expressions/modifier");

CollectionExpression = require("../base/collectionExpression");

/*
 action:
*/


Parser = (function(_super) {
  __extends(Parser, _super);

  /*
  */


  function Parser() {
    Parser.__super__.constructor.call(this, new Tokenizer());
  }

  /*
  */


  Parser.prototype._parse = function() {
    this._nextCode();
    return this._parseActionsOrOptions();
  };

  /*
  */


  Parser.prototype._parseActionsOrOptions = function() {
    var actions, isExpr, pn;

    actions = [];
    isExpr = !(pn = this._t.peekNext()) || pn[0] !== TokenCodes.COLON;
    if (this._t.current[0] === TokenCodes.BS) {
      this._nextCode();
      isExpr = false;
    }
    if (isExpr) {
      return new ScriptExpression(void 0, this._parseActionOptions());
    }
    while (this._t.current) {
      actions.push(this._parseAction());
      if (this._currentCode() === TokenCodes.COMA) {
        this._nextCode();
      }
    }
    return new ScriptsExpression(actions);
  };

  /*
  */


  Parser.prototype._parseAction = function() {
    var name;

    name = this._currentString();
    this._nextCode();
    this._nextCode();
    return new ScriptExpression(name, this._parseActionOptions());
  };

  /*
  */


  Parser.prototype._parseActionOptions = function() {
    switch (this._currentCode()) {
      case TokenCodes.LB:
        return this._parseMultiOptions();
      default:
        return this._parseReference();
    }
  };

  /*
  */


  Parser.prototype._parseMultiOptions = function() {
    var c, name, options;

    options = [];
    this._nextCode();
    while ((c = this._currentCode()) !== TokenCodes.RB) {
      name = this._currentString();
      this._expectNextCode(TokenCodes.COLON);
      this._nextCode();
      options.push(new OptionExpression(name, this._parseActionOptions()));
      if (this._currentCode() === TokenCodes.COMA) {
        this._nextCode();
      }
    }
    this._nextCode();
    return new OptionsExpression(options);
  };

  /*
  */


  Parser.prototype._parseReference = function() {
    var c, expressions, modifiers;

    expressions = [];
    modifiers = [];
    while (c = this._currentCode()) {
      if (c === TokenCodes.VAR) {
        expressions.push(this._parseRef());
        c = this._currentCode();
      }
      if (c === TokenCodes.LP) {
        expressions.push(this._parseGroup());
        c = this._currentCode();
      }
      if (c === TokenCodes.LB) {
        expressions.push(this._parseActionOptions());
        c = this._currentCode();
      }
      if (c === TokenCodes.STRING) {
        expressions.push(new StringExpression(this._currentString()));
        c = this._nextCode();
      }
      while (c === TokenCodes.PIPE) {
        expressions.push(this._parsePipe(expressions.pop()));
        c = this._currentCode();
      }
      if (~[TokenCodes.RP, TokenCodes.RB].indexOf(c)) {
        break;
      }
      if (!c || ~[TokenCodes.COMA].indexOf(c)) {
        break;
      }
      expressions.push(new JsExpression(this._currentString()));
      this._nextCode();
    }
    if (!expressions.length) {
      return void 0;
    }
    return new CollectionExpression(expressions);
  };

  /*
   filter item.name > 5, test;
  */


  Parser.prototype._parsePipe = function(expressions) {
    var name, params;

    this._nextCode();
    name = this._currentString();
    params = [];
    this._nextCode();
    return new ModifierExpression(name, this._parseParams(), expressions);
  };

  /*
  */


  Parser.prototype._parseParams = function() {
    return new ParamsExpression(this._parseParams2());
  };

  /*
  */


  Parser.prototype._parseParams2 = function() {
    var c, params;

    this._expectCurrentCode(TokenCodes.LP);
    params = [];
    while (c = this._nextCode()) {
      if (c === TokenCodes.RP) {
        break;
      }
      params.push(this._parseReference());
      c = this._currentCode();
      if (c !== TokenCodes.COMA) {
        break;
      }
    }
    this._nextCode();
    return params;
  };

  /*
  */


  Parser.prototype._parseGroup = function() {
    return new GroupExpression(this._parseParams2());
  };

  /*
  */


  Parser.prototype._parseRef = function() {
    var assign, c, castAs, name, refs;

    c = this._currentCode();
    refs = [];
    assign = null;
    while (c === TokenCodes.VAR) {
      name = this._currentString();
      if ((c = this._nextCode()) === TokenCodes.LP) {
        refs.push(new FnExpression(name, this._parseParams()));
        c = this._currentCode();
      } else {
        refs.push(new RefExpression(name));
      }
      if (c === TokenCodes.DOT) {
        c = this._nextCode();
      }
    }
    if (c === TokenCodes.AS) {
      this._nextCode();
      castAs = this._currentString();
      this._nextCode();
    }
    if (c === TokenCodes.ASSIGN) {
      this._nextCode();
      assign = this._parseReference();
    }
    return new RefPathExpression(refs, castAs, assign);
  };

  return Parser;

})(BaseParser);

module.exports = new Parser();

},{"../base/collectionExpression":40,"../base/parser":42,"./expressions/fn":44,"./expressions/group":45,"./expressions/js":46,"./expressions/modifier":47,"./expressions/option":48,"./expressions/options":49,"./expressions/params":50,"./expressions/ref":51,"./expressions/refPath":52,"./expressions/script":53,"./expressions/scripts":54,"./expressions/string":55,"./tokenizer":57}],57:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var BaseTokenizer, Codes, Tokenizer, key, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BaseTokenizer = require("../base/tokenizer");

Codes = (function() {
  function Codes() {}

  Codes.OTHER = -1;

  Codes.WORD = 256;

  Codes.STRING = Codes.WORD + 1;

  Codes.VAR = Codes.STRING + 1;

  Codes.WS = Codes.VAR + 1;

  Codes.NUMBER = Codes.WS + 1;

  Codes.BOOL = Codes.NUMBER + 1;

  Codes.UNDEF = Codes.BOOL + 1;

  Codes.AS = Codes.UNDEF + 1;

  Codes.OR = Codes.AS + 1;

  Codes.ASSIGN = Codes.OR + 1;

  Codes.EQ = Codes.ASSIGN + 1;

  Codes.NEQ = Codes.EQ + 1;

  Codes.NOT = Codes.NEQ + 1;

  Codes.DOLLAR = 36;

  Codes.LP = 40;

  Codes.RP = 41;

  Codes.COMA = 44;

  Codes.DOT = 46;

  Codes.BS = 47;

  Codes.COLON = 58;

  Codes.SEMI_COLON = 59;

  Codes.AT = 64;

  Codes.LB = 123;

  Codes.PIPE = 124;

  Codes.RB = 125;

  Codes.byCodes = {};

  Codes.key = function(code) {
    var key;

    for (key in Codes) {
      if (Codes[key] === code) {
        return key;
      }
    }
  };

  return Codes;

})();

for (key in Codes) {
  Codes.byCodes[Codes[key]] = Codes[key];
}

/*

1. check if word. If word, then eval until /}|,/
value = parse("name")
*/


Tokenizer = (function(_super) {
  __extends(Tokenizer, _super);

  function Tokenizer() {
    _ref = Tokenizer.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  Tokenizer.prototype.codes = Codes;

  Tokenizer.codes = Codes;

  /*
  */


  Tokenizer.prototype._next = function() {
    var ccode, t, word;

    if (this._s.isAZ() || (ccode = this._s.ccode()) === 36 || ccode === 95 || ccode === 64) {
      word = this._s.next(/[_$@a-zA-Z0-9]+/);
      if (/true|false/.test(word)) {
        return this._t(Codes.BOOL, word);
      }
      if (/undefined|null/.test(word)) {
        return this._t(Codes.UNDEF, word);
      }
      if (word === "as") {
        return this._t(Codes.AS, word);
      }
      return this._t(Codes.VAR, word);
    } else if ((t = this._tstring(Codes.STRING))) {
      return t;
    } else if (this._s.is09()) {
      return this._t(Codes.NUMBER, this._s.nextNumber());
    } else if (ccode === 33) {
      if (this._s.peek(2) === "!=") {
        this._s.skip(1);
        return this._t(Codes.NEQ, "!=");
      } else {
        return this._t(Codes.NOT, "!");
      }
    } else if (ccode === 61) {
      if (this._s.peek(2) === "==") {
        this._s.skip(1);
        return this._t(Codes.EQ, "==");
      } else {
        return this._t(Codes.ASSIGN, "=");
      }
    } else if (ccode === 124 && this._s.peek(2) === "||") {
      this._s.nextChar();
      return this._t(Codes.OR, "||");
    } else if (Codes.byCodes[ccode]) {
      return this._t(Codes.byCodes[ccode], this._s.cchar());
    }
  };

  return Tokenizer;

})(BaseTokenizer);

module.exports = Tokenizer;

},{"../base/tokenizer":43}],58:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var formatter, parse, templateParser;

templateParser = require("./template/parser");

formatter = require("./template/formatter");

exports.parse = parse = function(content, options) {
  if (options == null) {
    options = {};
  }
  content = templateParser.parse(content);
  return formatter.format(content);
};

exports.compile = function(content) {
  var module;

  module = {
    exports: {}
  };
  eval(parse(content));
  return module.exports;
};

},{"./template/formatter":71,"./template/parser":72}],59:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var AttributeExpression,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

AttributeExpression = (function(_super) {
  __extends(AttributeExpression, _super);

  AttributeExpression.prototype._type = "attribute";

  /*
  */


  function AttributeExpression(name, value) {
    this.name = name;
    this.value = value;
    AttributeExpression.__super__.constructor.call(this);
    if (this.value) {
      this.addChild(this.value);
    }
  }

  /*
  */


  AttributeExpression.prototype.hasBinding = function() {
    var part, _i, _len, _ref;

    if (!this.value) {
      return false;
    }
    _ref = this.value.items;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      part = _ref[_i];
      if (part._binding) {
        return true;
      }
    }
    return false;
  };

  /*
  */


  AttributeExpression.prototype.toJsString = function() {
    return this.value;
  };

  return AttributeExpression;

})(require("./base"));

module.exports = AttributeExpression;

},{"./base":61}],60:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var AttributesExpression,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

AttributesExpression = (function(_super) {
  __extends(AttributesExpression, _super);

  /*
  */


  function AttributesExpression(items) {
    AttributesExpression.__super__.constructor.call(this, items);
  }

  /*
  */


  AttributesExpression.prototype.toJsString = function() {
    var attr, params, _i, _len, _ref;

    params = [];
    _ref = this._children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      attr = _ref[_i];
      params.push("'" + attr.name + "':" + (attr.value ? attr.value.toJsString() : 'true'));
    }
    return "{" + (params.join(',')) + "}";
  };

  /*
  */


  AttributesExpression.prototype.hasBinding = function() {
    var attr, _i, _len, _ref;

    _ref = this._children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      attr = _ref[_i];
      if (attr.hasBinding()) {
        return true;
      }
    }
    return false;
  };

  /*
  */


  AttributesExpression.prototype.toString = function() {
    var attr, buffer, params, _i, _len, _ref;

    params = [];
    _ref = this._children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      attr = _ref[_i];
      buffer = [];
      buffer.push("" + attr.name);
      if (attr.value) {
        buffer.push("=\"" + attr.value + "\"");
      }
      params.push(buffer.join(""));
    }
    return params.join(" ");
  };

  return AttributesExpression;

})(require("./collection"));

module.exports = AttributesExpression;

},{"./collection":64}],61:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var Base, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Base = (function(_super) {
  __extends(Base, _super);

  function Base() {
    _ref = Base.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  return Base;

})(require("../../base/expression").Expression);

module.exports = Base;

},{"../../base/expression":41}],62:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var Binding, RootExpression,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

RootExpression = require("./root");

Binding = (function(_super) {
  __extends(Binding, _super);

  Binding.prototype._type = "binding";

  /*
  */


  function Binding(script, children, childBinding) {
    this.script = script;
    Binding.__super__.constructor.call(this);
    this.children = new RootExpression(children, false);
    if (childBinding) {
      this.childBinding = new RootExpression(childBinding, false);
    }
    this.addChild(this.children);
  }

  /*
  */


  Binding.prototype.toJsString = function() {
    return "this." + (this.toMethodString());
  };

  /*
  */


  Binding.prototype.toString = function() {
    return "'), " + (this.toMethodString()) + ", text('";
  };

  /*
  */


  Binding.prototype.toMethodString = function() {
    var buffer;

    buffer = ["block(" + this.script + ", " + (this.children.toString())];
    if (this.childBinding) {
      buffer.push(", " + (this.childBinding.toString()));
    }
    buffer.push(")");
    return buffer.join("");
  };

  return Binding;

})(require("./base"));

module.exports = Binding;

},{"./base":61,"./root":66}],63:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var ChildrenExpression,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

ChildrenExpression = (function(_super) {
  __extends(ChildrenExpression, _super);

  ChildrenExpression.prototype._type = "children";

  /*
  */


  function ChildrenExpression(items) {
    ChildrenExpression.__super__.constructor.call(this, items);
  }

  /*
  */


  ChildrenExpression.prototype.toJsString = function() {
    return "{ children: " + (ChildrenExpression.__super__.toJsString.call(this)) + " }";
  };

  /*
  */


  ChildrenExpression.prototype.toString = function() {
    return this.items.join("");
  };

  return ChildrenExpression;

})(require("./collection"));

module.exports = ChildrenExpression;

},{"./collection":64}],64:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var Expression, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Expression = (function(_super) {
  __extends(Expression, _super);

  function Expression() {
    _ref = Expression.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Expression.prototype.toJsString = function() {
    return "[" + (this.map('toJsString', ',')) + "]";
  };

  return Expression;

})(require("../../base/collectionExpression"));

module.exports = Expression;

},{"../../base/collectionExpression":40}],65:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var NodeExpression,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

NodeExpression = (function(_super) {
  __extends(NodeExpression, _super);

  NodeExpression.prototype._type = "node";

  /*
  */


  function NodeExpression(name, attributes, children) {
    this.name = name;
    this.attributes = attributes;
    this.children = children;
    NodeExpression.__super__.constructor.call(this);
    if (attributes) {
      this.addChild(this.attributes);
    }
    if (children) {
      this.addChild(this.children);
    }
  }

  /*
  */


  NodeExpression.prototype.toJsString = function() {
    var buffer, options;

    buffer = ["'), element('" + this.name + "'"];
    options = [];
    if (this.attributes) {
      buffer.push(", " + (this.attributes.toJsString()) + " ");
    } else {
      buffer.push(", {}");
    }
    if (this.children) {
      buffer.push(", [ text('" + (this.children.toString()) + "') ] ");
    }
    buffer.push("), text('");
    return buffer.join("");
  };

  /*
  */


  NodeExpression.prototype.toString = function() {
    return this.toJsString();
  };

  return NodeExpression;

})(require("./base"));

module.exports = NodeExpression;

},{"./base":61}],66:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var RootExpression,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

RootExpression = (function(_super) {
  __extends(RootExpression, _super);

  RootExpression.prototype._method = "html";

  function RootExpression(children, modExports) {
    this.children = children;
    this.modExports = modExports != null ? modExports : true;
    RootExpression.__super__.constructor.call(this);
    this.addChild(children);
  }

  RootExpression.prototype.toString = function() {
    var buffer;

    buffer = [];
    if (this.modExports) {
      buffer.push("module.exports = ");
    }
    buffer.push("function(fragment, block, element, text, modifiers){ return fragment([ text('" + this.children + "') ]) }");
    return buffer.join(" ");
  };

  return RootExpression;

})(require("./base"));

module.exports = RootExpression;

},{"./base":61}],67:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var StringExpression,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

StringExpression = (function(_super) {
  __extends(StringExpression, _super);

  StringExpression.prototype._type = "string";

  /*
  */


  function StringExpression(value) {
    this.value = value;
    StringExpression.__super__.constructor.call(this);
  }

  /*
  */


  StringExpression.prototype.toString = function() {
    return "" + (this.value.replace(/'/g, "\\'").replace(/\n/g, "\\n"));
  };

  /*
  */


  StringExpression.prototype.toJsString = function() {
    return "'" + (this.toString()) + "'";
  };

  return StringExpression;

})(require("./base"));

module.exports = StringExpression;

},{"./base":61}],68:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var TextExpression,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

TextExpression = (function(_super) {
  __extends(TextExpression, _super);

  TextExpression.prototype._type = "text";

  /*
  */


  function TextExpression(buffer) {
    this.buffer = buffer;
    TextExpression.__super__.constructor.call(this);
    this.addChild(this.buffer);
  }

  /*
  */


  TextExpression.prototype.toJsString = function() {
    return "text(" + this.buffer + ")";
  };

  TextExpression.prototype.toString = function() {
    return this.buffer.items.join("");
  };

  return TextExpression;

})(require("./base"));

module.exports = TextExpression;

},{"./base":61}],69:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var TextBindingExpression,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

TextBindingExpression = (function(_super) {
  __extends(TextBindingExpression, _super);

  TextBindingExpression.prototype._type = "textBinding";

  TextBindingExpression.prototype._method = "textBinding";

  TextBindingExpression.prototype._binding = true;

  /*
  */


  function TextBindingExpression(binding) {
    this.binding = binding;
    TextBindingExpression.__super__.constructor.call(this);
  }

  /*
  */


  TextBindingExpression.prototype.toString = function() {
    return "'), " + (this.toMethodString()) + ", text('";
  };

  /*
  */


  TextBindingExpression.prototype.toJsString = function() {
    return this.binding;
  };

  /*
  */


  TextBindingExpression.prototype.toMethodString = function() {
    return "block(" + this.binding + ")";
  };

  return TextBindingExpression;

})(require("./base"));

module.exports = TextBindingExpression;

},{"./base":61}],70:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var TextStringExpression,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

TextStringExpression = (function(_super) {
  __extends(TextStringExpression, _super);

  TextStringExpression.prototype._type = "textString";

  /*
  */


  function TextStringExpression(value) {
    this.value = value;
    TextStringExpression.__super__.constructor.call(this);
  }

  /*
  */


  TextStringExpression.prototype.toJsString = function() {
    return this.value.toJsString();
  };

  /*
  */


  TextStringExpression.prototype.toString = function() {
    return "" + this.value;
  };

  return TextStringExpression;

})(require("./base"));

module.exports = TextStringExpression;

},{"./base":61}],71:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var Formatter, jsp, pro, uglify;

uglify = require("uglify-js");

jsp = uglify.parser;

pro = uglify.uglify;

/*
  Beautifies javascript
*/


Formatter = (function() {
  function Formatter() {}

  /*
  */


  Formatter.prototype.format = function(source) {
    var ast;

    ast = jsp.parse(String(source).replace(/\.push\(\'\'\)/g, "").replace(/\.text\(\'\'\)/g, ""));
    return source = pro.gen_code(ast, {
      beautify: true
    });
  };

  return Formatter;

})();

module.exports = new Formatter();

},{"uglify-js":124}],72:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var AttributeExpression, AttributesExpression, BaseParser, BindingExpression, ChildrenExpression, CollectionExpression, NodeExpression, Parser, RootExpression, StringExpression, TextBindingExpression, TextExpression, TextStringExpression, TokenCodes, Tokenizer, bindingParser,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BaseParser = require("../base/parser");

Tokenizer = require("./tokenizer");

TokenCodes = Tokenizer.Codes;

bindingParser = require("../binding/parser");

RootExpression = require("./expressions/root");

NodeExpression = require("./expressions/node");

TextExpression = require("./expressions/text");

StringExpression = require("./expressions/string");

BindingExpression = require("./expressions/binding");

ChildrenExpression = require("./expressions/children");

AttributeExpression = require("./expressions/attribute");

AttributesExpression = require("./expressions/attributes");

CollectionExpression = require("./expressions/collection");

TextStringExpression = require("./expressions/textString");

TextBindingExpression = require("./expressions/textBinding");

Parser = (function(_super) {
  __extends(Parser, _super);

  /*
  */


  function Parser() {
    Parser.__super__.constructor.call(this);
    this._t = new Tokenizer();
  }

  /*
  */


  Parser.prototype._parse = function() {
    var expr, expressions, i;

    expressions = [];
    i = 0;
    this._nextCode();
    while (this._t.current) {
      expr = this._parseExpression();
      if (expr) {
        expressions.push(expr);
      }
    }
    return new RootExpression(new CollectionExpression(expressions));
  };

  /*
  */


  Parser.prototype._parseExpression = function() {
    var ccode;

    if (!(ccode = this._currentCode())) {
      return null;
    }
    if (ccode === TokenCodes.LT) {
      return this._parseNode();
    } else if (ccode === TokenCodes.SBLOCK) {
      return this._parseBindingBlock();
    } else {
      return this._parseText();
    }
  };

  /*
  */


  Parser.prototype._parseNode = function() {
    var attributes, cchar, children, name;

    name = this._nextString();
    this._nextCode();
    attributes = this._parseAttributes();
    while ((cchar = this._currentCode()) && cchar) {
      if (cchar === TokenCodes.GT) {
        this._nextCode();
        children = this._parseChildren(name);
        break;
      } else if (cchar === TokenCodes.ETNC) {
        this._nextCode();
        break;
      } else {
        this._nextCode();
      }
    }
    return new NodeExpression(name, attributes, children);
  };

  /*
  */


  Parser.prototype._parseAttributes = function() {
    var attrs, ccode;

    attrs = [];
    while (ccode = this._currentCode()) {
      if ((TokenCodes.GT | TokenCodes.ETNC) & ccode) {
        break;
      }
      if (ccode === TokenCodes.WS) {
        this._nextCode();
        continue;
      }
      attrs.push(this._parseAttribute());
    }
    if (!attrs.length) {
      return null;
    }
    return new AttributesExpression(attrs);
  };

  /*
  */


  Parser.prototype._parseChildren = function(nodeName) {
    var ccode, children;

    children = [];
    while ((ccode = this._currentCode()) && ccode) {
      if ((TokenCodes.GT | TokenCodes.EBLOCK) & ccode) {
        break;
      }
      if (ccode === TokenCodes.ETAG) {
        this._nextCode();
        break;
      }
      children.push(this._parseExpression());
    }
    if (!children.length) {
      return null;
    }
    return new CollectionExpression(children);
  };

  /*
  */


  Parser.prototype._parseAttribute = function() {
    var name, value;

    name = this._currentString();
    if (this._nextCode() === TokenCodes.EQ) {
      this._nextCodeSkipWs();
      value = this._parseAttributeValue().buffer;
    }
    return new AttributeExpression(name, value);
  };

  /*
  */


  Parser.prototype._parseAttributeValue = function() {
    var quoteCode, ret;

    quoteCode = this._currentCode();
    this._nextCode();
    ret = this._parseTextUntil(quoteCode);
    this._nextCodeSkipWs();
    return ret;
  };

  /*
  */


  Parser.prototype._parseText = function() {
    return this._parseTextUntil(TokenCodes.EBLOCK | TokenCodes.SBLOCK | TokenCodes.LT | TokenCodes.ETAG);
  };

  /*
  */


  Parser.prototype._parseTextUntil = function(scode) {
    var ccode, items, str;

    items = [];
    while (!((ccode = this._currentCode()) & scode) && ccode) {
      if (ccode === TokenCodes.LM) {
        items.push(this._parseTextBinding());
      } else {
        str = this._parseTextString(TokenCodes.LM | scode);
        if (str) {
          items.push(str);
        }
      }
    }
    return new TextExpression(new CollectionExpression(items));
  };

  /*
  */


  Parser.prototype._parseTextString = function(scode) {
    var buffer, ccode;

    buffer = [];
    while (!((ccode = this._currentCode()) & scode) && ccode) {
      buffer.push(this._currentString());
      this._nextCode();
    }
    return new TextStringExpression(new StringExpression(buffer.join("")));
  };

  /*
  */


  Parser.prototype._parseBindingBlock = function(isChild) {
    var ccode, child, children, script;

    script = this._parseScript(isChild);
    children = [];
    while ((ccode = this._currentCode()) !== TokenCodes.EBLOCK && ccode) {
      children.push(this._parseExpression());
    }
    this._nextCode();
    if (this._currentCode() !== TokenCodes.RM) {
      this._t.putBack();
      child = this._parseBindingBlock(true);
    } else {
      this._nextCode();
    }
    return new BindingExpression(script, new CollectionExpression(children), child);
  };

  /*
  */


  Parser.prototype._parseTextBinding = function() {
    return new TextBindingExpression(this._parseScript());
  };

  /*
  */


  Parser.prototype._parseScript = function(isChild) {
    var buffer, ccode, script;

    this._nextCode();
    buffer = [];
    while (((ccode = this._currentCode()) !== TokenCodes.RM) && ccode) {
      buffer.push(this._currentString());
      this._nextCode();
    }
    if (isChild) {
      buffer.unshift("/");
    }
    script = bindingParser.parse(buffer.join(""));
    this._nextCode();
    return script;
  };

  return Parser;

})(BaseParser);

module.exports = new Parser();

},{"../base/parser":42,"../binding/parser":56,"./expressions/attribute":59,"./expressions/attributes":60,"./expressions/binding":62,"./expressions/children":63,"./expressions/collection":64,"./expressions/node":65,"./expressions/root":66,"./expressions/string":67,"./expressions/text":68,"./expressions/textBinding":69,"./expressions/textString":70,"./tokenizer":73}],73:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var BaseTokenizer, Codes, Tokenizer,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BaseTokenizer = require("../base/tokenizer");

/*
 <div id="test">

 </div>
*/


Codes = (function() {
  function Codes() {}

  Codes.OTHER = -1;

  Codes.WORD = 2;

  Codes.LT = Codes.WORD << 1;

  Codes.GT = Codes.LT << 1;

  Codes.ETNC = Codes.GT << 1;

  Codes.BS = Codes.ETNC << 1;

  Codes.EQ = Codes.BS << 1;

  Codes.STRING = Codes.EQ << 1;

  Codes.LM = Codes.STRING << 1;

  Codes.RM = Codes.LM << 1;

  Codes.SBLOCK = Codes.RM << 1;

  Codes.EBLOCK = Codes.SBLOCK << 1;

  Codes.QUOTE = Codes.EBLOCK << 1;

  Codes.SQUOTE = Codes.QUOTE << 1;

  Codes.ETAG = Codes.SQUOTE << 1;

  Codes.BLOCK = Codes.ETAG << 1;

  Codes.CHAR = Codes.BLOCK << 1;

  Codes.COMMENT = Codes.CHAR << 1;

  Codes.HASH = Codes.COMMENT << 1;

  Codes.WS = Codes.HASH << 1;

  return Codes;

})();

Tokenizer = (function(_super) {
  __extends(Tokenizer, _super);

  /*
  */


  Tokenizer.Codes = Codes;

  /*
  */


  function Tokenizer() {
    Tokenizer.__super__.constructor.call(this);
    this._s.skipWhitespace(false);
  }

  /*
  */


  Tokenizer.prototype._next = function() {
    var cchar, word;

    if (this._s.isAZ()) {
      return this._t(Codes.WORD, this._s.next(/[$_\-a-zA-Z0-9]+/));
    }
    if ((cchar = this._s.cchar()) === "<") {
      if (this._s.peek(4) === "<!--") {
        this._s.skip(4);
        while ((cchar = this._s.cchar()) && cchar) {
          if (cchar === "-") {
            if (this._s.peek(3) === "-->") {
              this._s.skip(3);
              break;
            }
          }
          this._s.nextChar();
        }
        return this._next();
      } else {
        if (this._s.peek(2) === "</") {
          word = this._s.next(/[a-zA-Z0-9]+/);
          this._s.skip(1);
          return this._t(Codes.ETAG, word);
        }
        return this._t(Codes.LT, "<");
      }
    } else if (cchar === "/") {
      if (this._s.peek(2) === "/>") {
        this._s.skip(1);
        return this._t(Codes.ETNC, "/>");
      }
      return this._t(Codes.BS, "/");
    } else if (cchar === ">") {
      return this._t(Codes.GT, ">");
    } else if (this._s.isWs()) {
      this._s.next(/[\s\r\n\t]+/);
      return this._t(Codes.WS, " ");
    } else if (cchar === "{") {
      if (this._s.peek(3) === "{{/") {
        this._s.skip(2);
        return this._t(Codes.EBLOCK, "{{/");
      }
      if (this._s.peek(3) === "{{#") {
        this._s.skip(2);
        return this._t(Codes.SBLOCK, "{{#");
      }
      if (this._s.peek(2) === "{{") {
        this._s.nextChar();
        return this._t(Codes.LM, "{{");
      }
    } else if (cchar === "}") {
      if (this._s.peek(2) === "}}" && this._s.peek(3) !== "}}}") {
        this._s.nextChar();
        return this._t(Codes.RM, "}}");
      }
    } else if (cchar === "=") {
      return this._t(Codes.EQ, "=");
    } else if (cchar === "\"") {
      return this._t(Codes.QUOTE, "\"");
    } else if (cchar === "\'") {
      return this._t(Codes.SQUOTE, "\'");
    } else if (cchar === "#") {
      return this._t(Codes.HASH, "#");
    }
    return this._t(Codes.CHAR, this._s.cchar());
  };

  return Tokenizer;

})(BaseTokenizer);

module.exports = Tokenizer;

},{"../base/tokenizer":43}],74:[function(require,module,exports){
(function(process){/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = setImmediate;
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                }
            }));
        });
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _each(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor !== Array) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (test()) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (!test()) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if(data.constructor !== Array) {
              data = [data];
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain) cargo.drain();
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.compose = function (/* functions... */) {
        var fns = Array.prototype.reverse.call(arguments);
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // AMD / RequireJS
    if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // Node.js
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

})(require("__browserify_process"))
},{"__browserify_process":101}],75:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var SettersFactory, settersFactory, utils;

  SettersFactory = require("./setters/factory");

  settersFactory = new SettersFactory();

  utils = require("../core/utils");

  module.exports = (function() {
    /*
    */
    function _Class(_from) {
      this._from = _from;
      this._limit = -1;
      this._setters = [];
      this._listen();
      this.map(function(value) {
        return value;
      });
    }

    /*
    */


    _Class.prototype.transform = function() {
      return this.map.apply(this, arguments);
    };

    /*
    */


    _Class.prototype.map = function(value) {
      if (!arguments.length) {
        return this._transformer;
      }
      this._transformer = utils.transformer(value);
      return this;
    };

    /*
    */


    _Class.prototype.now = function() {
      var item, setter, _i, _j, _len, _len1, _ref, _ref1;

      _ref = this._setters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        setter = _ref[_i];
        setter.now();
      }
      _ref1 = this._from.source();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        item = _ref1[_j];
        this._callSetters("insert", item);
      }
      return this;
    };

    /*
    */


    _Class.prototype.dispose = function() {
      this._dispose(this._setters);
      this._setters = void 0;
      this._dispose(this._listeners);
      return this._listeners = void 0;
    };

    /*
    */


    _Class.prototype.copyId = function(value) {
      if (!arguments.length) {
        return this._copyId;
      }
      this._copyId = value;
      return this;
    };

    /*
    */


    _Class.prototype._dispose = function(collection) {
      var disposable, _i, _len, _results;

      if (collection) {
        _results = [];
        for (_i = 0, _len = collection.length; _i < _len; _i++) {
          disposable = collection[_i];
          _results.push(disposable.dispose());
        }
        return _results;
      }
    };

    /*
    */


    _Class.prototype.filter = function(search) {
      if (!arguments.length) {
        return this._filter;
      }
      this._filter = search;
      return this;
    };

    /*
    */


    _Class.prototype.to = function(collection, now) {
      var setter;

      if (now == null) {
        now = true;
      }
      setter = settersFactory.createSetter(this, collection);
      if (setter) {
        this._setters.push(setter);
        if (now === true) {
          setter.now();
        }
      }
      return this;
    };

    /*
    */


    _Class.prototype._listen = function() {
      var event, _i, _len, _ref, _results,
        _this = this;

      this._listeners = [];
      _ref = ["insert", "remove", "reset"];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        event = _ref[_i];
        _results.push((function(event) {
          return _this._listeners.push(_this._from.on(event, function(item, index) {
            return _this._callSetters(event, item, index);
          }));
        })(event));
      }
      return _results;
    };

    /*
    */


    _Class.prototype._callSetters = function(method, item, index) {
      var setter, _i, _len, _ref, _results;

      _ref = this._setters;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        setter = _ref[_i];
        _results.push(setter.change(method, item, index));
      }
      return _results;
    };

    return _Class;

  })();

}).call(this);

},{"../core/utils":83,"./setters/factory":79}],76:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var BindableObject, Binding, EventEmitter, computed, dref, hoist, type,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  dref = require("dref");

  Binding = require("./binding");

  EventEmitter = require("../core/eventEmitter");

  type = require("type-component");

  hoist = require("hoist");

  BindableObject = require("../object");

  computed = require("../utils/computed");

  /*
  */


  module.exports = (function(_super) {
    __extends(_Class, _super);

    /*
    */


    _Class.prototype.__isCollection = true;

    /*
    */


    function _Class(source, _id) {
      if (source == null) {
        source = [];
      }
      if (_id == null) {
        _id = "_id";
      }
      this._enforceItemId = __bind(this._enforceItemId, this);
      this.reset = __bind(this.reset, this);
      this.source = __bind(this.source, this);
      _Class.__super__.constructor.call(this);
      this._source = [];
      if (type(source) === "string") {
        _id = source;
        source = [];
      }
      this._length = 0;
      this._id(_id);
      this.__enforceId = false;
      this.transform().postMap(this._enforceItemId);
      this.reset(source);
    }

    /*
    */


    _Class.prototype.empty = function() {
      return !this._length;
    };

    /*
    */


    _Class.prototype.length = function() {
      return this._length;
    };

    /*
    */


    _Class.prototype.source = function(value) {
      if (!arguments.length) {
        return this._source;
      }
      return this.reset(value);
    };

    /*
    */


    _Class.prototype.reset = function(source) {
      if (!source) {
        source = [];
      }
      this.disposeSourceBinding();
      this._remove(this._source || []);
      if (source.__isCollection) {
        this._source = [];
        this._id(source._id());
        this._sourceBinding = source.bind().to(this).now();
        return this;
      }
      this._insert(this._source = this._transform(source));
      this._resetInfo();
      return this;
    };

    /*
    */


    _Class.prototype.disposeSourceBinding = function() {
      if (this._sourceBinding) {
        this._sourceBinding.dispose();
        return this._sourceBinding = void 0;
      }
    };

    /*
    */


    _Class.prototype.bind = function(to) {
      if (type(to) === "string") {
        return _Class.__super__.bind.apply(this, arguments);
      }
      return new Binding(this).to(to);
    };

    /*
    */


    _Class.prototype.set = function(key, value) {
      var k;

      k = Number(key);
      if (isNaN(k)) {
        return _Class.__super__.set.apply(this, arguments);
      }
      return this.splice(k, value);
    };

    /*
    */


    _Class.prototype.get = function(key) {
      var k;

      k = Number(key);
      if (isNaN(k)) {
        return _Class.__super__.get.call(this, key);
      }
      return this.at(k);
    };

    /*
    */


    _Class.prototype.at = function(index) {
      return this._source[index];
    };

    /*
    */


    _Class.prototype.first = function() {
      return this._source[0];
    };

    /*
    */


    _Class.prototype.last = function() {
      return this._source[this._length - 1];
    };

    /*
    */


    _Class.prototype.update = function(item) {};

    /*
    */


    _Class.prototype.remove = function(item) {
      var index;

      index = this.indexOf(item);
      if (!~index) {
        return false;
      }
      this.splice(index, 1);
      return true;
    };

    /*
    */


    _Class.prototype.filter = function(cb) {
      return this._source.filter(cb);
    };

    /*
    */


    _Class.prototype.each = computed("length", function(fn) {
      var item, _i, _len, _ref, _results;

      _ref = this._source;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        _results.push(fn(item));
      }
      return _results;
    });

    /*
    */


    _Class.prototype.splice = function(index, count) {
      var args, remove;

      args = Array.prototype.slice.call(arguments);
      args.splice(0, 2);
      args = this._transform(args);
      remove = this.slice(index, index + count);
      this._source.splice.apply(this._source, arguments);
      this._remove(remove, index);
      return this._insert(args, index);
    };

    /*
    */


    _Class.prototype.transform = function() {
      return this._transformer || (this._transformer = hoist());
    };

    /*
    */


    _Class.prototype.slice = function(start, end) {
      return this._source.slice(start, end);
    };

    /*
    */


    _Class.prototype.indexOf = function(searchItem) {
      var i, item, _i, _len, _ref;

      _ref = this._source;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        item = _ref[i];
        if (dref.get(item, this.__id) === dref.get(searchItem, this.__id)) {
          return i;
        }
      }
      return -1;
    };

    /*
    */


    _Class.prototype._id = function(key) {
      if (!arguments.length) {
        return this.__id;
      }
      if (this.__id === key) {
        return this;
      }
      this.__id = key;
      if (this._source) {
        this._enforceId();
      }
      return this;
    };

    /*
    */


    _Class.prototype.push = function() {
      var items;

      items = this._transform(Array.prototype.slice.call(arguments));
      this._source.push.apply(this._source, items);
      return this._insert(items, this._length);
    };

    /*
    */


    _Class.prototype.unshift = function() {
      var items;

      items = this._transform(Array.prototype.slice.call(arguments));
      this._source.unshift.apply(this._source, items);
      return this._insert(items);
    };

    /*
    */


    _Class.prototype.toJSON = function() {
      var item, source, _i, _len, _ref;

      source = [];
      _ref = this._source;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        source.push((typeof item.toJSON === "function" ? item.toJSON() : void 0) || item);
      }
      return source;
    };

    /*
    */


    _Class.prototype.pop = function() {
      return this._remove([this._source.pop()], this._length)[0];
    };

    /*
    */


    _Class.prototype.shift = function() {
      return this._remove([this._source.shift()], 0)[0];
    };

    /*
    */


    _Class.prototype.enforceId = function(value) {
      if (!arguments.length) {
        return this.__enforceId;
      }
      return this.__enforceId = value;
    };

    /*
    */


    _Class.prototype._enforceId = function() {
      var item, _i, _len, _ref, _results;

      _ref = this._source;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        _results.push(this._enforceItemId(item));
      }
      return _results;
    };

    /*
    */


    _Class.prototype._enforceItemId = function(item) {
      var _id;

      if (!this.__enforceId) {
        return item;
      }
      _id = dref.get(item, this.__id);
      if ((_id === void 0) || (_id === null)) {
        throw new Error("item '" + item + "' must have a '" + this.__id + "'");
      }
      return item;
    };

    /*
    */


    _Class.prototype._insert = function(items, start) {
      var i, item, _i, _len;

      if (start == null) {
        start = 0;
      }
      if (!items.length) {
        return;
      }
      this._length += items.length;
      this._resetInfo();
      for (i = _i = 0, _len = items.length; _i < _len; i = ++_i) {
        item = items[i];
        this.emit("insert", item, start + i);
      }
      return items;
    };

    /*
    */


    _Class.prototype._remove = function(items, start) {
      var i, item, _i, _len;

      if (start == null) {
        start = 0;
      }
      if (!items.length) {
        return;
      }
      this._length -= items.length;
      this._resetInfo();
      for (i = _i = 0, _len = items.length; _i < _len; i = ++_i) {
        item = items[i];
        this.emit("remove", item, start + i);
      }
      return items;
    };

    /*
    */


    _Class.prototype._resetInfo = function() {
      this.set("length", this._length);
      return this.set("empty", !this._length);
    };

    /*
    */


    _Class.prototype._transform = function(item, index, start) {
      var i, results, _i, _len;

      if (!this._transformer) {
        return item;
      }
      if (type(item) === "array") {
        results = [];
        for (_i = 0, _len = item.length; _i < _len; _i++) {
          i = item[_i];
          results.push(this._transformer(i));
        }
        return results;
      }
      return this._transformer(item);
    };

    return _Class;

  })(BindableObject);

}).call(this);

},{"../core/eventEmitter":82,"../object":88,"../utils/computed":95,"./binding":75,"dref":102,"hoist":104,"type-component":119}],77:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var async, utils;

  utils = require("../../core/utils");

  async = require("async");

  module.exports = (function() {
    /*
    */
    function _Class(binding, target) {
      this.binding = binding;
      this.target = target;
      this._transformer = binding.transform();
      this._filter = binding.filter();
      this.init();
    }

    /*
    */


    _Class.prototype.init = function() {};

    /*
    */


    _Class.prototype.now = function() {};

    /*
    */


    _Class.prototype.dispose = function() {};

    /*
    */


    _Class.prototype.change = function(event, item, oldItem) {
      if (event === "reset") {
        return this._changeItems(event, item, oldItem);
      } else {
        return this._changeItem(event, item, oldItem);
        /*
        */

      }
    };

    _Class.prototype._changeItem = function(event, item, oldItem) {
      if (this._filter) {
        if (!this._filter(item)) {
          return;
        }
      }
      return this._change(event, this._transformer.to(item), oldItem);
    };

    /*
    */


    _Class.prototype._changeItems = function(event, items, oldItems) {
      var changed, i, item, _i, _len;

      if (this._filter) {
        changed = items.filter(this._filter);
      } else {
        changed = items.concat();
      }
      for (i = _i = 0, _len = changed.length; _i < _len; i = ++_i) {
        item = changed[i];
        changed[i] = this._transformer.to(item);
      }
      return this._change(events, changed, oldItems);
    };

    /*
    */


    _Class.prototype._change = function(event, item) {};

    /*
    */


    _Class.prototype.bothWays = function() {};

    /*
    */


    _Class.prototype.__transform = function(method, value) {
      return utils.tryTransform(this._transformer, method, [value]);
    };

    return _Class;

  })();

}).call(this);

},{"../../core/utils":83,"async":74}],78:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var ObjSetter, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  ObjSetter = require("./object");

  module.exports = (function(_super) {
    __extends(_Class, _super);

    function _Class() {
      _ref = _Class.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    /*
    */


    _Class.prototype.init = function() {
      var methods,
        _this = this;

      _Class.__super__.init.call(this);
      return this._setter = new ObjSetter(this.binding, methods = {
        insert: function(item) {
          if (_this.binding._copyId) {
            _this.target._id(_this.binding._from._id());
          }
          if (~_this.target.indexOf(item)) {
            return methods.update(item);
          } else {
            return _this.target.push(item);
          }
        },
        update: function(item) {
          return _this.target.update(item);
        },
        reset: function(items, oldItems) {
          var item, _i, _j, _len, _len1, _results;

          for (_i = 0, _len = oldItems.length; _i < _len; _i++) {
            item = oldItems[_i];
            _this.target.remove(item);
          }
          _results = [];
          for (_j = 0, _len1 = items.length; _j < _len1; _j++) {
            item = items[_j];
            _results.push(methods.insert(item));
          }
          return _results;
        },
        remove: function(item) {
          var index;

          index = _this.target.indexOf(item);
          if (~index) {
            return _this.target.splice(index, 1);
          }
        }
      });
    };

    /*
    */


    _Class.prototype.now = function() {
      return this._setter.now();
    };

    /*
    */


    _Class.prototype._change = function() {
      return this._setter._change.apply(this._setter, arguments);
    };

    /*
    */


    _Class.prototype.bothWays = function() {
      throw new Error("cannot bind both ways yet");
    };

    return _Class;

  })(require("./base"));

}).call(this);

},{"./base":77,"./object":81}],79:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var CollectionSetter, FnSetter, ObjSetter;

  FnSetter = require("./fn");

  ObjSetter = require("./object");

  CollectionSetter = require("./collection");

  module.exports = (function() {
    function _Class() {}

    /*
    */


    _Class.prototype.createSetter = function(binding, target) {
      if (!target) {
        return null;
      }
      if (typeof target === "function") {
        return new FnSetter(binding, target);
      } else if (target.__isCollection) {
        return new CollectionSetter(binding, target);
      } else if (target.insert || target.update || target.remove || target.replace) {
        return new ObjSetter(binding, target);
      }
      return null;
    };

    return _Class;

  })();

}).call(this);

},{"./collection":78,"./fn":80,"./object":81}],80:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  module.exports = (function(_super) {
    __extends(_Class, _super);

    function _Class() {
      _ref = _Class.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    /*
    */


    _Class.prototype.init = function() {
      return _Class.__super__.init.call(this);
    };

    /*
    */


    _Class.prototype.now = function() {
      if (this._initialized) {
        return;
      }
      return this._initialized = true;
    };

    /*
    */


    _Class.prototype._change = function(method, item, oldItems) {
      return this.target(method, item, oldItems);
    };

    return _Class;

  })(require("./base"));

}).call(this);

},{"./base":77}],81:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var FnSetter, _, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require("underscore");

  FnSetter = require("./fn");

  module.exports = (function(_super) {
    __extends(_Class, _super);

    function _Class() {
      _ref = _Class.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    /*
    */


    _Class.prototype.init = function() {
      var _this = this;

      _.defaults(this.target, {
        insert: (function(item) {}),
        remove: (function(item) {}),
        reset: (function(item) {})
      });
      return this._setter = new FnSetter(this.binding, function(method, item, index) {
        return _this.target[method].call(_this.target, item, index);
      });
    };

    /*
    */


    _Class.prototype.now = function() {
      return this._setter.now();
    };

    /*
    */


    _Class.prototype._change = function() {
      return this._setter._change.apply(this._setter, arguments);
    };

    return _Class;

  })(require("./base"));

}).call(this);

},{"./base":77,"./fn":80,"underscore":125}],82:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var EventEmitter, disposable, events, type, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  events = require("events");

  disposable = require("disposable");

  type = require("type-component");

  module.exports = EventEmitter = (function(_super) {
    __extends(EventEmitter, _super);

    function EventEmitter() {
      _ref = EventEmitter.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    /*
    */


    EventEmitter.prototype.on = function(key, listener) {
      var disposables, k, keys, listeners,
        _this = this;

      disposables = disposable.create();
      if (arguments.length === 1) {
        listeners = key;
        for (k in listeners) {
          disposables.add(this.on(k, listeners[k]));
        }
        return disposables;
      }
      keys = [];
      if (typeof key === "string") {
        keys = key.split(" ");
      } else {
        keys = key;
      }
      keys.forEach(function(key) {
        EventEmitter.__super__.on.call(_this, key, listener);
        return disposables.add(function() {
          return _this.off(key, listener);
        });
      });
      return disposables;
    };

    /*
    */


    EventEmitter.prototype.once = function(key, listener) {
      var disp, oldListener;

      oldListener = listener;
      if (type(listener) !== "function") {
        throw new Error("listener must be a function");
      }
      disp = this.on(key, function() {
        disp.dispose();
        return oldListener.apply(this, arguments);
      });
      disp.target = this;
      return disp;
    };

    /*
    */


    EventEmitter.prototype.off = function(key, listener) {
      return this.removeListener(key, listener);
    };

    return EventEmitter;

  })(events.EventEmitter);

}).call(this);

},{"disposable":97,"events":99,"type-component":119}],83:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var hoist;

  hoist = require("hoist");

  exports.tryTransform = function(transformer, method, value) {
    if (!transformer) {
      return value[0];
    }
    return transformer[method].call(transformer, value);
  };

  exports.transformer = function(options) {
    if (typeof options === "function") {
      options = {
        from: options,
        to: options
      };
    }
    if (!options.from) {
      options.from = function(value) {
        return value;
      };
    }
    if (!options.to) {
      options.to = function(value) {
        return value;
      };
    }
    return options;
  };

}).call(this);

},{"hoist":104}],84:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var Binding;

  require("dref").use(require("./shim/dref"));

  Binding = require("./object/binding");

  exports.Object = require("./object");

  exports.Collection = require("./collection");

  exports.EventEmitter = require("./core/eventEmitter");

  exports.computed = require("./utils/computed");

  exports.options = require("./utils/options");

  Binding.Collection = exports.Collection;

}).call(this);

},{"./collection":76,"./core/eventEmitter":82,"./object":88,"./object/binding":85,"./shim/dref":94,"./utils/computed":95,"./utils/options":96,"dref":102}],85:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var BindableSetter, Binding, DeepPropertyWatcher, bindableSetter, options, toarray, type, utils,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  BindableSetter = require("./setters/factory");

  bindableSetter = new BindableSetter();

  utils = require("../core/utils");

  options = require("../utils/options");

  toarray = require("toarray");

  DeepPropertyWatcher = require("./deepPropertyWatcher");

  type = require("type-component");

  /*
   Glues stuff together
  */


  module.exports = Binding = (function() {
    /*
    */
    Binding.prototype.__isBinding = true;

    /*
    */


    function Binding(_from, properties) {
      this._from = _from;
      this.now = __bind(this.now, this);
      this._properties = properties.split(/[,\s]+/g);
      this._limit = -1;
      this._delay = options.delay;
      this._setters = [];
      this._cvalues = [];
      this._listeners = [];
      this._triggerCount = 0;
      this.map(function(value) {
        return value;
      });
      this._listen();
    }

    /* 
     executes the binding now
    */


    Binding.prototype.now = function() {
      var hasChanged, listener, nvalues, setter, _i, _j, _len, _len1, _ref, _ref1;

      nvalues = [];
      _ref = this._listeners;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        listener = _ref[_i];
        nvalues.push(listener.value());
      }
      hasChanged = false;
      _ref1 = this._setters;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        setter = _ref1[_j];
        hasChanged = setter.change(nvalues) || hasChanged;
      }
      if (hasChanged && (~this._limit && ++this._triggerCount >= this._limit)) {
        this.dispose();
      }
      return this;
    };

    /*
     casts this binding as a collection binding
    */


    Binding.prototype.collection = function() {
      if (this._collectionBinding) {
        return this._collectionBinding;
      }
      this._collection = new Binding.Collection();
      this.to(this._collection.source);
      this.now();
      return this._collectionBinding = this._collection.bind().copyId(true);
    };

    /*
     binds to a target
    */


    Binding.prototype.to = function(target, property, now) {
      var setter;

      if (now == null) {
        now = false;
      }
      setter = bindableSetter.createSetter(this, target, property);
      if (setter) {
        this._setters.push(setter);
        if (now === true) {
          setter.now();
        }
      }
      return this;
    };

    /*
     from property? create a binding going the other way. This is useful for classes. see class-test.js
    */


    Binding.prototype.from = function(from, property) {
      if (arguments.length === 1) {
        property = from;
        from = this._from;
      }
      return from.bind(property).to(this._from, this._properties);
    };

    /*
     maps the bound value
    */


    Binding.prototype.map = function(options) {
      if (!arguments.length) {
        return this._map;
      }
      this._map = utils.transformer(options);
      return this;
    };

    /*
     runs the binding just once
    */


    Binding.prototype.once = function() {
      return this.limit(1);
    };

    /*
     limits the number of times the binding can be called
    */


    Binding.prototype.limit = function(count) {
      this._limit = count;
      return this;
    };

    /*
     returns whether the binding is bound with ways
    */


    Binding.prototype.isBothWays = function() {
      return !!this._boundBothWays;
    };

    /*  
     makes the binding go both ways.
    */


    Binding.prototype.bothWays = function() {
      var setter, _i, _len, _ref;

      if (this._boundBothWays) {
        return this;
      }
      this._boundBothWays = true;
      _ref = this._setters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        setter = _ref[_i];
        setter.bothWays();
      }
      return this;
    };

    /*
    */


    Binding.prototype.delay = function(value) {
      if (!arguments.length) {
        return this._delay;
      }
      this._delay = value;
      return this;
    };

    /*
     removes the binding
    */


    Binding.prototype.dispose = function() {
      var disposeListener, listener, setter, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;

      _ref = this._setters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        setter = _ref[_i];
        setter.dispose();
      }
      this._setters = [];
      if (this._collectionBinding) {
        this._collectionBinding.dispose();
      }
      if (this._listeners) {
        _ref1 = this._listeners;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          listener = _ref1[_j];
          listener.dispose();
        }
        _ref2 = this._disposeListeners;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          disposeListener = _ref2[_k];
          disposeListener.dispose();
        }
      }
      this._listeners = [];
      this._disposeListeners = [];
      return this;
    };

    /*
    */


    Binding.prototype._listen = function() {
      var disposeListeners, listeners, property, _i, _len, _ref,
        _this = this;

      listeners = [];
      disposeListeners = [];
      _ref = this._properties;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        property = _ref[_i];
        listeners.push(new DeepPropertyWatcher({
          target: this._from,
          path: property.split("."),
          callback: this.now,
          index: 0,
          delay: this._delay
        }));
        disposeListeners.push(this._from.once("dispose", function() {
          return _this.dispose();
        }));
      }
      this._disposeListeners = disposeListeners;
      return this._listeners = listeners;
    };

    return Binding;

  })();

  /*
  */


  Binding.fromOptions = function(target, options) {
    var binding, t, to, tops, _i, _len, _ref;

    binding = target.bind(options.from || options.property);
    if (type(options.to) === "object") {
      for (to in options.to) {
        tops = options.to[to];
        if (tops.transform || tops.map) {
          binding.map(tops.transform || tops.map);
        }
        if (tops.now) {
          binding.now();
        }
        if (tops.bothWays) {
          binding.bothWays();
        }
        binding.to(to);
      }
    } else {
      options.to = toarray(options.to);
      _ref = options.to;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        tops = typeof t === "object" ? t : {
          property: t
        };
        if (tops.transform || tops.map) {
          bindings.map(tops.transform || tops.map);
        }
        binding.to(tops.property);
      }
    }
    if (options.limit) {
      binding.limit(options.limit);
    }
    if (options.once) {
      binding.once();
    }
    if (options.bothWays) {
      binding.bothWays();
    }
    if (options.now) {
      binding.now();
    }
    return binding;
  };

}).call(this);

},{"../core/utils":83,"../utils/options":96,"./deepPropertyWatcher":86,"./setters/factory":92,"toarray":98,"type-component":119}],86:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var PropertyWatcher, options, type,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  type = require("type-component");

  options = require("../utils/options");

  PropertyWatcher = (function() {
    /*
    */
    function PropertyWatcher(options) {
      this._changed = __bind(this._changed, this);      this.target = options.target;
      this.watch = options.watch;
      this.path = options.path;
      this.index = options.index;
      this.root = options.root || this;
      this.delay = options.delay;
      this.callback = options.callback;
      this.property = this.path[this.index];
      this._children = [];
      this._bindings = [];
      this._value = void 0;
      this._values = void 0;
      this._watching = false;
      this._updating = false;
      this._disposed = false;
      if (this._each = this.property.substr(0, 1) === "@") {
        this.root._computeEach = true;
        this.property = this.property.substr(1);
      }
      this._watch();
    }

    /*
    */


    PropertyWatcher.prototype.value = function() {
      var values;

      values = [];
      this._addValues(values);
      if (this._computeEach) {
        return values;
      } else {
        return values[0];
      }
    };

    /*
    */


    PropertyWatcher.prototype._addValues = function(values) {
      var child, _i, _len, _ref;

      if (!this._children.length) {
        if (this._values) {
          values.push.apply(values, this._values);
        } else if (this._value != null) {
          values.push(this._value);
        }
        return;
      }
      _ref = this._children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        child._addValues(values);
      }
      return void 0;
    };

    /*
    */


    PropertyWatcher.prototype.dispose = function() {
      var binding, child, _i, _j, _len, _len1, _ref, _ref1, _ref2;

      this._disposed = true;
      if ((_ref = this._listener) != null) {
        _ref.dispose();
      }
      this._listener = void 0;
      _ref1 = this._bindings;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        binding = _ref1[_i];
        binding.dispose();
      }
      _ref2 = this._children;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        child = _ref2[_j];
        child.dispose();
      }
      this._children = [];
      return this._bindings = [];
    };

    /*
    */


    PropertyWatcher.prototype._update = function() {
      var _this = this;

      if (!~this.delay) {
        this._watch();
        this.callback();
        return;
      }
      if (this._updating) {
        return;
      }
      this._updating = true;
      this._disposed = false;
      return setTimeout((function() {
        if (_this._disposed) {
          return;
        }
        _this._watch();
        return _this.callback();
      }), this.delay);
    };

    /*
    */


    PropertyWatcher.prototype._watch = function() {
      var nt, prop, ref, t, value, _i, _len, _ref;

      this._updating = false;
      if (this.target) {
        if (this.target.__isBindable) {
          if ((nt = this.target.get()).__isBindable) {
            this.target = nt;
          }
          this.watch = this.target;
          this.childPath = this.path.slice(this.index);
          this.childIndex = 1;
          value = this.target.get(this.property);
        } else {
          value = this.target[this.property];
          this.childPath = this.path;
          this.childIndex = this.index + 1;
        }
      } else {
        this.childPath = this.path;
        this.childIndex = this.index + 1;
      }
      if (this._listener) {
        this.dispose();
      }
      this._value = value;
      if (((t = type(value)) === "function") && value.refs) {
        _ref = value.refs;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ref = _ref[_i];
          this._watchRef(ref);
        }
      }
      prop = this.childPath.slice(0, this.childIndex - 1).concat(this.property).join(".");
      this.watch._watching(prop);
      this._listener = this.watch.on("change:" + prop, this._changed);
      if (this._each) {
        return this._watchEachValue(value, t);
      } else {
        return this._watchValue(value);
      }
    };

    /*
    */


    PropertyWatcher.prototype._watchEachValue = function(fnOrArray, t) {
      if (!~this.root.delay) {
        this.root.delay = options.computedDelay;
      }
      switch (t) {
        case "function":
          return this._callEach(fnOrArray);
        case "array":
          return this._loopEach(fnOrArray);
        case "undefined":
          break;
        default:
          throw Error("'@" + this._property + "' is a " + t + ". '@" + this._property + "' must be either an array, or function.");
      }
    };

    /*
     asynchronous
    */


    PropertyWatcher.prototype._callEach = function(fn) {
      var _this = this;

      this._values = [];
      return fn.call(this.target, function(value) {
        _this._values.push(value);
        return _this._watchValue(value);
      });
    };

    /*
     synchronous
    */


    PropertyWatcher.prototype._loopEach = function(values) {
      var value, _i, _len;

      for (_i = 0, _len = values.length; _i < _len; _i++) {
        value = values[_i];
        this._watchValue(value);
      }
      return void 0;
    };

    /*
    */


    PropertyWatcher.prototype._watchValue = function(value) {
      if (this.childIndex < this.childPath.length) {
        return this._children.push(new PropertyWatcher({
          watch: this.watch,
          target: value,
          path: this.childPath,
          index: this.childIndex,
          callback: this.callback,
          root: this.root,
          delay: this.delay
        }));
      }
    };

    /*
    */


    PropertyWatcher.prototype._watchRef = function(ref) {
      return this._bindings.push(new PropertyWatcher({
        target: this.target,
        path: ref.split("."),
        index: 0,
        callback: this._changed,
        delay: this.delay
      }));
    };

    /*
    */


    PropertyWatcher.prototype._changed = function(_value) {
      this._value = _value;
      return this.root._update();
    };

    return PropertyWatcher;

  })();

  module.exports = PropertyWatcher;

}).call(this);

},{"../utils/options":96,"type-component":119}],87:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  exports.get = function(target, key, flatten) {
    var ct, i, k, keyParts, _i, _len;

    if (flatten == null) {
      flatten = true;
    }
    if (!target) {
      return target;
    }
    keyParts = key ? key.split(".") : [];
    ct = target;
    for (i = _i = 0, _len = keyParts.length; _i < _len; i = ++_i) {
      k = keyParts[i];
      if (!ct) {
        return;
      }
      if (ct.__isBindable) {
        return ct.get(keyParts.slice(i).join("."));
      }
      ct = ct[k];
    }
    if (flatten && ct && ct.__isBindable) {
      return ct.get();
    }
    return ct;
  };

  exports.set = function(target, key, value) {
    var ct, i, k, keyParts, n, nv, _i, _len;

    if (!target || !key) {
      return;
    }
    keyParts = key.split(".");
    ct = target.data;
    n = keyParts.length;
    for (i = _i = 0, _len = keyParts.length; _i < _len; i = ++_i) {
      k = keyParts[i];
      if (ct.__isBindable) {
        return ct.set(keyParts.slice(i).join("."), value);
      } else {
        if (i === n - 1) {
          if (ct[k] === value) {
            return false;
          }
          ct[k] = value;
          return true;
        } else {
          nv = ct[k];
          if (!nv || (typeof nv !== "object")) {
            nv = ct[k] = {};
          }
          ct = nv;
        }
      }
    }
  };

}).call(this);

},{}],88:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var Bindable, Binding, EventEmitter, dref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  dref = require("./dref");

  EventEmitter = require("../core/eventEmitter");

  Binding = require("./binding");

  module.exports = Bindable = (function(_super) {
    __extends(Bindable, _super);

    /*
    */


    Bindable.prototype.__isBindable = true;

    /*
    */


    function Bindable(data) {
      Bindable.__super__.constructor.call(this);
      this._initData(data);
      this._bindings = [];
    }

    /*
    */


    Bindable.prototype._initData = function(data) {
      this.data = data != null ? data : {};
    };

    /*
    */


    Bindable.prototype._watching = function(property) {};

    /*
    */


    Bindable.prototype.get = function(key, flatten) {
      var firstProp, keyParts, ret;

      if (flatten == null) {
        flatten = false;
      }
      ret = dref.get(this.data, key, flatten);
      if (ret != null) {
        return ret;
      }
      keyParts = key.split(".");
      firstProp = keyParts.shift();
      ret = dref.get(this[firstProp], keyParts.join("."), flatten);
      if (ret != null) {
        dref.set(this, firstProp, ret);
      }
      return ret;
    };

    /*
    */


    Bindable.prototype.toObject = function(key) {
      return this.get(key, true);
    };

    /*
     DEPRECATED
    */


    Bindable.prototype.getFlatten = function(key) {
      return this.toObject(key);
    };

    /*
    */


    Bindable.prototype.keys = function() {
      return Object.keys(this.getFlatten());
    };

    /*
    */


    Bindable.prototype.has = function(key) {
      return !!this.get(key);
    };

    /*
    */


    Bindable.prototype.set = function(key, value) {
      var k, _i, _len, _ref;

      if (arguments.length === 1) {
        if (key.__isBindable) {
          _ref = key.keys();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            k = _ref[_i];
            this.set(k, key.get(k));
          }
          return;
        }
        for (k in key) {
          this.set(k, key[k]);
        }
        return;
      }
      if (value && value.__isBinding) {
        value.to(this, key);
        return;
      }
      return this._set(key, value);
    };

    /*
    */


    Bindable.prototype.reset = function(newData) {
      var key;

      if (newData == null) {
        newData = {};
      }
      this.set(newData);
      for (key in this.data) {
        if (dref.get(newData, key) == null) {
          this.set(key, void 0);
        }
      }
      return this;
    };

    /*
    */


    Bindable.prototype._set = function(key, value) {
      if (!dref.set(this, key, value)) {
        return this;
      }
      this.emit("change:" + key, value);
      this.emit("change", key, value);
      return this;
    };

    /*
    */


    Bindable.prototype._ref = function(context, key) {
      if (!key) {
        return context;
      }
      return dref.get(context, key);
    };

    /*
    */


    Bindable.prototype.bind = function(property, to) {
      if (typeof property === "object") {
        return Binding.fromOptions(this, property);
      }
      if (to && to.__isBinding) {
        this.set(property, to);
        return;
      }
      return new Binding(this, property).to(to);
    };

    /*
    */


    Bindable.prototype.dispose = function() {
      return this.emit("dispose");
    };

    /*
    */


    Bindable.prototype.toJSON = function() {
      return this.data;
    };

    return Bindable;

  })(EventEmitter);

  module.exports.EventEmitter = EventEmitter;

  module.exports.propertyWatcher = require("./deepPropertyWatcher");

}).call(this);

},{"../core/eventEmitter":82,"./binding":85,"./deepPropertyWatcher":86,"./dref":87}],89:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var utils;

  utils = require("../../core/utils");

  module.exports = (function() {
    /*
    */
    function _Class(binding) {
      this.binding = binding;
      this._map = binding.map();
    }

    /*
    */


    _Class.prototype.change = function(values) {
      var oldValue, value, _ref;

      value = (_ref = this._map).to.apply(_ref, values);
      if (this._value === value) {
        return false;
      }
      oldValue = this._value;
      this._value = value;
      this._change(value, oldValue);
      return true;
    };

    /*
    */


    _Class.prototype.bothWays = function() {};

    /*
    */


    _Class.prototype._change = function(value) {};

    return _Class;

  })();

}).call(this);

},{"../../core/utils":83}],90:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var Base, type,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Base = require("./base");

  type = require("type-component");

  module.exports = (function(_super) {
    __extends(_Class, _super);

    /*
    */


    function _Class(binding, to, property) {
      this.binding = binding;
      this.to = to;
      this.property = property;
      _Class.__super__.constructor.call(this, this.binding);
    }

    /*
    */


    _Class.prototype._change = function(newValue) {
      this._ignoreBothWays = true;
      this.to.set(this.property, newValue);
      return this._ignoreBothWays = false;
    };

    /*
    */


    _Class.prototype.dispose = function() {
      var _ref;

      if ((_ref = this._bothWaysBinding) != null) {
        _ref.dispose();
      }
      return this._bothWaysBinding = this.binding = this.to = this.properties = null;
    };

    /*
    */


    _Class.prototype.bothWays = function() {
      var _this = this;

      return this._bothWaysBinding = this.to.bind(this.property).map({
        to: function() {
          var value, _ref;

          value = (_ref = _this.binding._map).from.apply(_ref, arguments);
          if (type(value) === "array") {
            return value;
          } else {
            return [value];
          }
        }
      }).to(function(values) {
        var i, prop, value, _i, _len, _results;

        if (_this._ignoreBothWays) {
          return;
        }
        _results = [];
        for (i = _i = 0, _len = values.length; _i < _len; i = ++_i) {
          value = values[i];
          prop = _this.binding._properties[i];
          _results.push(_this.binding._from.set(prop, value));
        }
        return _results;
      });
    };

    return _Class;

  })(Base);

}).call(this);

},{"./base":89,"type-component":119}],91:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var Base,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Base = require("./base");

  module.exports = (function(_super) {
    __extends(_Class, _super);

    /*
    */


    function _Class(binding, to, property) {
      this.binding = binding;
      this.to = to;
      this.property = property;
      _Class.__super__.constructor.call(this, this.binding);
    }

    /*
    */


    _Class.prototype._change = function(newValue, oldValue) {
      return this.to.reset(newValue, oldValue);
    };

    /*
    */


    _Class.prototype.dispose = function() {
      return this.to.disposeSourceBinding();
    };

    return _Class;

  })(Base);

}).call(this);

},{"./base":89}],92:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var BindableSetter, CollectionSetter, FnSetter;

  FnSetter = require("./fn");

  BindableSetter = require("./bindable");

  CollectionSetter = require("./collection");

  module.exports = (function() {
    function _Class() {}

    /*
    */


    _Class.prototype.createSetter = function(binding, target, property) {
      var callback, to, toProperty;

      to = null;
      toProperty = null;
      callback = null;
      if (!target && !property) {
        return null;
      }
      if (typeof property === "string") {
        to = target;
        toProperty = property;
      } else if (typeof target === "string") {
        to = binding._from;
        toProperty = target;
      } else if (typeof target === "function") {
        callback = target;
      } else if (typeof target === "object" && target) {
        if (target.__isBinding) {
          throw new Error("Cannot bind to a binding.");
        } else if (target.__isCollection) {
          return new CollectionSetter(binding, target);
        }
      }
      if (callback) {
        return new FnSetter(binding, callback);
      } else if (to && toProperty) {
        return new BindableSetter(binding, to, toProperty);
      }
      return null;
    };

    return _Class;

  })();

}).call(this);

},{"./bindable":90,"./collection":91,"./fn":93}],93:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var Base,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Base = require("./base");

  module.exports = (function(_super) {
    __extends(_Class, _super);

    /*
    */


    function _Class(binding, callback) {
      this.binding = binding;
      this.callback = callback;
      _Class.__super__.constructor.call(this, this.binding);
    }

    /*
    */


    _Class.prototype._change = function(newValue, oldValue) {
      return this.callback(newValue, oldValue);
    };

    /*
    */


    _Class.prototype.dispose = function() {
      return this.callback = null;
    };

    return _Class;

  })(Base);

}).call(this);

},{"./base":89}],94:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  module.exports = {
    test: function(item) {
      return item.get && item.set;
    },
    get: function(item, key) {
      var result;

      result = item.data[key];
      if ((result === null) || (result === void 0)) {
        result = item[key];
      }
      return result;
    },
    set: function(item, key, value) {
      return item.set(key, value);
    }
  };

}).call(this);

},{}],95:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var toarray;

  toarray = require("toarray");

  module.exports = function(properties, fn) {
    properties = toarray(properties);
    fn.refs = properties;
    return fn;
  };

}).call(this);

},{"toarray":98}],96:[function(require,module,exports){
(function(){// Generated by CoffeeScript 1.6.2
/*
 global options
*/


(function() {
  module.exports = {
    delay: -1,
    computedDelay: 0
  };

}).call(this);

})()
},{}],97:[function(require,module,exports){


(function() {

	var _disposable = {};
		


	_disposable.create = function() {
		
		var self = {},
		disposables = [];


		self.add = function(disposable) {

			if(arguments.length > 1) {
				var collection = _disposable.create();
				for(var i = arguments.length; i--;) {
					collection.add(arguments[i]);
				}
				return self.add(collection);
			}

			if(typeof disposable == 'function') {
				
				var disposableFunc = disposable, args = Array.prototype.slice.call(arguments, 0);

				//remove the func
				args.shift();


				disposable = {
					dispose: function() {
						disposableFunc.apply(null, args);
					}
				};
			} else 
			if(!disposable || !disposable.dispose) {
				return false;
			}


			disposables.push(disposable);

			return {
				dispose: function() {
					var i = disposables.indexOf(disposable);
					if(i > -1) disposables.splice(i, 1);
				}
			};
		};

		self.addTimeout = function(timerId) {
			return self.add(function() {
				clearTimeout(timerId);
			});
		};

		self.addInterval = function(timerId) {
			return self.add(function() {
				clearInterval(timerId);
			});
		};

		self.addBinding = function(target) {
			self.add(function() {
				target.unbind();
			});
		};



		self.dispose = function() {
			
			for(var i = disposables.length; i--;) {
				disposables[i].dispose();
			}

			disposables = [];
		};

		return self;
	}



	if(typeof module != 'undefined') {
		module.exports = _disposable;
	}
	else
	if(typeof window != 'undefined') {
		window.disposable = _disposable;
	}


})();


},{}],98:[function(require,module,exports){
module.exports = function(item) {
  if(item === undefined)  return [];
  return Object.prototype.toString.call(item) === "[object Array]" ? item : [item];
}
},{}],99:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":101}],100:[function(require,module,exports){
require=(function(e,t,n,r){function i(r){if(!n[r]){if(!t[r]){if(e)return e(r);throw new Error("Cannot find module '"+r+"'")}var s=n[r]={exports:{}};t[r][0](function(e){var n=t[r][1][e];return i(n?n:e)},s,s.exports)}return n[r].exports}for(var s=0;s<r.length;s++)i(r[s]);return i})(typeof require!=="undefined"&&require,{1:[function(require,module,exports){
// UTILITY
var util = require('util');
var Buffer = require("buffer").Buffer;
var pSlice = Array.prototype.slice;

function objectKeys(object) {
  if (Object.keys) return Object.keys(object);
  var result = [];
  for (var name in object) {
    if (Object.prototype.hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.message = options.message;
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
};
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (value === undefined) {
    return '' + value;
  }
  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (typeof value === 'function' || value instanceof RegExp) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (typeof s == 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

assert.AssertionError.prototype.toString = function() {
  if (this.message) {
    return [this.name + ':', this.message].join(' ');
  } else {
    return [
      this.name + ':',
      truncate(JSON.stringify(this.actual, replacer), 128),
      this.operator,
      truncate(JSON.stringify(this.expected, replacer), 128)
    ].join(' ');
  }
};

// assert.AssertionError instanceof Error

assert.AssertionError.__proto__ = Error.prototype;

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!!!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (expected instanceof RegExp) {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail('Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail('Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

},{"util":2,"buffer":3}],2:[function(require,module,exports){
var events = require('events');

exports.isArray = isArray;
exports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};
exports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};


exports.print = function () {};
exports.puts = function () {};
exports.debug = function() {};

exports.inspect = function(obj, showHidden, depth, colors) {
  var seen = [];

  var stylize = function(str, styleType) {
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    var styles =
        { 'bold' : [1, 22],
          'italic' : [3, 23],
          'underline' : [4, 24],
          'inverse' : [7, 27],
          'white' : [37, 39],
          'grey' : [90, 39],
          'black' : [30, 39],
          'blue' : [34, 39],
          'cyan' : [36, 39],
          'green' : [32, 39],
          'magenta' : [35, 39],
          'red' : [31, 39],
          'yellow' : [33, 39] };

    var style =
        { 'special': 'cyan',
          'number': 'blue',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red' }[styleType];

    if (style) {
      return '\033[' + styles[style][0] + 'm' + str +
             '\033[' + styles[style][1] + 'm';
    } else {
      return str;
    }
  };
  if (! colors) {
    stylize = function(str, styleType) { return str; };
  }

  function format(value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' &&
        // Filter out the util module, it's inspect function is special
        value !== exports &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      return value.inspect(recurseTimes);
    }

    // Primitive types cannot have properties
    switch (typeof value) {
      case 'undefined':
        return stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return stylize(simple, 'string');

      case 'number':
        return stylize('' + value, 'number');

      case 'boolean':
        return stylize('' + value, 'boolean');
    }
    // For some reason typeof null is "object", so special case here.
    if (value === null) {
      return stylize('null', 'null');
    }

    // Look up the keys of the object.
    var visible_keys = Object_keys(value);
    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;

    // Functions without properties can be shortcutted.
    if (typeof value === 'function' && keys.length === 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        var name = value.name ? ': ' + value.name : '';
        return stylize('[Function' + name + ']', 'special');
      }
    }

    // Dates without properties can be shortcutted
    if (isDate(value) && keys.length === 0) {
      return stylize(value.toUTCString(), 'date');
    }

    var base, type, braces;
    // Determine the object type
    if (isArray(value)) {
      type = 'Array';
      braces = ['[', ']'];
    } else {
      type = 'Object';
      braces = ['{', '}'];
    }

    // Make functions say that they are functions
    if (typeof value === 'function') {
      var n = value.name ? ': ' + value.name : '';
      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
    } else {
      base = '';
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + value.toUTCString();
    }

    if (keys.length === 0) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        return stylize('[Object]', 'special');
      }
    }

    seen.push(value);

    var output = keys.map(function(key) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Getter/Setter]', 'special');
          } else {
            str = stylize('[Getter]', 'special');
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Setter]', 'special');
          }
        }
      }
      if (visible_keys.indexOf(key) < 0) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = format(value[key]);
          } else {
            str = format(value[key], recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (isArray(value)) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (type === 'Array' && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    });

    seen.pop();

    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.length + 1;
    }, 0);

    if (length > 50) {
      output = braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];

    } else {
      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    return output;
  }
  return format(obj, (typeof depth === 'undefined' ? 2 : depth));
};


function isArray(ar) {
  return ar instanceof Array ||
         Array.isArray(ar) ||
         (ar && ar !== Object.prototype && isArray(ar.__proto__));
}


function isRegExp(re) {
  return re instanceof RegExp ||
    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');
}


function isDate(d) {
  if (d instanceof Date) return true;
  if (typeof d !== 'object') return false;
  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);
  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);
  return JSON.stringify(proto) === JSON.stringify(properties);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

exports.log = function (msg) {};

exports.pump = null;

var Object_keys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

var Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {
    var res = [];
    for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
};

var Object_create = Object.create || function (prototype, properties) {
    // from es5-shim
    var object;
    if (prototype === null) {
        object = { '__proto__' : null };
    }
    else {
        if (typeof prototype !== 'object') {
            throw new TypeError(
                'typeof prototype[' + (typeof prototype) + '] != \'object\''
            );
        }
        var Type = function () {};
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
    }
    if (typeof properties !== 'undefined' && Object.defineProperties) {
        Object.defineProperties(object, properties);
    }
    return object;
};

exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object_create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (typeof f !== 'string') {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(exports.inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j': return JSON.stringify(args[i++]);
      default:
        return x;
    }
  });
  for(var x = args[i]; i < len; x = args[++i]){
    if (x === null || typeof x !== 'object') {
      str += ' ' + x;
    } else {
      str += ' ' + exports.inspect(x);
    }
  }
  return str;
};

},{"events":4}],5:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],6:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],4:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":6}],"buffer-browserify":[function(require,module,exports){
module.exports=require('q9TxCC');
},{}],"q9TxCC":[function(require,module,exports){
function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.binaryWrite = SlowBuffer.prototype.asciiWrite;

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.binarySlice = SlowBuffer.prototype.asciiSlice;

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

SlowBuffer.prototype.fill = function(value, start, end) {
  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this.parent[i + this.offset] = subject.readUInt8(i);
        }
        else {
          this.parent[i + this.offset] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1];
    }
  } else {
    val = buffer.parent[buffer.offset + offset];
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer.parent[buffer.offset + offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

},{"assert":1,"./buffer_ieee754":5,"base64-js":7}],7:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],8:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],3:[function(require,module,exports){
function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        this.parent[i + this.offset] = subject[i];
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    val |= buffer.parent[buffer.offset + offset + 1];
  } else {
    val = buffer.parent[buffer.offset + offset];
    val |= buffer.parent[buffer.offset + offset + 1] << 8;
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset + 1] << 16;
    val |= buffer.parent[buffer.offset + offset + 2] << 8;
    val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    val = buffer.parent[buffer.offset + offset + 2] << 16;
    val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  buffer.parent[buffer.offset + offset] = value;
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  if (isBigEndian) {
    buffer.parent[buffer.offset + offset] = (value & 0xff00) >>> 8;
    buffer.parent[buffer.offset + offset + 1] = value & 0x00ff;
  } else {
    buffer.parent[buffer.offset + offset + 1] = (value & 0xff00) >>> 8;
    buffer.parent[buffer.offset + offset] = value & 0x00ff;
  }
}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  if (isBigEndian) {
    buffer.parent[buffer.offset + offset] = (value >>> 24) & 0xff;
    buffer.parent[buffer.offset + offset + 1] = (value >>> 16) & 0xff;
    buffer.parent[buffer.offset + offset + 2] = (value >>> 8) & 0xff;
    buffer.parent[buffer.offset + offset + 3] = value & 0xff;
  } else {
    buffer.parent[buffer.offset + offset + 3] = (value >>> 24) & 0xff;
    buffer.parent[buffer.offset + offset + 2] = (value >>> 16) & 0xff;
    buffer.parent[buffer.offset + offset + 1] = (value >>> 8) & 0xff;
    buffer.parent[buffer.offset + offset] = value & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

},{"assert":1,"./buffer_ieee754":8,"base64-js":9}],9:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}]},{},[])
;;module.exports=require("buffer-browserify")

},{}],101:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],102:[function(require,module,exports){
(function(global){var _gss = global._gss = global._gss || [],
type = require("type-component");

/**
 */

var _gs = function(context) {
	for(var i = _gss.length; i--;) {
		var gs = _gss[i];
		if(gs.test(context)) {
			return gs;
		}
	}
}

/**
 */

var _length = function(context) {
	var gs = _gs(context);

	return gs ? gs.length(context) : context.length;
}


/**
 */

var _get = function(context, key) {

	var gs = _gs(context);

	return gs ? gs.get(context, key) : context[key];
}


/**
 */

var _set = function(context, key, value) {

	var gs = _gs(context);

	return gs ? gs.set(context, key, value) : (context[key] = value);
}

/**
 * finds references
 */

var _findValues = function(keyParts, target, create, index, values) {

	if(!values) {
		keyParts = (type(keyParts) === "array" ? keyParts : keyParts.split(".")).filter(function(part) {
			return !!part.length;
		})
		values = [];
		index = 0;
	}

	var ct, j, kp, i = index, n = keyParts.length, pt = target;


	for(;i < n; i++) {
		kp = keyParts[i];
		ct = _get(pt, kp);


		if(kp == '$') {

			for(j = _length(pt); j--;) {
				_findValues(keyParts, _get(pt, j), create, i + 1, values);
			}
			return values;
		} else
		if(ct == undefined || ct == null) {
			if(!create) return values;
			_set(pt, kp, { });
			ct = _get(pt, kp);
		}

		pt = ct;
	}

	if(ct) {
		values.push(ct);
	} else {
		values.push(pt);
	}

	return values;
}


/**
 */

var getValue = function(target, key) {
	key = String(key);
	var values =  _findValues(key, target);

	return key.indexOf('.$.') == -1 ? values[0] : values;
}

/**
 */

var setValue = function(target, key, newValue) {
	key = String(key);
	var keyParts = key.split("."),
	keySet = keyParts.pop();

	if(keySet == '$') {
		keySet = keyParts.pop();
	}

	var values = _findValues(keyParts, target, true);


	for(var i = values.length; i--;) {
		// values[i][keySet] = newValue;
		_set(values[i], keySet, newValue);
	}

}


exports.get = getValue;
exports.set = setValue;
exports.use = function(gs) {
	_gss.push(gs);
}



})(self)
},{"type-component":119}],103:[function(require,module,exports){
(function(Buffer){
(function (global, module) {

  if ('undefined' == typeof module) {
    var module = { exports: {} }
      , exports = module.exports
  }

  /**
   * Exports.
   */

  module.exports = expect;
  expect.Assertion = Assertion;

  /**
   * Exports version.
   */

  expect.version = '0.1.2';

  /**
   * Possible assertion flags.
   */

  var flags = {
      not: ['to', 'be', 'have', 'include', 'only']
    , to: ['be', 'have', 'include', 'only', 'not']
    , only: ['have']
    , have: ['own']
    , be: ['an']
  };

  function expect (obj) {
    return new Assertion(obj);
  }

  /**
   * Constructor
   *
   * @api private
   */

  function Assertion (obj, flag, parent) {
    this.obj = obj;
    this.flags = {};

    if (undefined != parent) {
      this.flags[flag] = true;

      for (var i in parent.flags) {
        if (parent.flags.hasOwnProperty(i)) {
          this.flags[i] = true;
        }
      }
    }

    var $flags = flag ? flags[flag] : keys(flags)
      , self = this

    if ($flags) {
      for (var i = 0, l = $flags.length; i < l; i++) {
        // avoid recursion
        if (this.flags[$flags[i]]) continue;

        var name = $flags[i]
          , assertion = new Assertion(this.obj, name, this)

        if ('function' == typeof Assertion.prototype[name]) {
          // clone the function, make sure we dont touch the prot reference
          var old = this[name];
          this[name] = function () {
            return old.apply(self, arguments);
          }

          for (var fn in Assertion.prototype) {
            if (Assertion.prototype.hasOwnProperty(fn) && fn != name) {
              this[name][fn] = bind(assertion[fn], assertion);
            }
          }
        } else {
          this[name] = assertion;
        }
      }
    }
  };

  /**
   * Performs an assertion
   *
   * @api private
   */

  Assertion.prototype.assert = function (truth, msg, error) {
    var msg = this.flags.not ? error : msg
      , ok = this.flags.not ? !truth : truth;

    if (!ok) {
      throw new Error(msg.call(this));
    }

    this.and = new Assertion(this.obj);
  };

  /**
   * Check if the value is truthy
   *
   * @api public
   */

  Assertion.prototype.ok = function () {
    this.assert(
        !!this.obj
      , function(){ return 'expected ' + i(this.obj) + ' to be truthy' }
      , function(){ return 'expected ' + i(this.obj) + ' to be falsy' });
  };

  /**
   * Assert that the function throws.
   *
   * @param {Function|RegExp} callback, or regexp to match error string against
   * @api public
   */

  Assertion.prototype.throwError =
  Assertion.prototype.throwException = function (fn) {
    expect(this.obj).to.be.a('function');

    var thrown = false
      , not = this.flags.not

    try {
      this.obj();
    } catch (e) {
      if ('function' == typeof fn) {
        fn(e);
      } else if ('object' == typeof fn) {
        var subject = 'string' == typeof e ? e : e.message;
        if (not) {
          expect(subject).to.not.match(fn);
        } else {
          expect(subject).to.match(fn);
        }
      }
      thrown = true;
    }

    if ('object' == typeof fn && not) {
      // in the presence of a matcher, ensure the `not` only applies to
      // the matching.
      this.flags.not = false;
    }

    var name = this.obj.name || 'fn';
    this.assert(
        thrown
      , function(){ return 'expected ' + name + ' to throw an exception' }
      , function(){ return 'expected ' + name + ' not to throw an exception' });
  };

  /**
   * Checks if the array is empty.
   *
   * @api public
   */

  Assertion.prototype.empty = function () {
    var expectation;

    if ('object' == typeof this.obj && null !== this.obj && !isArray(this.obj)) {
      if ('number' == typeof this.obj.length) {
        expectation = !this.obj.length;
      } else {
        expectation = !keys(this.obj).length;
      }
    } else {
      if ('string' != typeof this.obj) {
        expect(this.obj).to.be.an('object');
      }

      expect(this.obj).to.have.property('length');
      expectation = !this.obj.length;
    }

    this.assert(
        expectation
      , function(){ return 'expected ' + i(this.obj) + ' to be empty' }
      , function(){ return 'expected ' + i(this.obj) + ' to not be empty' });
    return this;
  };

  /**
   * Checks if the obj exactly equals another.
   *
   * @api public
   */

  Assertion.prototype.be =
  Assertion.prototype.equal = function (obj) {
    this.assert(
        obj === this.obj
      , function(){ return 'expected ' + i(this.obj) + ' to equal ' + i(obj) }
      , function(){ return 'expected ' + i(this.obj) + ' to not equal ' + i(obj) });
    return this;
  };

  /**
   * Checks if the obj sortof equals another.
   *
   * @api public
   */

  Assertion.prototype.eql = function (obj) {
    this.assert(
        expect.eql(obj, this.obj)
      , function(){ return 'expected ' + i(this.obj) + ' to sort of equal ' + i(obj) }
      , function(){ return 'expected ' + i(this.obj) + ' to sort of not equal ' + i(obj) });
    return this;
  };

  /**
   * Assert within start to finish (inclusive).
   *
   * @param {Number} start
   * @param {Number} finish
   * @api public
   */

  Assertion.prototype.within = function (start, finish) {
    var range = start + '..' + finish;
    this.assert(
        this.obj >= start && this.obj <= finish
      , function(){ return 'expected ' + i(this.obj) + ' to be within ' + range }
      , function(){ return 'expected ' + i(this.obj) + ' to not be within ' + range });
    return this;
  };

  /**
   * Assert typeof / instance of
   *
   * @api public
   */

  Assertion.prototype.a =
  Assertion.prototype.an = function (type) {
    if ('string' == typeof type) {
      // proper english in error msg
      var n = /^[aeiou]/.test(type) ? 'n' : '';

      // typeof with support for 'array'
      this.assert(
          'array' == type ? isArray(this.obj) :
            'object' == type
              ? 'object' == typeof this.obj && null !== this.obj
              : type == typeof this.obj
        , function(){ return 'expected ' + i(this.obj) + ' to be a' + n + ' ' + type }
        , function(){ return 'expected ' + i(this.obj) + ' not to be a' + n + ' ' + type });
    } else {
      // instanceof
      var name = type.name || 'supplied constructor';
      this.assert(
          this.obj instanceof type
        , function(){ return 'expected ' + i(this.obj) + ' to be an instance of ' + name }
        , function(){ return 'expected ' + i(this.obj) + ' not to be an instance of ' + name });
    }

    return this;
  };

  /**
   * Assert numeric value above _n_.
   *
   * @param {Number} n
   * @api public
   */

  Assertion.prototype.greaterThan =
  Assertion.prototype.above = function (n) {
    this.assert(
        this.obj > n
      , function(){ return 'expected ' + i(this.obj) + ' to be above ' + n }
      , function(){ return 'expected ' + i(this.obj) + ' to be below ' + n });
    return this;
  };

  /**
   * Assert numeric value below _n_.
   *
   * @param {Number} n
   * @api public
   */

  Assertion.prototype.lessThan =
  Assertion.prototype.below = function (n) {
    this.assert(
        this.obj < n
      , function(){ return 'expected ' + i(this.obj) + ' to be below ' + n }
      , function(){ return 'expected ' + i(this.obj) + ' to be above ' + n });
    return this;
  };

  /**
   * Assert string value matches _regexp_.
   *
   * @param {RegExp} regexp
   * @api public
   */

  Assertion.prototype.match = function (regexp) {
    this.assert(
        regexp.exec(this.obj)
      , function(){ return 'expected ' + i(this.obj) + ' to match ' + regexp }
      , function(){ return 'expected ' + i(this.obj) + ' not to match ' + regexp });
    return this;
  };

  /**
   * Assert property "length" exists and has value of _n_.
   *
   * @param {Number} n
   * @api public
   */

  Assertion.prototype.length = function (n) {
    expect(this.obj).to.have.property('length');
    var len = this.obj.length;
    this.assert(
        n == len
      , function(){ return 'expected ' + i(this.obj) + ' to have a length of ' + n + ' but got ' + len }
      , function(){ return 'expected ' + i(this.obj) + ' to not have a length of ' + len });
    return this;
  };

  /**
   * Assert property _name_ exists, with optional _val_.
   *
   * @param {String} name
   * @param {Mixed} val
   * @api public
   */

  Assertion.prototype.property = function (name, val) {
    if (this.flags.own) {
      this.assert(
          Object.prototype.hasOwnProperty.call(this.obj, name)
        , function(){ return 'expected ' + i(this.obj) + ' to have own property ' + i(name) }
        , function(){ return 'expected ' + i(this.obj) + ' to not have own property ' + i(name) });
      return this;
    }

    if (this.flags.not && undefined !== val) {
      if (undefined === this.obj[name]) {
        throw new Error(i(this.obj) + ' has no property ' + i(name));
      }
    } else {
      var hasProp;
      try {
        hasProp = name in this.obj
      } catch (e) {
        hasProp = undefined !== this.obj[name]
      }

      this.assert(
          hasProp
        , function(){ return 'expected ' + i(this.obj) + ' to have a property ' + i(name) }
        , function(){ return 'expected ' + i(this.obj) + ' to not have a property ' + i(name) });
    }

    if (undefined !== val) {
      this.assert(
          val === this.obj[name]
        , function(){ return 'expected ' + i(this.obj) + ' to have a property ' + i(name)
          + ' of ' + i(val) + ', but got ' + i(this.obj[name]) }
        , function(){ return 'expected ' + i(this.obj) + ' to not have a property ' + i(name)
          + ' of ' + i(val) });
    }

    this.obj = this.obj[name];
    return this;
  };

  /**
   * Assert that the array contains _obj_ or string contains _obj_.
   *
   * @param {Mixed} obj|string
   * @api public
   */

  Assertion.prototype.string =
  Assertion.prototype.contain = function (obj) {
    if ('string' == typeof this.obj) {
      this.assert(
          ~this.obj.indexOf(obj)
        , function(){ return 'expected ' + i(this.obj) + ' to contain ' + i(obj) }
        , function(){ return 'expected ' + i(this.obj) + ' to not contain ' + i(obj) });
    } else {
      this.assert(
          ~indexOf(this.obj, obj)
        , function(){ return 'expected ' + i(this.obj) + ' to contain ' + i(obj) }
        , function(){ return 'expected ' + i(this.obj) + ' to not contain ' + i(obj) });
    }
    return this;
  };

  /**
   * Assert exact keys or inclusion of keys by using
   * the `.own` modifier.
   *
   * @param {Array|String ...} keys
   * @api public
   */

  Assertion.prototype.key =
  Assertion.prototype.keys = function ($keys) {
    var str
      , ok = true;

    $keys = isArray($keys)
      ? $keys
      : Array.prototype.slice.call(arguments);

    if (!$keys.length) throw new Error('keys required');

    var actual = keys(this.obj)
      , len = $keys.length;

    // Inclusion
    ok = every($keys, function (key) {
      return ~indexOf(actual, key);
    });

    // Strict
    if (!this.flags.not && this.flags.only) {
      ok = ok && $keys.length == actual.length;
    }

    // Key string
    if (len > 1) {
      $keys = map($keys, function (key) {
        return i(key);
      });
      var last = $keys.pop();
      str = $keys.join(', ') + ', and ' + last;
    } else {
      str = i($keys[0]);
    }

    // Form
    str = (len > 1 ? 'keys ' : 'key ') + str;

    // Have / include
    str = (!this.flags.only ? 'include ' : 'only have ') + str;

    // Assertion
    this.assert(
        ok
      , function(){ return 'expected ' + i(this.obj) + ' to ' + str }
      , function(){ return 'expected ' + i(this.obj) + ' to not ' + str });

    return this;
  };
  /**
   * Assert a failure.
   *
   * @param {String ...} custom message
   * @api public
   */
  Assertion.prototype.fail = function (msg) {
    msg = msg || "explicit failure";
    this.assert(false, msg, msg);
    return this;
  };

  /**
   * Function bind implementation.
   */

  function bind (fn, scope) {
    return function () {
      return fn.apply(scope, arguments);
    }
  }

  /**
   * Array every compatibility
   *
   * @see bit.ly/5Fq1N2
   * @api public
   */

  function every (arr, fn, thisObj) {
    var scope = thisObj || global;
    for (var i = 0, j = arr.length; i < j; ++i) {
      if (!fn.call(scope, arr[i], i, arr)) {
        return false;
      }
    }
    return true;
  };

  /**
   * Array indexOf compatibility.
   *
   * @see bit.ly/a5Dxa2
   * @api public
   */

  function indexOf (arr, o, i) {
    if (Array.prototype.indexOf) {
      return Array.prototype.indexOf.call(arr, o, i);
    }

    if (arr.length === undefined) {
      return -1;
    }

    for (var j = arr.length, i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0
        ; i < j && arr[i] !== o; i++);

    return j <= i ? -1 : i;
  };

  // https://gist.github.com/1044128/
  var getOuterHTML = function(element) {
    if ('outerHTML' in element) return element.outerHTML;
    var ns = "http://www.w3.org/1999/xhtml";
    var container = document.createElementNS(ns, '_');
    var elemProto = (window.HTMLElement || window.Element).prototype;
    var xmlSerializer = new XMLSerializer();
    var html;
    if (document.xmlVersion) {
      return xmlSerializer.serializeToString(element);
    } else {
      container.appendChild(element.cloneNode(false));
      html = container.innerHTML.replace('><', '>' + element.innerHTML + '<');
      container.innerHTML = '';
      return html;
    }
  };

  // Returns true if object is a DOM element.
  var isDOMElement = function (object) {
    if (typeof HTMLElement === 'object') {
      return object instanceof HTMLElement;
    } else {
      return object &&
        typeof object === 'object' &&
        object.nodeType === 1 &&
        typeof object.nodeName === 'string';
    }
  };

  /**
   * Inspects an object.
   *
   * @see taken from node.js `util` module (copyright Joyent, MIT license)
   * @api private
   */

  function i (obj, showHidden, depth) {
    var seen = [];

    function stylize (str) {
      return str;
    };

    function format (value, recurseTimes) {
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (value && typeof value.inspect === 'function' &&
          // Filter out the util module, it's inspect function is special
          value !== exports &&
          // Also filter out any prototype objects using the circular check.
          !(value.constructor && value.constructor.prototype === value)) {
        return value.inspect(recurseTimes);
      }

      // Primitive types cannot have properties
      switch (typeof value) {
        case 'undefined':
          return stylize('undefined', 'undefined');

        case 'string':
          var simple = '\'' + json.stringify(value).replace(/^"|"$/g, '')
                                                   .replace(/'/g, "\\'")
                                                   .replace(/\\"/g, '"') + '\'';
          return stylize(simple, 'string');

        case 'number':
          return stylize('' + value, 'number');

        case 'boolean':
          return stylize('' + value, 'boolean');
      }
      // For some reason typeof null is "object", so special case here.
      if (value === null) {
        return stylize('null', 'null');
      }

      if (isDOMElement(value)) {
        return getOuterHTML(value);
      }

      // Look up the keys of the object.
      var visible_keys = keys(value);
      var $keys = showHidden ? Object.getOwnPropertyNames(value) : visible_keys;

      // Functions without properties can be shortcutted.
      if (typeof value === 'function' && $keys.length === 0) {
        if (isRegExp(value)) {
          return stylize('' + value, 'regexp');
        } else {
          var name = value.name ? ': ' + value.name : '';
          return stylize('[Function' + name + ']', 'special');
        }
      }

      // Dates without properties can be shortcutted
      if (isDate(value) && $keys.length === 0) {
        return stylize(value.toUTCString(), 'date');
      }

      var base, type, braces;
      // Determine the object type
      if (isArray(value)) {
        type = 'Array';
        braces = ['[', ']'];
      } else {
        type = 'Object';
        braces = ['{', '}'];
      }

      // Make functions say that they are functions
      if (typeof value === 'function') {
        var n = value.name ? ': ' + value.name : '';
        base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
      } else {
        base = '';
      }

      // Make dates with properties first say the date
      if (isDate(value)) {
        base = ' ' + value.toUTCString();
      }

      if ($keys.length === 0) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return stylize('' + value, 'regexp');
        } else {
          return stylize('[Object]', 'special');
        }
      }

      seen.push(value);

      var output = map($keys, function (key) {
        var name, str;
        if (value.__lookupGetter__) {
          if (value.__lookupGetter__(key)) {
            if (value.__lookupSetter__(key)) {
              str = stylize('[Getter/Setter]', 'special');
            } else {
              str = stylize('[Getter]', 'special');
            }
          } else {
            if (value.__lookupSetter__(key)) {
              str = stylize('[Setter]', 'special');
            }
          }
        }
        if (indexOf(visible_keys, key) < 0) {
          name = '[' + key + ']';
        }
        if (!str) {
          if (indexOf(seen, value[key]) < 0) {
            if (recurseTimes === null) {
              str = format(value[key]);
            } else {
              str = format(value[key], recurseTimes - 1);
            }
            if (str.indexOf('\n') > -1) {
              if (isArray(value)) {
                str = map(str.split('\n'), function (line) {
                  return '  ' + line;
                }).join('\n').substr(2);
              } else {
                str = '\n' + map(str.split('\n'), function (line) {
                  return '   ' + line;
                }).join('\n');
              }
            }
          } else {
            str = stylize('[Circular]', 'special');
          }
        }
        if (typeof name === 'undefined') {
          if (type === 'Array' && key.match(/^\d+$/)) {
            return str;
          }
          name = json.stringify('' + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = stylize(name, 'name');
          } else {
            name = name.replace(/'/g, "\\'")
                       .replace(/\\"/g, '"')
                       .replace(/(^"|"$)/g, "'");
            name = stylize(name, 'string');
          }
        }

        return name + ': ' + str;
      });

      seen.pop();

      var numLinesEst = 0;
      var length = reduce(output, function (prev, cur) {
        numLinesEst++;
        if (indexOf(cur, '\n') >= 0) numLinesEst++;
        return prev + cur.length + 1;
      }, 0);

      if (length > 50) {
        output = braces[0] +
                 (base === '' ? '' : base + '\n ') +
                 ' ' +
                 output.join(',\n  ') +
                 ' ' +
                 braces[1];

      } else {
        output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
      }

      return output;
    }
    return format(obj, (typeof depth === 'undefined' ? 2 : depth));
  };

  function isArray (ar) {
    return Object.prototype.toString.call(ar) == '[object Array]';
  };

  function isRegExp(re) {
    var s;
    try {
      s = '' + re;
    } catch (e) {
      return false;
    }

    return re instanceof RegExp || // easy case
           // duck-type for context-switching evalcx case
           typeof(re) === 'function' &&
           re.constructor.name === 'RegExp' &&
           re.compile &&
           re.test &&
           re.exec &&
           s.match(/^\/.*\/[gim]{0,3}$/);
  };

  function isDate(d) {
    if (d instanceof Date) return true;
    return false;
  };

  function keys (obj) {
    if (Object.keys) {
      return Object.keys(obj);
    }

    var keys = [];

    for (var i in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, i)) {
        keys.push(i);
      }
    }

    return keys;
  }

  function map (arr, mapper, that) {
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, mapper, that);
    }

    var other= new Array(arr.length);

    for (var i= 0, n = arr.length; i<n; i++)
      if (i in arr)
        other[i] = mapper.call(that, arr[i], i, arr);

    return other;
  };

  function reduce (arr, fun) {
    if (Array.prototype.reduce) {
      return Array.prototype.reduce.apply(
          arr
        , Array.prototype.slice.call(arguments, 1)
      );
    }

    var len = +this.length;

    if (typeof fun !== "function")
      throw new TypeError();

    // no value to return if no initial value and an empty array
    if (len === 0 && arguments.length === 1)
      throw new TypeError();

    var i = 0;
    if (arguments.length >= 2) {
      var rv = arguments[1];
    } else {
      do {
        if (i in this) {
          rv = this[i++];
          break;
        }

        // if array contains no values, no initial value to return
        if (++i >= len)
          throw new TypeError();
      } while (true);
    }

    for (; i < len; i++) {
      if (i in this)
        rv = fun.call(null, rv, this[i], i, this);
    }

    return rv;
  };

  /**
   * Asserts deep equality
   *
   * @see taken from node.js `assert` module (copyright Joyent, MIT license)
   * @api private
   */

  expect.eql = function eql (actual, expected) {
    // 7.1. All identical values are equivalent, as determined by ===.
    if (actual === expected) {
      return true;
    } else if ('undefined' != typeof Buffer
        && Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
      if (actual.length != expected.length) return false;

      for (var i = 0; i < actual.length; i++) {
        if (actual[i] !== expected[i]) return false;
      }

      return true;

    // 7.2. If the expected value is a Date object, the actual value is
    // equivalent if it is also a Date object that refers to the same time.
    } else if (actual instanceof Date && expected instanceof Date) {
      return actual.getTime() === expected.getTime();

    // 7.3. Other pairs that do not both pass typeof value == "object",
    // equivalence is determined by ==.
    } else if (typeof actual != 'object' && typeof expected != 'object') {
      return actual == expected;

    // 7.4. For all other Object pairs, including Array objects, equivalence is
    // determined by having the same number of owned properties (as verified
    // with Object.prototype.hasOwnProperty.call), the same set of keys
    // (although not necessarily the same order), equivalent values for every
    // corresponding key, and an identical "prototype" property. Note: this
    // accounts for both named and indexed properties on Arrays.
    } else {
      return objEquiv(actual, expected);
    }
  }

  function isUndefinedOrNull (value) {
    return value === null || value === undefined;
  }

  function isArguments (object) {
    return Object.prototype.toString.call(object) == '[object Arguments]';
  }

  function objEquiv (a, b) {
    if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
      return false;
    // an identical "prototype" property.
    if (a.prototype !== b.prototype) return false;
    //~~~I've managed to break Object.keys through screwy arguments passing.
    //   Converting to array solves the problem.
    if (isArguments(a)) {
      if (!isArguments(b)) {
        return false;
      }
      a = pSlice.call(a);
      b = pSlice.call(b);
      return expect.eql(a, b);
    }
    try{
      var ka = keys(a),
        kb = keys(b),
        key, i;
    } catch (e) {//happens when one is a string literal and the other isn't
      return false;
    }
    // having the same number of owned properties (keys incorporates hasOwnProperty)
    if (ka.length != kb.length)
      return false;
    //the same set of keys (although not necessarily the same order),
    ka.sort();
    kb.sort();
    //~~~cheap key test
    for (i = ka.length - 1; i >= 0; i--) {
      if (ka[i] != kb[i])
        return false;
    }
    //equivalent values for every corresponding key, and
    //~~~possibly expensive deep test
    for (i = ka.length - 1; i >= 0; i--) {
      key = ka[i];
      if (!expect.eql(a[key], b[key]))
         return false;
    }
    return true;
  }

  var json = (function () {
    "use strict";

    if ('object' == typeof JSON && JSON.parse && JSON.stringify) {
      return {
          parse: nativeJSON.parse
        , stringify: nativeJSON.stringify
      }
    }

    var JSON = {};

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    function date(d, key) {
      return isFinite(d.valueOf()) ?
          d.getUTCFullYear()     + '-' +
          f(d.getUTCMonth() + 1) + '-' +
          f(d.getUTCDate())      + 'T' +
          f(d.getUTCHours())     + ':' +
          f(d.getUTCMinutes())   + ':' +
          f(d.getUTCSeconds())   + 'Z' : null;
    };

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

  // If the string contains no control characters, no quote characters, and no
  // backslash characters, then we can safely slap some quotes around it.
  // Otherwise we must also replace the offending characters with safe escape
  // sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

  // Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

  // If the value has a toJSON method, call it to obtain a replacement value.

        if (value instanceof Date) {
            value = date(key);
        }

  // If we were called with a replacer function, then call the replacer to
  // obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

  // What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

  // JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

  // If the value is a boolean or null, convert it to a string. Note:
  // typeof null does not produce 'null'. The case is included here in
  // the remote chance that this gets fixed someday.

            return String(value);

  // If the type is 'object', we might be dealing with an object or an array or
  // null.

        case 'object':

  // Due to a specification blunder in ECMAScript, typeof null is 'object',
  // so watch out for that case.

            if (!value) {
                return 'null';
            }

  // Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

  // Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

  // The value is an array. Stringify every element. Use null as a placeholder
  // for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

  // Join all of the elements together, separated with commas, and wrap them in
  // brackets.

                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

  // If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

  // Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

  // Join all of the member texts together, separated with commas,
  // and wrap them in braces.

            v = partial.length === 0 ? '{}' : gap ?
                '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

  // If the JSON object does not yet have a stringify method, give it one.

    JSON.stringify = function (value, replacer, space) {

  // The stringify method takes a value and an optional replacer, and an optional
  // space parameter, and returns a JSON text. The replacer can be a function
  // that can replace values, or an array of strings that will select the keys.
  // A default replacer method can be provided. Use of the space parameter can
  // produce text that is more easily readable.

        var i;
        gap = '';
        indent = '';

  // If the space parameter is a number, make an indent string containing that
  // many spaces.

        if (typeof space === 'number') {
            for (i = 0; i < space; i += 1) {
                indent += ' ';
            }

  // If the space parameter is a string, it will be used as the indent string.

        } else if (typeof space === 'string') {
            indent = space;
        }

  // If there is a replacer, it must be a function or an array.
  // Otherwise, throw an error.

        rep = replacer;
        if (replacer && typeof replacer !== 'function' &&
                (typeof replacer !== 'object' ||
                typeof replacer.length !== 'number')) {
            throw new Error('JSON.stringify');
        }

  // Make a fake root object containing our value under the key of ''.
  // Return the result of stringifying the value.

        return str('', {'': value});
    };

  // If the JSON object does not yet have a parse method, give it one.

    JSON.parse = function (text, reviver) {
    // The parse method takes a text and an optional reviver function, and returns
    // a JavaScript value if the text is a valid JSON text.

        var j;

        function walk(holder, key) {

    // The walk method is used to recursively walk the resulting structure so
    // that modifications can be made.

            var k, v, value = holder[key];
            if (value && typeof value === 'object') {
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = walk(value, k);
                        if (v !== undefined) {
                            value[k] = v;
                        } else {
                            delete value[k];
                        }
                    }
                }
            }
            return reviver.call(holder, key, value);
        }


    // Parsing happens in four stages. In the first stage, we replace certain
    // Unicode characters with escape sequences. JavaScript handles many characters
    // incorrectly, either silently deleting them, or treating them as line endings.

        text = String(text);
        cx.lastIndex = 0;
        if (cx.test(text)) {
            text = text.replace(cx, function (a) {
                return '\\u' +
                    ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            });
        }

    // In the second stage, we run the text against regular expressions that look
    // for non-JSON patterns. We are especially concerned with '()' and 'new'
    // because they can cause invocation, and '=' because it can cause mutation.
    // But just to be safe, we want to reject all unexpected forms.

    // We split the second stage into 4 regexp operations in order to work around
    // crippling inefficiencies in IE's and Safari's regexp engines. First we
    // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
    // replace all simple value tokens with ']' characters. Third, we delete all
    // open brackets that follow a colon or comma or that begin the text. Finally,
    // we look to see that the remaining characters are only whitespace or ']' or
    // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

        if (/^[\],:{}\s]*$/
                .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                    .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                    .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

    // In the third stage we use the eval function to compile the text into a
    // JavaScript structure. The '{' operator is subject to a syntactic ambiguity
    // in JavaScript: it can begin a block or an object literal. We wrap the text
    // in parens to eliminate the ambiguity.

            j = eval('(' + text + ')');

    // In the optional fourth stage, we recursively walk the new structure, passing
    // each name/value pair to a reviver function for possible transformation.

            return typeof reviver === 'function' ?
                walk({'': j}, '') : j;
        }

    // If the text is not JSON parseable, then a SyntaxError is thrown.

        throw new SyntaxError('JSON.parse');
    };

    return JSON;
  })();

  if ('undefined' != typeof window) {
    window.expect = module.exports;
  }

})(
    this
  , 'undefined' != typeof module ? module : {}
  , 'undefined' != typeof exports ? exports : {}
);

})(require("__browserify_Buffer").Buffer)
},{"__browserify_Buffer":100}],104:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var method, transformer, _fn, _i, _len, _ref,
    _this = this;

  transformer = require("./transformer");

  module.exports = transformer;

  _ref = ["cast", "map", "preCast", "preMap", "postCast", "postMap"];
  _fn = function(method) {
    return module.exports[method] = function() {
      var t;

      t = transformer();
      return t[method].apply(t, arguments);
    };
  };
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    method = _ref[_i];
    _fn(method);
  }

}).call(this);

},{"./transformer":105}],105:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var async, getArrayTypeCaster, getClassTypeCaster, getSimpleDataTypeCaster, getTypeCaster, type;

  type = require("type-component");

  async = require("async");

  /*
  */


  getArrayTypeCaster = function() {
    return function(value) {
      if (type(value) === "array") {
        return value;
      }
      return [value];
    };
  };

  /*
  */


  getSimpleDataTypeCaster = function(typeClass) {
    return function(value) {
      return typeClass(value);
    };
  };

  /*
  */


  getClassTypeCaster = function(typeClass) {
    return function(value) {
      if (value && value.constructor === typeClass) {
        return value;
      }
      return new typeClass(value);
    };
  };

  /*
  */


  getTypeCaster = function(typeClass) {
    if (typeClass === Array) {
      return getArrayTypeCaster();
    }
    if ((typeClass === String) || (typeClass === Number)) {
      return getSimpleDataTypeCaster(typeClass);
    }
    return getClassTypeCaster(typeClass);
  };

  /*
  */


  module.exports = function(options) {
    var caster, mapper, self, _mid, _post, _pre, _transform;

    if (options == null) {
      options = {};
    }
    _transform = [];
    _pre = [];
    _post = [];
    _mid = [];
    /*
    */

    self = function(value, next) {
      if (arguments.length > 1 && type(arguments[arguments.length - 1]) === "function") {
        return self.async(value, next);
      } else {
        return self.sync.apply(null, arguments);
      }
    };
    /*
    */

    self.async = function(value, next) {
      return async.eachSeries(_transform, (function(transformer, next) {
        if (transformer.async) {
          return transformer.transform(value, function(err, result) {
            if (err) {
              return next(err);
            }
            return next(null, value = result);
          });
        } else {
          value = transformer.transform(value);
          return next();
        }
      }), function(err, result) {
        if (err) {
          return next(err);
        }
        return next(null, value);
      });
    };
    /*
    */

    self.sync = function() {
      var transformer, _i, _len;

      for (_i = 0, _len = _transform.length; _i < _len; _i++) {
        transformer = _transform[_i];
        arguments[0] = transformer.transform.apply(null, arguments);
      }
      return arguments[0];
    };
    /*
    */

    self.preCast = function(typeClass) {
      return self._push(caster(typeClass), _pre);
    };
    /*
    */

    self.cast = function(typeClass) {
      return self._push(caster(typeClass), _mid);
    };
    /*
    */

    self.postCast = function(typeClass) {
      return self._push(caster(typeClass), _post);
    };
    /*
    */

    caster = function(typeClass) {
      return {
        transform: getTypeCaster(typeClass)
      };
    };
    /*
    */

    self.preMap = function(fn) {
      return self._push(mapper(fn), _pre);
    };
    /*
    */

    self.map = function(fn) {
      return self._push(mapper(fn), _mid);
    };
    /*
    */

    self.postMap = function(fn) {
      return self._push(mapper(fn), _post);
    };
    /*
    */

    mapper = function(fn) {
      return {
        async: fn.length > 1,
        transform: fn
      };
    };
    /*
    */

    self._push = function(obj, stack) {
      stack.push(obj);
      _transform = _pre.concat(_mid).concat(_post);
      return this;
    };
    return self;
  };

}).call(this);

},{"async":74,"type-component":119}],106:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var Section;

Section = require("./section");

module.exports = function(nodeFactory) {
  return new Section(nodeFactory);
};

},{"./section":107}],107:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var Section, nofactor,
  __slice = [].slice;

nofactor = require("nofactor");

Section = (function() {
  /*
  */
  Section.prototype.__isLoafSection = true;

  /*
  */


  function Section(nodeFactory) {
    this.nodeFactory = nodeFactory != null ? nodeFactory : nofactor["default"];
    this.start = this.nodeFactory.createTextNode("");
    this.end = this.nodeFactory.createTextNode("");
    this._addParent();
  }

  /*
  */


  Section.prototype.replace = function(node) {
    node.parentNode.insertBefore(this.toFragment(), node);
    return node.parentNode.removeChild(node);
  };

  /*
  */


  Section.prototype.show = function() {
    var allElements, childLoad, node, _i, _len, _ref;

    if (!this._detached) {
      return this;
    }
    this._addParent();
    allElements = [];
    _ref = this._detached;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      if (node.parentNode && (childLoad = node.parentNode._loaf)) {
        node.parentNode._loaf = void 0;
        allElements.push(childLoad.toFragment());
      } else {
        allElements.push(node);
      }
    }
    this.append.apply(this, allElements);
    this._detached = void 0;
    return this;
  };

  /*
  */


  Section.prototype.hide = function() {
    this._detached = this.removeAll();
    return this;
  };

  /*
  */


  Section.prototype.removeAll = function() {
    var child, children, _i, _len;

    children = this.getChildNodes();
    children.shift();
    children.pop();
    for (_i = 0, _len = children.length; _i < _len; _i++) {
      child = children[_i];
      this.start.parentNode.removeChild(child);
    }
    return children;
  };

  /*
  */


  Section.prototype.append = function() {
    var children;

    children = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this._insertAfter(children, this.end.previousSibling);
  };

  /*
  */


  Section.prototype.prepend = function() {
    var children;

    children = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this._insertAfter(children, this.start);
  };

  /*
  */


  Section.prototype.replaceChildNodes = function() {
    this.removeAll();
    return this.append.apply(this, arguments);
  };

  /*
  */


  Section.prototype.toString = function() {
    var buffer;

    buffer = this.getChildNodes().map(function(node) {
      return node.innerHTML || String(node);
    });
    return buffer.join("");
  };

  /*
  */


  Section.prototype.toFragment = function() {
    return this.nodeFactory.createFragment(this.getChildNodes());
  };

  /*
  */


  Section.prototype.dispose = function() {
    var child, _i, _len, _ref, _results;

    _ref = this.getChildNodes();
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      _results.push(child.parentNode.removeChild(child));
    }
    return _results;
  };

  /*
  */


  Section.prototype.getChildNodes = function() {
    var children, cn, end;

    this._addParent();
    cn = this.start;
    end = this.end.nextSibling;
    children = [];
    while (cn !== end) {
      children.push(cn);
      cn = cn.nextSibling;
    }
    return children;
  };

  /*
  */


  Section.prototype._insertAfter = function(newNodes, refNode) {
    newNodes = newNodes.map(function(node) {
      if (node.__isLoafSection) {
        return node.toFragment();
      } else {
        return node;
      }
    });
    if (newNodes.length > 1) {
      newNodes = this.nodeFactory.createFragment(newNodes);
    } else {
      newNodes = newNodes[0];
    }
    this._addParent();
    return refNode.parentNode.insertBefore(newNodes, refNode.nextSibling);
  };

  /*
  */


  Section.prototype._addParent = function() {
    var parent;

    if (!this.start.parentNode) {
      parent = this.nodeFactory.createElement("div");
      parent._loaf = this;
      parent.appendChild(this.start);
      return parent.appendChild(this.end);
    }
  };

  return Section;

})();

module.exports = Section;

},{"nofactor":111}],108:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var BaseFactory;

BaseFactory = (function() {
  function BaseFactory() {}

  /*
  */


  BaseFactory.prototype.createElement = function(element) {};

  /*
  */


  BaseFactory.prototype.createFragment = function() {};

  /*
  */


  BaseFactory.prototype.createComment = function(text) {};

  /*
  */


  BaseFactory.prototype.createTextNode = function(text) {};

  /*
  */


  BaseFactory.prototype.parseHtml = function(content) {};

  return BaseFactory;

})();

},{}],109:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var DomFactory,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

DomFactory = (function(_super) {
  __extends(DomFactory, _super);

  /*
  */


  DomFactory.prototype.name = "dom";

  /*
  */


  function DomFactory() {}

  /*
  */


  DomFactory.prototype.createElement = function(name) {
    return document.createElement(name);
  };

  /*
  */


  DomFactory.prototype.createTextNode = function(text) {
    return document.createTextNode(text);
  };

  /*
  */


  DomFactory.prototype.createFragment = function(children) {
    var child, frag, _i, _len;

    if (children == null) {
      children = [];
    }
    frag = document.createDocumentFragment();
    for (_i = 0, _len = children.length; _i < _len; _i++) {
      child = children[_i];
      frag.appendChild(child);
    }
    return frag;
  };

  /*
  */


  DomFactory.prototype.parseHtml = function(text) {
    var div;

    div = this.createElement("div");
    div.innerHTML = text;
    return this.createFragment.apply(this, div.childNodes);
  };

  return DomFactory;

})(require("./base"));

module.exports = new DomFactory();

},{"./base":108}],110:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var entities;

entities = {
  "<": "lt",
  "&": "amp",
  ">": "gt",
  "\"": "quote"
};

module.exports = function(str) {
  str = String(str);
  return str.split('').map(function(c) {
    var cc, e;

    e = entities[c];
    cc = c.charCodeAt(0);
    if (e) {
      return "&" + e + ";";
    } else if (c.match(/\s/)) {
      return c;
    } else if (cc < 32 || cc > 126) {
      return "&#" + cc + ";";
    }
    return c;
  }).join('');
};

},{}],111:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
module.exports = {
  string: require("./string"),
  dom: require("./dom")
};

module.exports["default"] = typeof window !== "undefined" ? module.exports.dom : module.exports.string;

},{"./dom":109,"./string":112}],112:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var Comment, Container, Element, Fragment, Node, StringNodeFactory, Style, Text, bindable, ent, _ref, _ref1,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

bindable = require("bindable");

ent = require("./ent");

Node = (function() {
  function Node() {}

  Node.prototype.__isNode = true;

  return Node;

})();

Container = (function(_super) {
  __extends(Container, _super);

  /*
  */


  function Container() {
    this.childNodes = [];
  }

  /*
  */


  Container.prototype.appendChild = function(node) {
    var child, _i, _len, _ref;

    if (node.nodeType === 11) {
      _ref = node.childNodes.concat();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        this.appendChild(child);
      }
      return;
    }
    this._unlink(node);
    this.childNodes.push(node);
    return this._link(node);
  };

  /*
  */


  Container.prototype.removeChild = function(child) {
    var i, _ref, _ref1;

    i = this.childNodes.indexOf(child);
    if (!~i) {
      return;
    }
    this.childNodes.splice(i, 1);
    if ((_ref = child.previousSibling) != null) {
      _ref.nextSibling = child.nextSibling;
    }
    if ((_ref1 = child.nextSibling) != null) {
      _ref1.previousSibling = child.previousSibling;
    }
    return child.parentNode = child.nextSibling = child.previousSibling = void 0;
  };

  /*
  */


  Container.prototype.insertBefore = function(newElement, before) {
    var node, _i, _len, _ref;

    if (newElement.nodeType === 11) {
      _ref = newElement.childNodes.concat().reverse();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        this.insertBefore(node, before);
        before = node;
      }
      return;
    }
    return this._splice(this.childNodes.indexOf(before), 0, newElement);
  };

  /*
  */


  Container.prototype._splice = function(index, count, node) {
    var _ref;

    if (index == null) {
      index = -1;
    }
    if (!~index) {
      return;
    }
    if (node) {
      this._unlink(node);
    }
    (_ref = this.childNodes).splice.apply(_ref, arguments);
    if (node) {
      return this._link(node);
    }
  };

  /*
  */


  Container.prototype._unlink = function(node) {
    if (node.parentNode) {
      return node.parentNode.removeChild(node);
    }
  };

  /*
  */


  Container.prototype._link = function(node) {
    var i, _ref, _ref1;

    if (!node.__isNode) {
      throw new Error("cannot append non-node");
    }
    node.parentNode = this;
    i = this.childNodes.indexOf(node);
    node.previousSibling = i !== 0 ? this.childNodes[i - 1] : void 0;
    node.nextSibling = i !== this.childNodes.length - 1 ? this.childNodes[i + 1] : void 0;
    if ((_ref = node.previousSibling) != null) {
      _ref.nextSibling = node;
    }
    return (_ref1 = node.nextSibling) != null ? _ref1.previousSibling = node : void 0;
  };

  return Container;

})(Node);

Style = (function() {
  /*
  */
  Style.prototype._hasStyle = false;

  /*
  */


  function Style() {}

  /*
  */


  Style.prototype.setProperty = function(key, value) {
    if (value == null) {
      value = "";
    }
    if (value === "") {
      delete this[key];
      return;
    }
    return this[key] = value;
  };

  /*
  */


  Style.prototype.parse = function(styles) {
    var sp, style, _i, _len, _ref, _results;

    _ref = styles.split(/;\s*/);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      style = _ref[_i];
      sp = style.split(/:\s*/);
      if ((sp[1] == null) || sp[1] === "") {
        continue;
      }
      _results.push(this[sp[0]] = sp[1]);
    }
    return _results;
  };

  /*
  */


  Style.prototype.toString = function() {
    var buffer, key, v;

    buffer = [];
    for (key in this) {
      if (this.constructor.prototype[key] != null) {
        continue;
      }
      v = this[key];
      if (v === "") {
        continue;
      }
      buffer.push("" + key + ": " + this[key]);
    }
    if (!buffer.length) {
      return "";
    }
    return buffer.join("; ") + ";";
  };

  /*
  */


  Style.prototype.hasStyles = function() {
    var key;

    if (this._hasStyle) {
      return true;
    }
    for (key in this) {
      if ((this[key] != null) && (this.constructor.prototype[key] == null)) {
        return (this._hasStyle = true);
      }
    }
    return false;
  };

  return Style;

})();

Element = (function(_super) {
  __extends(Element, _super);

  /*
  */


  Element.prototype.nodeType = 3;

  /*
  */


  function Element(nodeName) {
    Element.__super__.constructor.call(this);
    this.nodeName = nodeName.toUpperCase();
    this._name = nodeName.toLowerCase(0);
    this.attributes = [];
    this._attrsByKey = {};
    this.style = new Style();
  }

  /*
  */


  Element.prototype.setAttribute = function(name, value) {
    var abk;

    name = name.toLowerCase();
    if (name === "style") {
      return this.style.parse(value);
    }
    if (value === void 0) {
      return this.removeAttribute(name);
    }
    if (!(abk = this._attrsByKey[name])) {
      this.attributes.push(abk = this._attrsByKey[name] = {});
    }
    abk.name = name;
    return abk.value = value;
  };

  /*
  */


  Element.prototype.removeAttribute = function(name) {
    var attr, i, _i, _len, _ref;

    _ref = this.attributes;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      attr = _ref[i];
      if (attr.name === name) {
        this.attributes.splice(i, 1);
        break;
      }
    }
    return delete this._attrsByKey[name];
  };

  /*
  */


  Element.prototype.getAttribute = function(name) {
    var _ref;

    return (_ref = this._attrsByKey[name]) != null ? _ref.value : void 0;
  };

  /*
  */


  Element.prototype.toString = function() {
    var attrbuff, attribs, buffer, name, v;

    buffer = ["<", this._name];
    attribs = [];
    for (name in this._attrsByKey) {
      v = this._attrsByKey[name].value;
      attrbuff = name;
      if (v != null) {
        attrbuff += "=\"" + v + "\"";
      }
      attribs.push(attrbuff);
    }
    if (this.style.hasStyles()) {
      attribs.push("style=\"" + (this.style.toString()) + "\"");
    }
    if (attribs.length) {
      buffer.push(" ", attribs.join(" "));
    }
    buffer.push(">");
    buffer.push.apply(buffer, this.childNodes);
    buffer.push("</", this._name, ">");
    return buffer.join("");
  };

  return Element;

})(Container);

Text = (function(_super) {
  __extends(Text, _super);

  /*
  */


  Text.prototype.nodeType = 3;

  /*
  */


  function Text(value) {
    this.value = ent(value);
  }

  /*
  */


  Text.prototype.toString = function() {
    return this.value;
  };

  return Text;

})(Node);

Comment = (function(_super) {
  __extends(Comment, _super);

  function Comment() {
    _ref = Comment.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  Comment.prototype.nodeType = 8;

  /*
  */


  Comment.prototype.toString = function() {
    return "<!--" + (Comment.__super__.toString.call(this)) + "-->";
  };

  return Comment;

})(Text);

Fragment = (function(_super) {
  __extends(Fragment, _super);

  function Fragment() {
    _ref1 = Fragment.__super__.constructor.apply(this, arguments);
    return _ref1;
  }

  /*
  */


  Fragment.prototype.nodeType = 11;

  /*
  */


  Fragment.prototype.toString = function() {
    return this.childNodes.join("");
  };

  return Fragment;

})(Container);

StringNodeFactory = (function(_super) {
  __extends(StringNodeFactory, _super);

  /*
  */


  StringNodeFactory.prototype.name = "string";

  /*
  */


  function StringNodeFactory(context) {
    this.context = context;
    this.internal = new bindable.Object();
  }

  /*
  */


  StringNodeFactory.prototype.createElement = function(name) {
    return new Element(name);
  };

  /*
  */


  StringNodeFactory.prototype.createTextNode = function(text) {
    return new Text(text);
  };

  /*
  */


  StringNodeFactory.prototype.createComment = function(text) {
    return new Comment(text);
  };

  /*
  */


  StringNodeFactory.prototype.createFragment = function(children) {
    var child, frag, _i, _len;

    if (children == null) {
      children = [];
    }
    frag = new Fragment();
    for (_i = 0, _len = children.length; _i < _len; _i++) {
      child = children[_i];
      frag.appendChild(child);
    }
    return frag;
  };

  /*
  */


  StringNodeFactory.prototype.parseHtml = function(buffer) {
    return this.createTextNode(buffer);
  };

  return StringNodeFactory;

})(require("./base"));

module.exports = new StringNodeFactory();

},{"./base":108,"./ent":110,"bindable":84}],113:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var BaseFactory;

BaseFactory = (function() {
  function BaseFactory() {}

  /*
  */


  BaseFactory.prototype.createElement = function(element) {};

  /*
  */


  BaseFactory.prototype.createFragment = function() {};

  /*
  */


  BaseFactory.prototype.createComment = function(text) {};

  /*
  */


  BaseFactory.prototype.createTextNode = function(text) {};

  /*
  */


  BaseFactory.prototype.parseHtml = function(content) {};

  return BaseFactory;

})();

},{}],114:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var DomFactory,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

DomFactory = (function(_super) {
  __extends(DomFactory, _super);

  /*
  */


  DomFactory.prototype.name = "dom";

  /*
  */


  function DomFactory() {}

  /*
  */


  DomFactory.prototype.createElement = function(name) {
    return document.createElement(name);
  };

  /*
  */


  DomFactory.prototype.createTextNode = function(text) {
    return document.createTextNode(text);
  };

  /*
  */


  DomFactory.prototype.createFragment = function(children) {
    var child, frag, _i, _len;

    if (children == null) {
      children = [];
    }
    frag = document.createDocumentFragment();
    for (_i = 0, _len = children.length; _i < _len; _i++) {
      child = children[_i];
      frag.appendChild(child);
    }
    return frag;
  };

  /*
  */


  DomFactory.prototype.parseHtml = function(text) {
    var div;

    div = this.createElement("div");
    div.innerHTML = text;
    return this.createFragment.apply(this, div.childNodes);
  };

  return DomFactory;

})(require("./base"));

module.exports = new DomFactory();

},{"./base":113}],115:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var entities;

entities = {
  "<": "lt",
  "&": "amp",
  ">": "gt",
  "\"": "quote"
};

module.exports = function(str) {
  str = String(str);
  return str.split('').map(function(c) {
    var cc, e;

    e = entities[c];
    cc = c.charCodeAt(0);
    if (e) {
      return "&" + e + ";";
    } else if (c.match(/\s/)) {
      return c;
    } else if (cc < 32 || cc > 126) {
      return "&#" + cc + ";";
    }
    return c;
  }).join('');
};

},{}],116:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
module.exports = {
  string: require("./string"),
  dom: require("./dom")
};

module.exports["default"] = typeof window !== "undefined" ? module.exports.dom : module.exports.string;

},{"./dom":114,"./string":117}],117:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var Comment, Container, Element, Fragment, Node, StringNodeFactory, Style, Text, bindable, ent, _ref, _ref1,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

bindable = require("bindable");

ent = require("./ent");

Node = (function() {
  function Node() {}

  Node.prototype.__isNode = true;

  return Node;

})();

Container = (function(_super) {
  __extends(Container, _super);

  /*
  */


  function Container() {
    this.childNodes = [];
  }

  /*
  */


  Container.prototype.appendChild = function(node) {
    var child, _i, _len, _ref;

    if (node.nodeType === 11) {
      _ref = node.childNodes.concat();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        this.appendChild(child);
      }
      return;
    }
    this._unlink(node);
    this.childNodes.push(node);
    return this._link(node);
  };

  /*
  */


  Container.prototype.removeChild = function(child) {
    var i, _ref, _ref1;

    i = this.childNodes.indexOf(child);
    if (!~i) {
      return;
    }
    this.childNodes.splice(i, 1);
    if ((_ref = child.previousSibling) != null) {
      _ref.nextSibling = child.nextSibling;
    }
    if ((_ref1 = child.nextSibling) != null) {
      _ref1.previousSibling = child.previousSibling;
    }
    return child.parentNode = child.nextSibling = child.previousSibling = void 0;
  };

  /*
  */


  Container.prototype.insertBefore = function(newElement, before) {
    var node, _i, _len, _ref;

    if (newElement.nodeType === 11) {
      _ref = newElement.childNodes.concat().reverse();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        this.insertBefore(node, before);
        before = node;
      }
      return;
    }
    return this._splice(this.childNodes.indexOf(before), 0, newElement);
  };

  /*
  */


  Container.prototype._splice = function(index, count, node) {
    var _ref;

    if (index == null) {
      index = -1;
    }
    if (!~index) {
      return;
    }
    if (node) {
      this._unlink(node);
    }
    (_ref = this.childNodes).splice.apply(_ref, arguments);
    if (node) {
      return this._link(node);
    }
  };

  /*
  */


  Container.prototype._unlink = function(node) {
    if (node.parentNode) {
      return node.parentNode.removeChild(node);
    }
  };

  /*
  */


  Container.prototype._link = function(node) {
    var i, _ref, _ref1;

    if (!node.__isNode) {
      throw new Error("cannot append non-node");
    }
    node.parentNode = this;
    i = this.childNodes.indexOf(node);
    node.previousSibling = i !== 0 ? this.childNodes[i - 1] : void 0;
    node.nextSibling = i !== this.childNodes.length - 1 ? this.childNodes[i + 1] : void 0;
    if ((_ref = node.previousSibling) != null) {
      _ref.nextSibling = node;
    }
    return (_ref1 = node.nextSibling) != null ? _ref1.previousSibling = node : void 0;
  };

  return Container;

})(Node);

Style = (function() {
  /*
  */
  Style.prototype._hasStyle = false;

  /*
  */


  function Style() {}

  /*
  */


  Style.prototype.setProperty = function(key, value) {
    if (value == null) {
      value = "";
    }
    if (value === "") {
      delete this[key];
      return;
    }
    return this[key] = value;
  };

  /*
  */


  Style.prototype.parse = function(styles) {
    var sp, style, _i, _len, _ref, _results;

    _ref = styles.split(/;\s*/);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      style = _ref[_i];
      sp = style.split(/:\s*/);
      if ((sp[1] == null) || sp[1] === "") {
        continue;
      }
      _results.push(this[sp[0]] = sp[1]);
    }
    return _results;
  };

  /*
  */


  Style.prototype.toString = function() {
    var buffer, key, v;

    buffer = [];
    for (key in this) {
      if (this.constructor.prototype[key] != null) {
        continue;
      }
      v = this[key];
      if (v === "") {
        continue;
      }
      buffer.push("" + key + ": " + this[key]);
    }
    if (!buffer.length) {
      return "";
    }
    return buffer.join("; ") + ";";
  };

  /*
  */


  Style.prototype.hasStyles = function() {
    var key;

    if (this._hasStyle) {
      return true;
    }
    for (key in this) {
      if ((this[key] != null) && (this.constructor.prototype[key] == null)) {
        return (this._hasStyle = true);
      }
    }
    return false;
  };

  return Style;

})();

Element = (function(_super) {
  __extends(Element, _super);

  /*
  */


  Element.prototype.nodeType = 3;

  /*
  */


  function Element(nodeName) {
    Element.__super__.constructor.call(this);
    this.nodeName = nodeName.toUpperCase();
    this._name = nodeName.toLowerCase(0);
    this.attributes = [];
    this._attrsByKey = {};
    this.style = new Style();
  }

  /*
  */


  Element.prototype.setAttribute = function(name, value) {
    var abk;

    name = name.toLowerCase();
    if (name === "style") {
      return this.style.parse(value);
    }
    if (value === void 0) {
      return this.removeAttribute(name);
    }
    if (!(abk = this._attrsByKey[name])) {
      this.attributes.push(abk = this._attrsByKey[name] = {});
    }
    abk.name = name;
    return abk.value = value;
  };

  /*
  */


  Element.prototype.removeAttribute = function(name) {
    var attr, i, _i, _len, _ref;

    _ref = this.attributes;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      attr = _ref[i];
      if (attr.name === name) {
        this.attributes.splice(i, 1);
        break;
      }
    }
    return delete this._attrsByKey[name];
  };

  /*
  */


  Element.prototype.getAttribute = function(name) {
    var _ref;

    return (_ref = this._attrsByKey[name]) != null ? _ref.value : void 0;
  };

  /*
  */


  Element.prototype.toString = function() {
    var attrbuff, attribs, buffer, name, v;

    buffer = ["<", this._name];
    attribs = [];
    for (name in this._attrsByKey) {
      v = this._attrsByKey[name].value;
      attrbuff = name;
      if (v != null) {
        attrbuff += "=\"" + v + "\"";
      }
      attribs.push(attrbuff);
    }
    if (this.style.hasStyles()) {
      attribs.push("style=\"" + (this.style.toString()) + "\"");
    }
    if (attribs.length) {
      buffer.push(" ", attribs.join(" "));
    }
    buffer.push(">");
    buffer.push.apply(buffer, this.childNodes);
    buffer.push("</", this._name, ">");
    return buffer.join("");
  };

  return Element;

})(Container);

Text = (function(_super) {
  __extends(Text, _super);

  /*
  */


  Text.prototype.nodeType = 3;

  /*
  */


  function Text(value) {
    this.value = ent(value);
  }

  /*
  */


  Text.prototype.toString = function() {
    return this.value;
  };

  return Text;

})(Node);

Comment = (function(_super) {
  __extends(Comment, _super);

  function Comment() {
    _ref = Comment.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  Comment.prototype.nodeType = 8;

  /*
  */


  Comment.prototype.toString = function() {
    return "<!--" + (Comment.__super__.toString.call(this)) + "-->";
  };

  return Comment;

})(Text);

Fragment = (function(_super) {
  __extends(Fragment, _super);

  function Fragment() {
    _ref1 = Fragment.__super__.constructor.apply(this, arguments);
    return _ref1;
  }

  /*
  */


  Fragment.prototype.nodeType = 11;

  /*
  */


  Fragment.prototype.toString = function() {
    return this.childNodes.join("");
  };

  return Fragment;

})(Container);

StringNodeFactory = (function(_super) {
  __extends(StringNodeFactory, _super);

  /*
  */


  StringNodeFactory.prototype.name = "string";

  /*
  */


  function StringNodeFactory(context) {
    this.context = context;
    this.internal = new bindable.Object();
  }

  /*
  */


  StringNodeFactory.prototype.createElement = function(name) {
    return new Element(name);
  };

  /*
  */


  StringNodeFactory.prototype.createTextNode = function(text) {
    return new Text(text);
  };

  /*
  */


  StringNodeFactory.prototype.createComment = function(text) {
    return new Comment(text);
  };

  /*
  */


  StringNodeFactory.prototype.createFragment = function(children) {
    var child, frag, _i, _len;

    if (children == null) {
      children = [];
    }
    frag = new Fragment();
    for (_i = 0, _len = children.length; _i < _len; _i++) {
      child = children[_i];
      frag.appendChild(child);
    }
    return frag;
  };

  /*
  */


  StringNodeFactory.prototype.parseHtml = function(buffer) {
    return this.createTextNode(buffer);
  };

  return StringNodeFactory;

})(require("./base"));

module.exports = new StringNodeFactory();

},{"./base":113,"./ent":115,"bindable":84}],118:[function(require,module,exports){

module.exports = function(source, options) {

	if(!options) {
		options = {
			skipWhitespace: true
		}
	}


	var _cchar = "",
	_ccode     = 0,
	_pos       = 0,
	_len       = 0,
	_src       = source;


	var self = {

		/**
		 * sets the source
		 */

		source: function(value) {
			_src = value;
			_len = value.length;
			self.pos(0);
		},
		
		/**
		 */

		skipWhitespace: function(value) {
			if(!arguments.length) {
				return options.skipWhitespace;
			}
			options.skipWhitespace = value;
		},

		/**
		 * true if the scanner cannot continue
		 */


		eof: function() {
			return _pos >= _len;
		},

		/**
		 */

		pos: function(value) {
			if(!arguments.length) return _pos;
			_pos = value;
			_cchar = _src.charAt(value);
			_ccode = _cchar.charCodeAt(0);
			self.skipWs();
		},

		/**
		 */

		skip: function(count) {
			return self.pos(Math.min(_pos + count, _len))
		},


		/**
		 */

		rewind: function(count) {
			_pos = Math.max(_pos - count || 1, 0);
			return _pos;
		},

		/**
		 */

		peek: function(count) {
			return _src.substr(_pos, count || 1);
		},

		/**
		 */

		nextChar: function() {
			self.pos(_pos + 1);
			self.skipWs();

			return _cchar;
		},

		/**
		 */

		skipWs: function() {
			if(options.skipWhitespace) {
				if(self.isWs()) {
					self.nextChar();
				}
			}
		},

		/**
		 */

		cchar: function() {
			return _cchar;
		},

		/**
		 */

		ccode: function() {
			return _ccode;
		},

		/**
		 */

		isAZ: function() {
			return (_ccode > 64 && _ccode < 91) || (_ccode > 96 && _ccode < 123);
		},

		/**
		 */

		is09: function() {
			return _ccode > 47 && _ccode < 58;
		},

		/**
		 */

		isWs: function() {
			//\t \n \r \s
			return _ccode === 9 || _ccode === 10 || _ccode === 13 || _ccode === 32;
		},

		/**
		 */

		isAlpha: function() {
			return self.isAZ() || self.is09();
		},

		/**
		 */

		matches: function(search) {
			return !!_src.substr(_pos).match(search);
		},

		/**
		 */

		next: function(search) {
			var buffer = _src.substr(_pos),
			match      = buffer.match(search);
			_pos += match.index + Math.max(0, match[0].length - 1);
			return match[0];
		},

		/**
		 */

		nextWord: function() {
			if(self.isAZ()) return self.next(/[a-zA-Z]+/);
		},

		/**
		 */

		nextNumber: function() {
			if(self.is09()) return self.next(/[0-9]+/);
		},

		/**
		 */

		nextAlpha: function() {
			if(self.isAlpha()) return self.next(/[a-zA-Z0-9]+/);
		},

		/**
		 */

		nextNonAlpha: function() {
			if(!self.isAlpha()) return self.next(/[^a-zA-Z0-9]+/);
		},

		/**
		 */

		nextWs: function() {
			if(self.isWs()) return self.next(/[\s\r\n\t]+/);
		},

		/**
		 */

		nextUntil: function(match) {
			var buffer = "";
			while(!self.eof() && !_cchar.match(match)) {
				buffer += _cchar;
				self.nextChar();
			}
			return buffer;
		},


		/**
		 */

		to: function(count) {
			var buffer = _src.substr(_pos, count);
			_pos += count;
			return buffer;
		}

	}


	//initialize
	self.source(source);


	return self;
}
},{}],119:[function(require,module,exports){

/**
 * toString ref.
 */

var toString = Object.prototype.toString;

/**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Function]': return 'function';
    case '[object Date]': return 'date';
    case '[object RegExp]': return 'regexp';
    case '[object Arguments]': return 'arguments';
    case '[object Array]': return 'array';
  }

  if (val === null) return 'null';
  if (val === undefined) return 'undefined';
  if (val === Object(val)) return 'object';

  return typeof val;
};

},{}],120:[function(require,module,exports){
(function(){/**
 * @preserve Copyright 2012 Robert Gust-Bardon <http://robert.gust-bardon.org/>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *     * Redistributions of source code must retain the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/**
 * @fileoverview Enhances <a href="https://github.com/mishoo/UglifyJS/"
 * >UglifyJS</a> with consolidation of null, Boolean, and String values.
 * <p>Also known as aliasing, this feature has been deprecated in <a href=
 * "http://closure-compiler.googlecode.com/">the Closure Compiler</a> since its
 * initial release, where it is unavailable from the <abbr title=
 * "command line interface">CLI</a>. The Closure Compiler allows one to log and
 * influence this process. In contrast, this implementation does not introduce
 * any variable declarations in global code and derives String values from
 * identifier names used as property accessors.</p>
 * <p>Consolidating literals may worsen the data compression ratio when an <a
 * href="http://tools.ietf.org/html/rfc2616#section-3.5">encoding
 * transformation</a> is applied. For instance, <a href=
 * "http://code.jquery.com/jquery-1.7.1.js">jQuery 1.7.1</a> takes 248235 bytes.
 * Building it with <a href="https://github.com/mishoo/UglifyJS/tarball/v1.2.5">
 * UglifyJS v1.2.5</a> results in 93647 bytes (37.73% of the original) which are
 * then compressed to 33154 bytes (13.36% of the original) using <a href=
 * "http://linux.die.net/man/1/gzip">gzip(1)</a>. Building it with the same
 * version of UglifyJS 1.2.5 patched with the implementation of consolidation
 * results in 80784 bytes (a decrease of 12863 bytes, i.e. 13.74%, in comparison
 * to the aforementioned 93647 bytes) which are then compressed to 34013 bytes
 * (an increase of 859 bytes, i.e. 2.59%, in comparison to the aforementioned
 * 33154 bytes).</p>
 * <p>Written in <a href="http://es5.github.com/#x4.2.2">the strict variant</a>
 * of <a href="http://es5.github.com/">ECMA-262 5.1 Edition</a>. Encoded in <a
 * href="http://tools.ietf.org/html/rfc3629">UTF-8</a>. Follows <a href=
 * "http://google-styleguide.googlecode.com/svn-history/r76/trunk/javascriptguide.xml"
 * >Revision 2.28 of the Google JavaScript Style Guide</a> (except for the
 * discouraged use of the {@code function} tag and the {@code namespace} tag).
 * 100% typed for the <a href=
 * "http://closure-compiler.googlecode.com/files/compiler-20120123.tar.gz"
 * >Closure Compiler Version 1741</a>.</p>
 * <p>Should you find this software useful, please consider <a href=
 * "https://paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=JZLW72X8FD4WG"
 * >a donation</a>.</p>
 * @author follow.me@RGustBardon (Robert Gust-Bardon)
 * @supported Tested with:
 *     <ul>
 *     <li><a href="http://nodejs.org/dist/v0.6.10/">Node v0.6.10</a>,</li>
 *     <li><a href="https://github.com/mishoo/UglifyJS/tarball/v1.2.5">UglifyJS
 *       v1.2.5</a>.</li>
 *     </ul>
 */

/*global console:false, exports:true, module:false, require:false */
/*jshint sub:true */
/**
 * Consolidates null, Boolean, and String values found inside an <abbr title=
 * "abstract syntax tree">AST</abbr>.
 * @param {!TSyntacticCodeUnit} oAbstractSyntaxTree An array-like object
 *     representing an <abbr title="abstract syntax tree">AST</abbr>.
 * @return {!TSyntacticCodeUnit} An array-like object representing an <abbr
 *     title="abstract syntax tree">AST</abbr> with its null, Boolean, and
 *     String values consolidated.
 */
// TODO(user) Consolidation of mathematical values found in numeric literals.
// TODO(user) Unconsolidation.
// TODO(user) Consolidation of ECMA-262 6th Edition programs.
// TODO(user) Rewrite in ECMA-262 6th Edition.
exports['ast_consolidate'] = function(oAbstractSyntaxTree) {
  'use strict';
  /*jshint bitwise:true, curly:true, eqeqeq:true, forin:true, immed:true,
        latedef:true, newcap:true, noarge:true, noempty:true, nonew:true,
        onevar:true, plusplus:true, regexp:true, undef:true, strict:true,
        sub:false, trailing:true */

  var _,
      /**
       * A record consisting of data about one or more source elements.
       * @constructor
       * @nosideeffects
       */
      TSourceElementsData = function() {
        /**
         * The category of the elements.
         * @type {number}
         * @see ESourceElementCategories
         */
        this.nCategory = ESourceElementCategories.N_OTHER;
        /**
         * The number of occurrences (within the elements) of each primitive
         * value that could be consolidated.
         * @type {!Array.<!Object.<string, number>>}
         */
        this.aCount = [];
        this.aCount[EPrimaryExpressionCategories.N_IDENTIFIER_NAMES] = {};
        this.aCount[EPrimaryExpressionCategories.N_STRING_LITERALS] = {};
        this.aCount[EPrimaryExpressionCategories.N_NULL_AND_BOOLEAN_LITERALS] =
            {};
        /**
         * Identifier names found within the elements.
         * @type {!Array.<string>}
         */
        this.aIdentifiers = [];
        /**
         * Prefixed representation Strings of each primitive value that could be
         * consolidated within the elements.
         * @type {!Array.<string>}
         */
        this.aPrimitiveValues = [];
      },
      /**
       * A record consisting of data about a primitive value that could be
       * consolidated.
       * @constructor
       * @nosideeffects
       */
      TPrimitiveValue = function() {
        /**
         * The difference in the number of terminal symbols between the original
         * source text and the one with the primitive value consolidated. If the
         * difference is positive, the primitive value is considered worthwhile.
         * @type {number}
         */
        this.nSaving = 0;
        /**
         * An identifier name of the variable that will be declared and assigned
         * the primitive value if the primitive value is consolidated.
         * @type {string}
         */
        this.sName = '';
      },
      /**
       * A record consisting of data on what to consolidate within the range of
       * source elements that is currently being considered.
       * @constructor
       * @nosideeffects
       */
      TSolution = function() {
        /**
         * An object whose keys are prefixed representation Strings of each
         * primitive value that could be consolidated within the elements and
         * whose values are corresponding data about those primitive values.
         * @type {!Object.<string, {nSaving: number, sName: string}>}
         * @see TPrimitiveValue
         */
        this.oPrimitiveValues = {};
        /**
         * The difference in the number of terminal symbols between the original
         * source text and the one with all the worthwhile primitive values
         * consolidated.
         * @type {number}
         * @see TPrimitiveValue#nSaving
         */
        this.nSavings = 0;
      },
      /**
       * The processor of <abbr title="abstract syntax tree">AST</abbr>s found
       * in UglifyJS.
       * @namespace
       * @type {!TProcessor}
       */
      oProcessor = (/** @type {!TProcessor} */ require('./process')),
      /**
       * A record consisting of a number of constants that represent the
       * difference in the number of terminal symbols between a source text with
       * a modified syntactic code unit and the original one.
       * @namespace
       * @type {!Object.<string, number>}
       */
      oWeights = {
        /**
         * The difference in the number of punctuators required by the bracket
         * notation and the dot notation.
         * <p><code>'[]'.length - '.'.length</code></p>
         * @const
         * @type {number}
         */
        N_PROPERTY_ACCESSOR: 1,
        /**
         * The number of punctuators required by a variable declaration with an
         * initialiser.
         * <p><code>':'.length + ';'.length</code></p>
         * @const
         * @type {number}
         */
        N_VARIABLE_DECLARATION: 2,
        /**
         * The number of terminal symbols required to introduce a variable
         * statement (excluding its variable declaration list).
         * <p><code>'var '.length</code></p>
         * @const
         * @type {number}
         */
        N_VARIABLE_STATEMENT_AFFIXATION: 4,
        /**
         * The number of terminal symbols needed to enclose source elements
         * within a function call with no argument values to a function with an
         * empty parameter list.
         * <p><code>'(function(){}());'.length</code></p>
         * @const
         * @type {number}
         */
        N_CLOSURE: 17
      },
      /**
       * Categories of primary expressions from which primitive values that
       * could be consolidated are derivable.
       * @namespace
       * @enum {number}
       */
      EPrimaryExpressionCategories = {
        /**
         * Identifier names used as property accessors.
         * @type {number}
         */
        N_IDENTIFIER_NAMES: 0,
        /**
         * String literals.
         * @type {number}
         */
        N_STRING_LITERALS: 1,
        /**
         * Null and Boolean literals.
         * @type {number}
         */
        N_NULL_AND_BOOLEAN_LITERALS: 2
      },
      /**
       * Prefixes of primitive values that could be consolidated.
       * The String values of the prefixes must have same number of characters.
       * The prefixes must not be used in any properties defined in any version
       * of <a href=
       * "http://www.ecma-international.org/publications/standards/Ecma-262.htm"
       * >ECMA-262</a>.
       * @namespace
       * @enum {string}
       */
      EValuePrefixes = {
        /**
         * Identifies String values.
         * @type {string}
         */
        S_STRING: '#S',
        /**
         * Identifies null and Boolean values.
         * @type {string}
         */
        S_SYMBOLIC: '#O'
      },
      /**
       * Categories of source elements in terms of their appropriateness of
       * having their primitive values consolidated.
       * @namespace
       * @enum {number}
       */
      ESourceElementCategories = {
        /**
         * Identifies a source element that includes the <a href=
         * "http://es5.github.com/#x12.10">{@code with}</a> statement.
         * @type {number}
         */
        N_WITH: 0,
        /**
         * Identifies a source element that includes the <a href=
         * "http://es5.github.com/#x15.1.2.1">{@code eval}</a> identifier name.
         * @type {number}
         */
        N_EVAL: 1,
        /**
         * Identifies a source element that must be excluded from the process
         * unless its whole scope is examined.
         * @type {number}
         */
        N_EXCLUDABLE: 2,
        /**
         * Identifies source elements not posing any problems.
         * @type {number}
         */
        N_OTHER: 3
      },
      /**
       * The list of literals (other than the String ones) whose primitive
       * values can be consolidated.
       * @const
       * @type {!Array.<string>}
       */
      A_OTHER_SUBSTITUTABLE_LITERALS = [
        'null',   // The null literal.
        'false',  // The Boolean literal {@code false}.
        'true'    // The Boolean literal {@code true}.
      ];

  (/**
    * Consolidates all worthwhile primitive values in a syntactic code unit.
    * @param {!TSyntacticCodeUnit} oSyntacticCodeUnit An array-like object
    *     representing the branch of the abstract syntax tree representing the
    *     syntactic code unit along with its scope.
    * @see TPrimitiveValue#nSaving
    */
   function fExamineSyntacticCodeUnit(oSyntacticCodeUnit) {
     var _,
         /**
          * Indicates whether the syntactic code unit represents global code.
          * @type {boolean}
          */
         bIsGlobal = 'toplevel' === oSyntacticCodeUnit[0],
         /**
          * Indicates whether the whole scope is being examined.
          * @type {boolean}
          */
         bIsWhollyExaminable = !bIsGlobal,
         /**
          * An array-like object representing source elements that constitute a
          * syntactic code unit.
          * @type {!TSyntacticCodeUnit}
          */
         oSourceElements,
         /**
          * A record consisting of data about the source element that is
          * currently being examined.
          * @type {!TSourceElementsData}
          */
         oSourceElementData,
         /**
          * The scope of the syntactic code unit.
          * @type {!TScope}
          */
         oScope,
         /**
          * An instance of an object that allows the traversal of an <abbr
          * title="abstract syntax tree">AST</abbr>.
          * @type {!TWalker}
          */
         oWalker,
         /**
          * An object encompassing collections of functions used during the
          * traversal of an <abbr title="abstract syntax tree">AST</abbr>.
          * @namespace
          * @type {!Object.<string, !Object.<string, function(...[*])>>}
          */
         oWalkers = {
           /**
            * A collection of functions used during the surveyance of source
            * elements.
            * @namespace
            * @type {!Object.<string, function(...[*])>}
            */
           oSurveySourceElement: {
             /**#nocode+*/  // JsDoc Toolkit 2.4.0 hides some of the keys.
             /**
              * Classifies the source element as excludable if it does not
              * contain a {@code with} statement or the {@code eval} identifier
              * name. Adds the identifier of the function and its formal
              * parameters to the list of identifier names found.
              * @param {string} sIdentifier The identifier of the function.
              * @param {!Array.<string>} aFormalParameterList Formal parameters.
              * @param {!TSyntacticCodeUnit} oFunctionBody Function code.
              */
             'defun': function(
                 sIdentifier,
                 aFormalParameterList,
                 oFunctionBody) {
               fClassifyAsExcludable();
               fAddIdentifier(sIdentifier);
               aFormalParameterList.forEach(fAddIdentifier);
             },
             /**
              * Increments the count of the number of occurrences of the String
              * value that is equivalent to the sequence of terminal symbols
              * that constitute the encountered identifier name.
              * @param {!TSyntacticCodeUnit} oExpression The nonterminal
              *     MemberExpression.
              * @param {string} sIdentifierName The identifier name used as the
              *     property accessor.
              * @return {!Array} The encountered branch of an <abbr title=
              *     "abstract syntax tree">AST</abbr> with its nonterminal
              *     MemberExpression traversed.
              */
             'dot': function(oExpression, sIdentifierName) {
               fCountPrimaryExpression(
                   EPrimaryExpressionCategories.N_IDENTIFIER_NAMES,
                   EValuePrefixes.S_STRING + sIdentifierName);
               return ['dot', oWalker.walk(oExpression), sIdentifierName];
             },
             /**
              * Adds the optional identifier of the function and its formal
              * parameters to the list of identifier names found.
              * @param {?string} sIdentifier The optional identifier of the
              *     function.
              * @param {!Array.<string>} aFormalParameterList Formal parameters.
              * @param {!TSyntacticCodeUnit} oFunctionBody Function code.
              */
             'function': function(
                 sIdentifier,
                 aFormalParameterList,
                 oFunctionBody) {
               if ('string' === typeof sIdentifier) {
                 fAddIdentifier(sIdentifier);
               }
               aFormalParameterList.forEach(fAddIdentifier);
             },
             /**
              * Either increments the count of the number of occurrences of the
              * encountered null or Boolean value or classifies a source element
              * as containing the {@code eval} identifier name.
              * @param {string} sIdentifier The identifier encountered.
              */
             'name': function(sIdentifier) {
               if (-1 !== A_OTHER_SUBSTITUTABLE_LITERALS.indexOf(sIdentifier)) {
                 fCountPrimaryExpression(
                     EPrimaryExpressionCategories.N_NULL_AND_BOOLEAN_LITERALS,
                     EValuePrefixes.S_SYMBOLIC + sIdentifier);
               } else {
                 if ('eval' === sIdentifier) {
                   oSourceElementData.nCategory =
                       ESourceElementCategories.N_EVAL;
                 }
                 fAddIdentifier(sIdentifier);
               }
             },
             /**
              * Classifies the source element as excludable if it does not
              * contain a {@code with} statement or the {@code eval} identifier
              * name.
              * @param {TSyntacticCodeUnit} oExpression The expression whose
              *     value is to be returned.
              */
             'return': function(oExpression) {
               fClassifyAsExcludable();
             },
             /**
              * Increments the count of the number of occurrences of the
              * encountered String value.
              * @param {string} sStringValue The String value of the string
              *     literal encountered.
              */
             'string': function(sStringValue) {
               if (sStringValue.length > 0) {
                 fCountPrimaryExpression(
                     EPrimaryExpressionCategories.N_STRING_LITERALS,
                     EValuePrefixes.S_STRING + sStringValue);
               }
             },
             /**
              * Adds the identifier reserved for an exception to the list of
              * identifier names found.
              * @param {!TSyntacticCodeUnit} oTry A block of code in which an
              *     exception can occur.
              * @param {Array} aCatch The identifier reserved for an exception
              *     and a block of code to handle the exception.
              * @param {TSyntacticCodeUnit} oFinally An optional block of code
              *     to be evaluated regardless of whether an exception occurs.
              */
             'try': function(oTry, aCatch, oFinally) {
               if (Array.isArray(aCatch)) {
                 fAddIdentifier(aCatch[0]);
               }
             },
             /**
              * Classifies the source element as excludable if it does not
              * contain a {@code with} statement or the {@code eval} identifier
              * name. Adds the identifier of each declared variable to the list
              * of identifier names found.
              * @param {!Array.<!Array>} aVariableDeclarationList Variable
              *     declarations.
              */
             'var': function(aVariableDeclarationList) {
               fClassifyAsExcludable();
               aVariableDeclarationList.forEach(fAddVariable);
             },
             /**
              * Classifies a source element as containing the {@code with}
              * statement.
              * @param {!TSyntacticCodeUnit} oExpression An expression whose
              *     value is to be converted to a value of type Object and
              *     become the binding object of a new object environment
              *     record of a new lexical environment in which the statement
              *     is to be executed.
              * @param {!TSyntacticCodeUnit} oStatement The statement to be
              *     executed in the augmented lexical environment.
              * @return {!Array} An empty array to stop the traversal.
              */
             'with': function(oExpression, oStatement) {
               oSourceElementData.nCategory = ESourceElementCategories.N_WITH;
               return [];
             }
             /**#nocode-*/  // JsDoc Toolkit 2.4.0 hides some of the keys.
           },
           /**
            * A collection of functions used while looking for nested functions.
            * @namespace
            * @type {!Object.<string, function(...[*])>}
            */
           oExamineFunctions: {
             /**#nocode+*/  // JsDoc Toolkit 2.4.0 hides some of the keys.
             /**
              * Orders an examination of a nested function declaration.
              * @this {!TSyntacticCodeUnit} An array-like object representing
              *     the branch of an <abbr title="abstract syntax tree"
              *     >AST</abbr> representing the syntactic code unit along with
              *     its scope.
              * @return {!Array} An empty array to stop the traversal.
              */
             'defun': function() {
               fExamineSyntacticCodeUnit(this);
               return [];
             },
             /**
              * Orders an examination of a nested function expression.
              * @this {!TSyntacticCodeUnit} An array-like object representing
              *     the branch of an <abbr title="abstract syntax tree"
              *     >AST</abbr> representing the syntactic code unit along with
              *     its scope.
              * @return {!Array} An empty array to stop the traversal.
              */
             'function': function() {
               fExamineSyntacticCodeUnit(this);
               return [];
             }
             /**#nocode-*/  // JsDoc Toolkit 2.4.0 hides some of the keys.
           }
         },
         /**
          * Records containing data about source elements.
          * @type {Array.<TSourceElementsData>}
          */
         aSourceElementsData = [],
         /**
          * The index (in the source text order) of the source element
          * immediately following a <a href="http://es5.github.com/#x14.1"
          * >Directive Prologue</a>.
          * @type {number}
          */
         nAfterDirectivePrologue = 0,
         /**
          * The index (in the source text order) of the source element that is
          * currently being considered.
          * @type {number}
          */
         nPosition,
         /**
          * The index (in the source text order) of the source element that is
          * the last element of the range of source elements that is currently
          * being considered.
          * @type {(undefined|number)}
          */
         nTo,
         /**
          * Initiates the traversal of a source element.
          * @param {!TWalker} oWalker An instance of an object that allows the
          *     traversal of an abstract syntax tree.
          * @param {!TSyntacticCodeUnit} oSourceElement A source element from
          *     which the traversal should commence.
          * @return {function(): !TSyntacticCodeUnit} A function that is able to
          *     initiate the traversal from a given source element.
          */
         cContext = function(oWalker, oSourceElement) {
           /**
            * @return {!TSyntacticCodeUnit} A function that is able to
            *     initiate the traversal from a given source element.
            */
           var fLambda = function() {
             return oWalker.walk(oSourceElement);
           };

           return fLambda;
         },
         /**
          * Classifies the source element as excludable if it does not
          * contain a {@code with} statement or the {@code eval} identifier
          * name.
          */
         fClassifyAsExcludable = function() {
           if (oSourceElementData.nCategory ===
               ESourceElementCategories.N_OTHER) {
             oSourceElementData.nCategory =
                 ESourceElementCategories.N_EXCLUDABLE;
           }
         },
         /**
          * Adds an identifier to the list of identifier names found.
          * @param {string} sIdentifier The identifier to be added.
          */
         fAddIdentifier = function(sIdentifier) {
           if (-1 === oSourceElementData.aIdentifiers.indexOf(sIdentifier)) {
             oSourceElementData.aIdentifiers.push(sIdentifier);
           }
         },
         /**
          * Adds the identifier of a variable to the list of identifier names
          * found.
          * @param {!Array} aVariableDeclaration A variable declaration.
          */
         fAddVariable = function(aVariableDeclaration) {
           fAddIdentifier(/** @type {string} */ aVariableDeclaration[0]);
         },
         /**
          * Increments the count of the number of occurrences of the prefixed
          * String representation attributed to the primary expression.
          * @param {number} nCategory The category of the primary expression.
          * @param {string} sName The prefixed String representation attributed
          *     to the primary expression.
          */
         fCountPrimaryExpression = function(nCategory, sName) {
           if (!oSourceElementData.aCount[nCategory].hasOwnProperty(sName)) {
             oSourceElementData.aCount[nCategory][sName] = 0;
             if (-1 === oSourceElementData.aPrimitiveValues.indexOf(sName)) {
               oSourceElementData.aPrimitiveValues.push(sName);
             }
           }
           oSourceElementData.aCount[nCategory][sName] += 1;
         },
         /**
          * Consolidates all worthwhile primitive values in a range of source
          *     elements.
          * @param {number} nFrom The index (in the source text order) of the
          *     source element that is the first element of the range.
          * @param {number} nTo The index (in the source text order) of the
          *     source element that is the last element of the range.
          * @param {boolean} bEnclose Indicates whether the range should be
          *     enclosed within a function call with no argument values to a
          *     function with an empty parameter list if any primitive values
          *     are consolidated.
          * @see TPrimitiveValue#nSaving
          */
         fExamineSourceElements = function(nFrom, nTo, bEnclose) {
           var _,
               /**
                * The index of the last mangled name.
                * @type {number}
                */
               nIndex = oScope.cname,
               /**
                * The index of the source element that is currently being
                * considered.
                * @type {number}
                */
               nPosition,
               /**
                * A collection of functions used during the consolidation of
                * primitive values and identifier names used as property
                * accessors.
                * @namespace
                * @type {!Object.<string, function(...[*])>}
                */
               oWalkersTransformers = {
                 /**
                  * If the String value that is equivalent to the sequence of
                  * terminal symbols that constitute the encountered identifier
                  * name is worthwhile, a syntactic conversion from the dot
                  * notation to the bracket notation ensues with that sequence
                  * being substituted by an identifier name to which the value
                  * is assigned.
                  * Applies to property accessors that use the dot notation.
                  * @param {!TSyntacticCodeUnit} oExpression The nonterminal
                  *     MemberExpression.
                  * @param {string} sIdentifierName The identifier name used as
                  *     the property accessor.
                  * @return {!Array} A syntactic code unit that is equivalent to
                  *     the one encountered.
                  * @see TPrimitiveValue#nSaving
                  */
                 'dot': function(oExpression, sIdentifierName) {
                   /**
                    * The prefixed String value that is equivalent to the
                    * sequence of terminal symbols that constitute the
                    * encountered identifier name.
                    * @type {string}
                    */
                   var sPrefixed = EValuePrefixes.S_STRING + sIdentifierName;

                   return oSolutionBest.oPrimitiveValues.hasOwnProperty(
                       sPrefixed) &&
                       oSolutionBest.oPrimitiveValues[sPrefixed].nSaving > 0 ?
                       ['sub',
                        oWalker.walk(oExpression),
                        ['name',
                         oSolutionBest.oPrimitiveValues[sPrefixed].sName]] :
                       ['dot', oWalker.walk(oExpression), sIdentifierName];
                 },
                 /**
                  * If the encountered identifier is a null or Boolean literal
                  * and its value is worthwhile, the identifier is substituted
                  * by an identifier name to which that value is assigned.
                  * Applies to identifier names.
                  * @param {string} sIdentifier The identifier encountered.
                  * @return {!Array} A syntactic code unit that is equivalent to
                  *     the one encountered.
                  * @see TPrimitiveValue#nSaving
                  */
                 'name': function(sIdentifier) {
                   /**
                    * The prefixed representation String of the identifier.
                    * @type {string}
                    */
                   var sPrefixed = EValuePrefixes.S_SYMBOLIC + sIdentifier;

                   return [
                     'name',
                     oSolutionBest.oPrimitiveValues.hasOwnProperty(sPrefixed) &&
                     oSolutionBest.oPrimitiveValues[sPrefixed].nSaving > 0 ?
                     oSolutionBest.oPrimitiveValues[sPrefixed].sName :
                     sIdentifier
                   ];
                 },
                 /**
                  * If the encountered String value is worthwhile, it is
                  * substituted by an identifier name to which that value is
                  * assigned.
                  * Applies to String values.
                  * @param {string} sStringValue The String value of the string
                  *     literal encountered.
                  * @return {!Array} A syntactic code unit that is equivalent to
                  *     the one encountered.
                  * @see TPrimitiveValue#nSaving
                  */
                 'string': function(sStringValue) {
                   /**
                    * The prefixed representation String of the primitive value
                    * of the literal.
                    * @type {string}
                    */
                   var sPrefixed =
                       EValuePrefixes.S_STRING + sStringValue;

                   return oSolutionBest.oPrimitiveValues.hasOwnProperty(
                       sPrefixed) &&
                       oSolutionBest.oPrimitiveValues[sPrefixed].nSaving > 0 ?
                       ['name',
                        oSolutionBest.oPrimitiveValues[sPrefixed].sName] :
                       ['string', sStringValue];
                 }
               },
               /**
                * Such data on what to consolidate within the range of source
                * elements that is currently being considered that lead to the
                * greatest known reduction of the number of the terminal symbols
                * in comparison to the original source text.
                * @type {!TSolution}
                */
               oSolutionBest = new TSolution(),
               /**
                * Data representing an ongoing attempt to find a better
                * reduction of the number of the terminal symbols in comparison
                * to the original source text than the best one that is
                * currently known.
                * @type {!TSolution}
                * @see oSolutionBest
                */
               oSolutionCandidate = new TSolution(),
               /**
                * A record consisting of data about the range of source elements
                * that is currently being examined.
                * @type {!TSourceElementsData}
                */
               oSourceElementsData = new TSourceElementsData(),
               /**
                * Variable declarations for each primitive value that is to be
                * consolidated within the elements.
                * @type {!Array.<!Array>}
                */
               aVariableDeclarations = [],
               /**
                * Augments a list with a prefixed representation String.
                * @param {!Array.<string>} aList A list that is to be augmented.
                * @return {function(string)} A function that augments a list
                *     with a prefixed representation String.
                */
               cAugmentList = function(aList) {
                 /**
                  * @param {string} sPrefixed Prefixed representation String of
                  *     a primitive value that could be consolidated within the
                  *     elements.
                  */
                 var fLambda = function(sPrefixed) {
                   if (-1 === aList.indexOf(sPrefixed)) {
                     aList.push(sPrefixed);
                   }
                 };

                 return fLambda;
               },
               /**
                * Adds the number of occurrences of a primitive value of a given
                * category that could be consolidated in the source element with
                * a given index to the count of occurrences of that primitive
                * value within the range of source elements that is currently
                * being considered.
                * @param {number} nPosition The index (in the source text order)
                *     of a source element.
                * @param {number} nCategory The category of the primary
                *     expression from which the primitive value is derived.
                * @return {function(string)} A function that performs the
                *     addition.
                * @see cAddOccurrencesInCategory
                */
               cAddOccurrences = function(nPosition, nCategory) {
                 /**
                  * @param {string} sPrefixed The prefixed representation String
                  *     of a primitive value.
                  */
                 var fLambda = function(sPrefixed) {
                   if (!oSourceElementsData.aCount[nCategory].hasOwnProperty(
                           sPrefixed)) {
                     oSourceElementsData.aCount[nCategory][sPrefixed] = 0;
                   }
                   oSourceElementsData.aCount[nCategory][sPrefixed] +=
                       aSourceElementsData[nPosition].aCount[nCategory][
                           sPrefixed];
                 };

                 return fLambda;
               },
               /**
                * Adds the number of occurrences of each primitive value of a
                * given category that could be consolidated in the source
                * element with a given index to the count of occurrences of that
                * primitive values within the range of source elements that is
                * currently being considered.
                * @param {number} nPosition The index (in the source text order)
                *     of a source element.
                * @return {function(number)} A function that performs the
                *     addition.
                * @see fAddOccurrences
                */
               cAddOccurrencesInCategory = function(nPosition) {
                 /**
                  * @param {number} nCategory The category of the primary
                  *     expression from which the primitive value is derived.
                  */
                 var fLambda = function(nCategory) {
                   Object.keys(
                       aSourceElementsData[nPosition].aCount[nCategory]
                   ).forEach(cAddOccurrences(nPosition, nCategory));
                 };

                 return fLambda;
               },
               /**
                * Adds the number of occurrences of each primitive value that
                * could be consolidated in the source element with a given index
                * to the count of occurrences of that primitive values within
                * the range of source elements that is currently being
                * considered.
                * @param {number} nPosition The index (in the source text order)
                *     of a source element.
                */
               fAddOccurrences = function(nPosition) {
                 Object.keys(aSourceElementsData[nPosition].aCount).forEach(
                     cAddOccurrencesInCategory(nPosition));
               },
               /**
                * Creates a variable declaration for a primitive value if that
                * primitive value is to be consolidated within the elements.
                * @param {string} sPrefixed Prefixed representation String of a
                *     primitive value that could be consolidated within the
                *     elements.
                * @see aVariableDeclarations
                */
               cAugmentVariableDeclarations = function(sPrefixed) {
                 if (oSolutionBest.oPrimitiveValues[sPrefixed].nSaving > 0) {
                   aVariableDeclarations.push([
                     oSolutionBest.oPrimitiveValues[sPrefixed].sName,
                     [0 === sPrefixed.indexOf(EValuePrefixes.S_SYMBOLIC) ?
                      'name' : 'string',
                      sPrefixed.substring(EValuePrefixes.S_SYMBOLIC.length)]
                   ]);
                 }
               },
               /**
                * Sorts primitive values with regard to the difference in the
                * number of terminal symbols between the original source text
                * and the one with those primitive values consolidated.
                * @param {string} sPrefixed0 The prefixed representation String
                *     of the first of the two primitive values that are being
                *     compared.
                * @param {string} sPrefixed1 The prefixed representation String
                *     of the second of the two primitive values that are being
                *     compared.
                * @return {number}
                *     <dl>
                *         <dt>-1</dt>
                *         <dd>if the first primitive value must be placed before
                *              the other one,</dd>
                *         <dt>0</dt>
                *         <dd>if the first primitive value may be placed before
                *              the other one,</dd>
                *         <dt>1</dt>
                *         <dd>if the first primitive value must not be placed
                *              before the other one.</dd>
                *     </dl>
                * @see TSolution.oPrimitiveValues
                */
               cSortPrimitiveValues = function(sPrefixed0, sPrefixed1) {
                 /**
                  * The difference between:
                  * <ol>
                  * <li>the difference in the number of terminal symbols
                  *     between the original source text and the one with the
                  *     first primitive value consolidated, and</li>
                  * <li>the difference in the number of terminal symbols
                  *     between the original source text and the one with the
                  *     second primitive value consolidated.</li>
                  * </ol>
                  * @type {number}
                  */
                 var nDifference =
                     oSolutionCandidate.oPrimitiveValues[sPrefixed0].nSaving -
                     oSolutionCandidate.oPrimitiveValues[sPrefixed1].nSaving;

                 return nDifference > 0 ? -1 : nDifference < 0 ? 1 : 0;
               },
               /**
                * Assigns an identifier name to a primitive value and calculates
                * whether instances of that primitive value are worth
                * consolidating.
                * @param {string} sPrefixed The prefixed representation String
                *     of a primitive value that is being evaluated.
                */
               fEvaluatePrimitiveValue = function(sPrefixed) {
                 var _,
                     /**
                      * The index of the last mangled name.
                      * @type {number}
                      */
                     nIndex,
                     /**
                      * The representation String of the primitive value that is
                      * being evaluated.
                      * @type {string}
                      */
                     sName =
                         sPrefixed.substring(EValuePrefixes.S_SYMBOLIC.length),
                     /**
                      * The number of source characters taken up by the
                      * representation String of the primitive value that is
                      * being evaluated.
                      * @type {number}
                      */
                     nLengthOriginal = sName.length,
                     /**
                      * The number of source characters taken up by the
                      * identifier name that could substitute the primitive
                      * value that is being evaluated.
                      * substituted.
                      * @type {number}
                      */
                     nLengthSubstitution,
                     /**
                      * The number of source characters taken up by by the
                      * representation String of the primitive value that is
                      * being evaluated when it is represented by a string
                      * literal.
                      * @type {number}
                      */
                     nLengthString = oProcessor.make_string(sName).length;

                 oSolutionCandidate.oPrimitiveValues[sPrefixed] =
                     new TPrimitiveValue();
                 do {  // Find an identifier unused in this or any nested scope.
                   nIndex = oScope.cname;
                   oSolutionCandidate.oPrimitiveValues[sPrefixed].sName =
                       oScope.next_mangled();
                 } while (-1 !== oSourceElementsData.aIdentifiers.indexOf(
                     oSolutionCandidate.oPrimitiveValues[sPrefixed].sName));
                 nLengthSubstitution = oSolutionCandidate.oPrimitiveValues[
                     sPrefixed].sName.length;
                 if (0 === sPrefixed.indexOf(EValuePrefixes.S_SYMBOLIC)) {
                   // foo:null, or foo:null;
                   oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving -=
                       nLengthSubstitution + nLengthOriginal +
                       oWeights.N_VARIABLE_DECLARATION;
                   // null vs foo
                   oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving +=
                       oSourceElementsData.aCount[
                           EPrimaryExpressionCategories.
                               N_NULL_AND_BOOLEAN_LITERALS][sPrefixed] *
                       (nLengthOriginal - nLengthSubstitution);
                 } else {
                   // foo:'fromCharCode';
                   oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving -=
                       nLengthSubstitution + nLengthString +
                       oWeights.N_VARIABLE_DECLARATION;
                   // .fromCharCode vs [foo]
                   if (oSourceElementsData.aCount[
                           EPrimaryExpressionCategories.N_IDENTIFIER_NAMES
                       ].hasOwnProperty(sPrefixed)) {
                     oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving +=
                         oSourceElementsData.aCount[
                             EPrimaryExpressionCategories.N_IDENTIFIER_NAMES
                         ][sPrefixed] *
                         (nLengthOriginal - nLengthSubstitution -
                          oWeights.N_PROPERTY_ACCESSOR);
                   }
                   // 'fromCharCode' vs foo
                   if (oSourceElementsData.aCount[
                           EPrimaryExpressionCategories.N_STRING_LITERALS
                       ].hasOwnProperty(sPrefixed)) {
                     oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving +=
                         oSourceElementsData.aCount[
                             EPrimaryExpressionCategories.N_STRING_LITERALS
                         ][sPrefixed] *
                         (nLengthString - nLengthSubstitution);
                   }
                 }
                 if (oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving >
                     0) {
                   oSolutionCandidate.nSavings +=
                       oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving;
                 } else {
                   oScope.cname = nIndex; // Free the identifier name.
                 }
               },
               /**
                * Adds a variable declaration to an existing variable statement.
                * @param {!Array} aVariableDeclaration A variable declaration
                *     with an initialiser.
                */
               cAddVariableDeclaration = function(aVariableDeclaration) {
                 (/** @type {!Array} */ oSourceElements[nFrom][1]).unshift(
                     aVariableDeclaration);
               };

           if (nFrom > nTo) {
             return;
           }
           // If the range is a closure, reuse the closure.
           if (nFrom === nTo &&
               'stat' === oSourceElements[nFrom][0] &&
               'call' === oSourceElements[nFrom][1][0] &&
               'function' === oSourceElements[nFrom][1][1][0]) {
             fExamineSyntacticCodeUnit(oSourceElements[nFrom][1][1]);
             return;
           }
           // Create a list of all derived primitive values within the range.
           for (nPosition = nFrom; nPosition <= nTo; nPosition += 1) {
             aSourceElementsData[nPosition].aPrimitiveValues.forEach(
                 cAugmentList(oSourceElementsData.aPrimitiveValues));
           }
           if (0 === oSourceElementsData.aPrimitiveValues.length) {
             return;
           }
           for (nPosition = nFrom; nPosition <= nTo; nPosition += 1) {
             // Add the number of occurrences to the total count.
             fAddOccurrences(nPosition);
             // Add identifiers of this or any nested scope to the list.
             aSourceElementsData[nPosition].aIdentifiers.forEach(
                 cAugmentList(oSourceElementsData.aIdentifiers));
           }
           // Distribute identifier names among derived primitive values.
           do {  // If there was any progress, find a better distribution.
             oSolutionBest = oSolutionCandidate;
             if (Object.keys(oSolutionCandidate.oPrimitiveValues).length > 0) {
               // Sort primitive values descending by their worthwhileness.
               oSourceElementsData.aPrimitiveValues.sort(cSortPrimitiveValues);
             }
             oSolutionCandidate = new TSolution();
             oSourceElementsData.aPrimitiveValues.forEach(
                 fEvaluatePrimitiveValue);
             oScope.cname = nIndex;
           } while (oSolutionCandidate.nSavings > oSolutionBest.nSavings);
           // Take the necessity of adding a variable statement into account.
           if ('var' !== oSourceElements[nFrom][0]) {
             oSolutionBest.nSavings -= oWeights.N_VARIABLE_STATEMENT_AFFIXATION;
           }
           if (bEnclose) {
             // Take the necessity of forming a closure into account.
             oSolutionBest.nSavings -= oWeights.N_CLOSURE;
           }
           if (oSolutionBest.nSavings > 0) {
             // Create variable declarations suitable for UglifyJS.
             Object.keys(oSolutionBest.oPrimitiveValues).forEach(
                 cAugmentVariableDeclarations);
             // Rewrite expressions that contain worthwhile primitive values.
             for (nPosition = nFrom; nPosition <= nTo; nPosition += 1) {
               oWalker = oProcessor.ast_walker();
               oSourceElements[nPosition] =
                   oWalker.with_walkers(
                       oWalkersTransformers,
                       cContext(oWalker, oSourceElements[nPosition]));
             }
             if ('var' === oSourceElements[nFrom][0]) {  // Reuse the statement.
               (/** @type {!Array.<!Array>} */ aVariableDeclarations.reverse(
                   )).forEach(cAddVariableDeclaration);
             } else {  // Add a variable statement.
               Array.prototype.splice.call(
                   oSourceElements,
                   nFrom,
                   0,
                   ['var', aVariableDeclarations]);
               nTo += 1;
             }
             if (bEnclose) {
               // Add a closure.
               Array.prototype.splice.call(
                   oSourceElements,
                   nFrom,
                   0,
                   ['stat', ['call', ['function', null, [], []], []]]);
               // Copy source elements into the closure.
               for (nPosition = nTo + 1; nPosition > nFrom; nPosition -= 1) {
                 Array.prototype.unshift.call(
                     oSourceElements[nFrom][1][1][3],
                     oSourceElements[nPosition]);
               }
               // Remove source elements outside the closure.
               Array.prototype.splice.call(
                   oSourceElements,
                   nFrom + 1,
                   nTo - nFrom + 1);
             }
           }
           if (bEnclose) {
             // Restore the availability of identifier names.
             oScope.cname = nIndex;
           }
         };

     oSourceElements = (/** @type {!TSyntacticCodeUnit} */
         oSyntacticCodeUnit[bIsGlobal ? 1 : 3]);
     if (0 === oSourceElements.length) {
       return;
     }
     oScope = bIsGlobal ? oSyntacticCodeUnit.scope : oSourceElements.scope;
     // Skip a Directive Prologue.
     while (nAfterDirectivePrologue < oSourceElements.length &&
            'directive' === oSourceElements[nAfterDirectivePrologue][0]) {
       nAfterDirectivePrologue += 1;
       aSourceElementsData.push(null);
     }
     if (oSourceElements.length === nAfterDirectivePrologue) {
       return;
     }
     for (nPosition = nAfterDirectivePrologue;
          nPosition < oSourceElements.length;
          nPosition += 1) {
       oSourceElementData = new TSourceElementsData();
       oWalker = oProcessor.ast_walker();
       // Classify a source element.
       // Find its derived primitive values and count their occurrences.
       // Find all identifiers used (including nested scopes).
       oWalker.with_walkers(
           oWalkers.oSurveySourceElement,
           cContext(oWalker, oSourceElements[nPosition]));
       // Establish whether the scope is still wholly examinable.
       bIsWhollyExaminable = bIsWhollyExaminable &&
           ESourceElementCategories.N_WITH !== oSourceElementData.nCategory &&
           ESourceElementCategories.N_EVAL !== oSourceElementData.nCategory;
       aSourceElementsData.push(oSourceElementData);
     }
     if (bIsWhollyExaminable) {  // Examine the whole scope.
       fExamineSourceElements(
           nAfterDirectivePrologue,
           oSourceElements.length - 1,
           false);
     } else {  // Examine unexcluded ranges of source elements.
       for (nPosition = oSourceElements.length - 1;
            nPosition >= nAfterDirectivePrologue;
            nPosition -= 1) {
         oSourceElementData = (/** @type {!TSourceElementsData} */
             aSourceElementsData[nPosition]);
         if (ESourceElementCategories.N_OTHER ===
             oSourceElementData.nCategory) {
           if ('undefined' === typeof nTo) {
             nTo = nPosition;  // Indicate the end of a range.
           }
           // Examine the range if it immediately follows a Directive Prologue.
           if (nPosition === nAfterDirectivePrologue) {
             fExamineSourceElements(nPosition, nTo, true);
           }
         } else {
           if ('undefined' !== typeof nTo) {
             // Examine the range that immediately follows this source element.
             fExamineSourceElements(nPosition + 1, nTo, true);
             nTo = void 0;  // Obliterate the range.
           }
           // Examine nested functions.
           oWalker = oProcessor.ast_walker();
           oWalker.with_walkers(
               oWalkers.oExamineFunctions,
               cContext(oWalker, oSourceElements[nPosition]));
         }
       }
     }
   }(oAbstractSyntaxTree = oProcessor.ast_add_scope(oAbstractSyntaxTree)));
  return oAbstractSyntaxTree;
};
/*jshint sub:false */

/* Local Variables:      */
/* mode: js              */
/* coding: utf-8         */
/* indent-tabs-mode: nil */
/* tab-width: 2          */
/* End:                  */
/* vim: set ft=javascript fenc=utf-8 et ts=2 sts=2 sw=2: */
/* :mode=javascript:noTabs=true:tabSize=2:indentSize=2:deepIndent=true: */


})()
},{"./process":122}],121:[function(require,module,exports){
/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.

  This version is suitable for Node.js.  With minimal changes (the
  exports stuff) it should work on any JS platform.

  This file contains the tokenizer/parser.  It is a port to JavaScript
  of parse-js [1], a JavaScript parser library written in Common Lisp
  by Marijn Haverbeke.  Thank you Marijn!

  [1] http://marijn.haverbeke.nl/parse-js/

  Exported functions:

    - tokenizer(code) -- returns a function.  Call the returned
      function to fetch the next token.

    - parse(code) -- returns an AST of the given JavaScript code.

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2010 (c) Mihai Bazon <mihai.bazon@gmail.com>
    Based on parse-js (http://marijn.haverbeke.nl/parse-js/).

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

/* -----[ Tokenizer (constants) ]----- */

var KEYWORDS = array_to_hash([
    "break",
    "case",
    "catch",
    "const",
    "continue",
    "debugger",
    "default",
    "delete",
    "do",
    "else",
    "finally",
    "for",
    "function",
    "if",
    "in",
    "instanceof",
    "new",
    "return",
    "switch",
    "throw",
    "try",
    "typeof",
    "var",
    "void",
    "while",
    "with"
]);

var RESERVED_WORDS = array_to_hash([
    "abstract",
    "boolean",
    "byte",
    "char",
    "class",
    "double",
    "enum",
    "export",
    "extends",
    "final",
    "float",
    "goto",
    "implements",
    "import",
    "int",
    "interface",
    "long",
    "native",
    "package",
    "private",
    "protected",
    "public",
    "short",
    "static",
    "super",
    "synchronized",
    "throws",
    "transient",
    "volatile"
]);

var KEYWORDS_BEFORE_EXPRESSION = array_to_hash([
    "return",
    "new",
    "delete",
    "throw",
    "else",
    "case"
]);

var KEYWORDS_ATOM = array_to_hash([
    "false",
    "null",
    "true",
    "undefined"
]);

var OPERATOR_CHARS = array_to_hash(characters("+-*&%=<>!?|~^"));

var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;
var RE_OCT_NUMBER = /^0[0-7]+$/;
var RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i;

var OPERATORS = array_to_hash([
    "in",
    "instanceof",
    "typeof",
    "new",
    "void",
    "delete",
    "++",
    "--",
    "+",
    "-",
    "!",
    "~",
    "&",
    "|",
    "^",
    "*",
    "/",
    "%",
    ">>",
    "<<",
    ">>>",
    "<",
    ">",
    "<=",
    ">=",
    "==",
    "===",
    "!=",
    "!==",
    "?",
    "=",
    "+=",
    "-=",
    "/=",
    "*=",
    "%=",
    ">>=",
    "<<=",
    ">>>=",
    "|=",
    "^=",
    "&=",
    "&&",
    "||"
]);

var WHITESPACE_CHARS = array_to_hash(characters(" \u00a0\n\r\t\f\u000b\u200b\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\uFEFF"));

var PUNC_BEFORE_EXPRESSION = array_to_hash(characters("[{(,.;:"));

var PUNC_CHARS = array_to_hash(characters("[]{}(),;:"));

var REGEXP_MODIFIERS = array_to_hash(characters("gmsiy"));

/* -----[ Tokenizer ]----- */

var UNICODE = {  // Unicode 6.1
    letter: new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
    combining_mark: new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08E4-\\u08FE\\u0900-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C01-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C82\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D02\\u0D03\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F\\u109A-\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF2-\\u1CF4\\u1DC0-\\u1DE6\\u1DFC-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA674-\\uA67D\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA7B\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),
    connector_punctuation: new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]"),
    digit: new RegExp("[\\u0030-\\u0039\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]")
};

function is_letter(ch) {
    return UNICODE.letter.test(ch);
};

function is_digit(ch) {
    ch = ch.charCodeAt(0);
    return ch >= 48 && ch <= 57;
};

function is_unicode_digit(ch) {
    return UNICODE.digit.test(ch);
}

function is_alphanumeric_char(ch) {
    return is_digit(ch) || is_letter(ch);
};

function is_unicode_combining_mark(ch) {
    return UNICODE.combining_mark.test(ch);
};

function is_unicode_connector_punctuation(ch) {
    return UNICODE.connector_punctuation.test(ch);
};

function is_identifier_start(ch) {
    return ch == "$" || ch == "_" || is_letter(ch);
};

function is_identifier_char(ch) {
    return is_identifier_start(ch)
        || is_unicode_combining_mark(ch)
        || is_unicode_digit(ch)
        || is_unicode_connector_punctuation(ch)
        || ch == "\u200c" // zero-width non-joiner <ZWNJ>
        || ch == "\u200d" // zero-width joiner <ZWJ> (in my ECMA-262 PDF, this is also 200c)
    ;
};

function parse_js_number(num) {
    if (RE_HEX_NUMBER.test(num)) {
        return parseInt(num.substr(2), 16);
    } else if (RE_OCT_NUMBER.test(num)) {
        return parseInt(num.substr(1), 8);
    } else if (RE_DEC_NUMBER.test(num)) {
        return parseFloat(num);
    }
};

function JS_Parse_Error(message, line, col, pos) {
    this.message = message;
    this.line = line + 1;
    this.col = col + 1;
    this.pos = pos + 1;
    this.stack = new Error().stack;
};

JS_Parse_Error.prototype.toString = function() {
    return this.message + " (line: " + this.line + ", col: " + this.col + ", pos: " + this.pos + ")" + "\n\n" + this.stack;
};

function js_error(message, line, col, pos) {
    throw new JS_Parse_Error(message, line, col, pos);
};

function is_token(token, type, val) {
    return token.type == type && (val == null || token.value == val);
};

var EX_EOF = {};

function tokenizer($TEXT) {

    var S = {
        text            : $TEXT.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/^\uFEFF/, ''),
        pos             : 0,
        tokpos          : 0,
        line            : 0,
        tokline         : 0,
        col             : 0,
        tokcol          : 0,
        newline_before  : false,
        regex_allowed   : false,
        comments_before : []
    };

    function peek() { return S.text.charAt(S.pos); };

    function next(signal_eof, in_string) {
        var ch = S.text.charAt(S.pos++);
        if (signal_eof && !ch)
            throw EX_EOF;
        if (ch == "\n") {
            S.newline_before = S.newline_before || !in_string;
            ++S.line;
            S.col = 0;
        } else {
            ++S.col;
        }
        return ch;
    };

    function eof() {
        return !S.peek();
    };

    function find(what, signal_eof) {
        var pos = S.text.indexOf(what, S.pos);
        if (signal_eof && pos == -1) throw EX_EOF;
        return pos;
    };

    function start_token() {
        S.tokline = S.line;
        S.tokcol = S.col;
        S.tokpos = S.pos;
    };

    function token(type, value, is_comment) {
        S.regex_allowed = ((type == "operator" && !HOP(UNARY_POSTFIX, value)) ||
                           (type == "keyword" && HOP(KEYWORDS_BEFORE_EXPRESSION, value)) ||
                           (type == "punc" && HOP(PUNC_BEFORE_EXPRESSION, value)));
        var ret = {
            type   : type,
            value  : value,
            line   : S.tokline,
            col    : S.tokcol,
            pos    : S.tokpos,
            endpos : S.pos,
            nlb    : S.newline_before
        };
        if (!is_comment) {
            ret.comments_before = S.comments_before;
            S.comments_before = [];
            // make note of any newlines in the comments that came before
            for (var i = 0, len = ret.comments_before.length; i < len; i++) {
                ret.nlb = ret.nlb || ret.comments_before[i].nlb;
            }
        }
        S.newline_before = false;
        return ret;
    };

    function skip_whitespace() {
        while (HOP(WHITESPACE_CHARS, peek()))
            next();
    };

    function read_while(pred) {
        var ret = "", ch = peek(), i = 0;
        while (ch && pred(ch, i++)) {
            ret += next();
            ch = peek();
        }
        return ret;
    };

    function parse_error(err) {
        js_error(err, S.tokline, S.tokcol, S.tokpos);
    };

    function read_num(prefix) {
        var has_e = false, after_e = false, has_x = false, has_dot = prefix == ".";
        var num = read_while(function(ch, i){
            if (ch == "x" || ch == "X") {
                if (has_x) return false;
                return has_x = true;
            }
            if (!has_x && (ch == "E" || ch == "e")) {
                if (has_e) return false;
                return has_e = after_e = true;
            }
            if (ch == "-") {
                if (after_e || (i == 0 && !prefix)) return true;
                return false;
            }
            if (ch == "+") return after_e;
            after_e = false;
            if (ch == ".") {
                if (!has_dot && !has_x && !has_e)
                    return has_dot = true;
                return false;
            }
            return is_alphanumeric_char(ch);
        });
        if (prefix)
            num = prefix + num;
        var valid = parse_js_number(num);
        if (!isNaN(valid)) {
            return token("num", valid);
        } else {
            parse_error("Invalid syntax: " + num);
        }
    };

    function read_escaped_char(in_string) {
        var ch = next(true, in_string);
        switch (ch) {
          case "n" : return "\n";
          case "r" : return "\r";
          case "t" : return "\t";
          case "b" : return "\b";
          case "v" : return "\u000b";
          case "f" : return "\f";
          case "0" : return "\0";
          case "x" : return String.fromCharCode(hex_bytes(2));
          case "u" : return String.fromCharCode(hex_bytes(4));
          case "\n": return "";
          default  : return ch;
        }
    };

    function hex_bytes(n) {
        var num = 0;
        for (; n > 0; --n) {
            var digit = parseInt(next(true), 16);
            if (isNaN(digit))
                parse_error("Invalid hex-character pattern in string");
            num = (num << 4) | digit;
        }
        return num;
    };

    function read_string() {
        return with_eof_error("Unterminated string constant", function(){
            var quote = next(), ret = "";
            for (;;) {
                var ch = next(true);
                if (ch == "\\") {
                    // read OctalEscapeSequence (XXX: deprecated if "strict mode")
                    // https://github.com/mishoo/UglifyJS/issues/178
                    var octal_len = 0, first = null;
                    ch = read_while(function(ch){
                        if (ch >= "0" && ch <= "7") {
                            if (!first) {
                                first = ch;
                                return ++octal_len;
                            }
                            else if (first <= "3" && octal_len <= 2) return ++octal_len;
                            else if (first >= "4" && octal_len <= 1) return ++octal_len;
                        }
                        return false;
                    });
                    if (octal_len > 0) ch = String.fromCharCode(parseInt(ch, 8));
                    else ch = read_escaped_char(true);
                }
                else if (ch == quote) break;
                else if (ch == "\n") throw EX_EOF;
                ret += ch;
            }
            return token("string", ret);
        });
    };

    function read_line_comment() {
        next();
        var i = find("\n"), ret;
        if (i == -1) {
            ret = S.text.substr(S.pos);
            S.pos = S.text.length;
        } else {
            ret = S.text.substring(S.pos, i);
            S.pos = i;
        }
        return token("comment1", ret, true);
    };

    function read_multiline_comment() {
        next();
        return with_eof_error("Unterminated multiline comment", function(){
            var i = find("*/", true),
            text = S.text.substring(S.pos, i);
            S.pos = i + 2;
            S.line += text.split("\n").length - 1;
            S.newline_before = S.newline_before || text.indexOf("\n") >= 0;

            // https://github.com/mishoo/UglifyJS/issues/#issue/100
            if (/^@cc_on/i.test(text)) {
                warn("WARNING: at line " + S.line);
                warn("*** Found \"conditional comment\": " + text);
                warn("*** UglifyJS DISCARDS ALL COMMENTS.  This means your code might no longer work properly in Internet Explorer.");
            }

            return token("comment2", text, true);
        });
    };

    function read_name() {
        var backslash = false, name = "", ch, escaped = false, hex;
        while ((ch = peek()) != null) {
            if (!backslash) {
                if (ch == "\\") escaped = backslash = true, next();
                else if (is_identifier_char(ch)) name += next();
                else break;
            }
            else {
                if (ch != "u") parse_error("Expecting UnicodeEscapeSequence -- uXXXX");
                ch = read_escaped_char();
                if (!is_identifier_char(ch)) parse_error("Unicode char: " + ch.charCodeAt(0) + " is not valid in identifier");
                name += ch;
                backslash = false;
            }
        }
        if (HOP(KEYWORDS, name) && escaped) {
            hex = name.charCodeAt(0).toString(16).toUpperCase();
            name = "\\u" + "0000".substr(hex.length) + hex + name.slice(1);
        }
        return name;
    };

    function read_regexp(regexp) {
        return with_eof_error("Unterminated regular expression", function(){
            var prev_backslash = false, ch, in_class = false;
            while ((ch = next(true))) if (prev_backslash) {
                regexp += "\\" + ch;
                prev_backslash = false;
            } else if (ch == "[") {
                in_class = true;
                regexp += ch;
            } else if (ch == "]" && in_class) {
                in_class = false;
                regexp += ch;
            } else if (ch == "/" && !in_class) {
                break;
            } else if (ch == "\\") {
                prev_backslash = true;
            } else {
                regexp += ch;
            }
            var mods = read_name();
            return token("regexp", [ regexp, mods ]);
        });
    };

    function read_operator(prefix) {
        function grow(op) {
            if (!peek()) return op;
            var bigger = op + peek();
            if (HOP(OPERATORS, bigger)) {
                next();
                return grow(bigger);
            } else {
                return op;
            }
        };
        return token("operator", grow(prefix || next()));
    };

    function handle_slash() {
        next();
        var regex_allowed = S.regex_allowed;
        switch (peek()) {
          case "/":
            S.comments_before.push(read_line_comment());
            S.regex_allowed = regex_allowed;
            return next_token();
          case "*":
            S.comments_before.push(read_multiline_comment());
            S.regex_allowed = regex_allowed;
            return next_token();
        }
        return S.regex_allowed ? read_regexp("") : read_operator("/");
    };

    function handle_dot() {
        next();
        return is_digit(peek())
            ? read_num(".")
            : token("punc", ".");
    };

    function read_word() {
        var word = read_name();
        return !HOP(KEYWORDS, word)
            ? token("name", word)
            : HOP(OPERATORS, word)
            ? token("operator", word)
            : HOP(KEYWORDS_ATOM, word)
            ? token("atom", word)
            : token("keyword", word);
    };

    function with_eof_error(eof_error, cont) {
        try {
            return cont();
        } catch(ex) {
            if (ex === EX_EOF) parse_error(eof_error);
            else throw ex;
        }
    };

    function next_token(force_regexp) {
        if (force_regexp != null)
            return read_regexp(force_regexp);
        skip_whitespace();
        start_token();
        var ch = peek();
        if (!ch) return token("eof");
        if (is_digit(ch)) return read_num();
        if (ch == '"' || ch == "'") return read_string();
        if (HOP(PUNC_CHARS, ch)) return token("punc", next());
        if (ch == ".") return handle_dot();
        if (ch == "/") return handle_slash();
        if (HOP(OPERATOR_CHARS, ch)) return read_operator();
        if (ch == "\\" || is_identifier_start(ch)) return read_word();
        parse_error("Unexpected character '" + ch + "'");
    };

    next_token.context = function(nc) {
        if (nc) S = nc;
        return S;
    };

    return next_token;

};

/* -----[ Parser (constants) ]----- */

var UNARY_PREFIX = array_to_hash([
    "typeof",
    "void",
    "delete",
    "--",
    "++",
    "!",
    "~",
    "-",
    "+"
]);

var UNARY_POSTFIX = array_to_hash([ "--", "++" ]);

var ASSIGNMENT = (function(a, ret, i){
    while (i < a.length) {
        ret[a[i]] = a[i].substr(0, a[i].length - 1);
        i++;
    }
    return ret;
})(
    ["+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&="],
    { "=": true },
    0
);

var PRECEDENCE = (function(a, ret){
    for (var i = 0, n = 1; i < a.length; ++i, ++n) {
        var b = a[i];
        for (var j = 0; j < b.length; ++j) {
            ret[b[j]] = n;
        }
    }
    return ret;
})(
    [
        ["||"],
        ["&&"],
        ["|"],
        ["^"],
        ["&"],
        ["==", "===", "!=", "!=="],
        ["<", ">", "<=", ">=", "in", "instanceof"],
        [">>", "<<", ">>>"],
        ["+", "-"],
        ["*", "/", "%"]
    ],
    {}
);

var STATEMENTS_WITH_LABELS = array_to_hash([ "for", "do", "while", "switch" ]);

var ATOMIC_START_TOKEN = array_to_hash([ "atom", "num", "string", "regexp", "name" ]);

/* -----[ Parser ]----- */

function NodeWithToken(str, start, end) {
    this.name = str;
    this.start = start;
    this.end = end;
};

NodeWithToken.prototype.toString = function() { return this.name; };

function parse($TEXT, exigent_mode, embed_tokens) {

    var S = {
        input         : typeof $TEXT == "string" ? tokenizer($TEXT, true) : $TEXT,
        token         : null,
        prev          : null,
        peeked        : null,
        in_function   : 0,
        in_directives : true,
        in_loop       : 0,
        labels        : []
    };

    S.token = next();

    function is(type, value) {
        return is_token(S.token, type, value);
    };

    function peek() { return S.peeked || (S.peeked = S.input()); };

    function next() {
        S.prev = S.token;
        if (S.peeked) {
            S.token = S.peeked;
            S.peeked = null;
        } else {
            S.token = S.input();
        }
        S.in_directives = S.in_directives && (
            S.token.type == "string" || is("punc", ";")
        );
        return S.token;
    };

    function prev() {
        return S.prev;
    };

    function croak(msg, line, col, pos) {
        var ctx = S.input.context();
        js_error(msg,
                 line != null ? line : ctx.tokline,
                 col != null ? col : ctx.tokcol,
                 pos != null ? pos : ctx.tokpos);
    };

    function token_error(token, msg) {
        croak(msg, token.line, token.col);
    };

    function unexpected(token) {
        if (token == null)
            token = S.token;
        token_error(token, "Unexpected token: " + token.type + " (" + token.value + ")");
    };

    function expect_token(type, val) {
        if (is(type, val)) {
            return next();
        }
        token_error(S.token, "Unexpected token " + S.token.type + ", expected " + type);
    };

    function expect(punc) { return expect_token("punc", punc); };

    function can_insert_semicolon() {
        return !exigent_mode && (
            S.token.nlb || is("eof") || is("punc", "}")
        );
    };

    function semicolon() {
        if (is("punc", ";")) next();
        else if (!can_insert_semicolon()) unexpected();
    };

    function as() {
        return slice(arguments);
    };

    function parenthesised() {
        expect("(");
        var ex = expression();
        expect(")");
        return ex;
    };

    function add_tokens(str, start, end) {
        return str instanceof NodeWithToken ? str : new NodeWithToken(str, start, end);
    };

    function maybe_embed_tokens(parser) {
        if (embed_tokens) return function() {
            var start = S.token;
            var ast = parser.apply(this, arguments);
            ast[0] = add_tokens(ast[0], start, prev());
            return ast;
        };
        else return parser;
    };

    var statement = maybe_embed_tokens(function() {
        if (is("operator", "/") || is("operator", "/=")) {
            S.peeked = null;
            S.token = S.input(S.token.value.substr(1)); // force regexp
        }
        switch (S.token.type) {
          case "string":
            var dir = S.in_directives, stat = simple_statement();
            if (dir && stat[1][0] == "string" && !is("punc", ","))
                return as("directive", stat[1][1]);
            return stat;
          case "num":
          case "regexp":
          case "operator":
          case "atom":
            return simple_statement();

          case "name":
            return is_token(peek(), "punc", ":")
                ? labeled_statement(prog1(S.token.value, next, next))
                : simple_statement();

          case "punc":
            switch (S.token.value) {
              case "{":
                return as("block", block_());
              case "[":
              case "(":
                return simple_statement();
              case ";":
                next();
                return as("block");
              default:
                unexpected();
            }

          case "keyword":
            switch (prog1(S.token.value, next)) {
              case "break":
                return break_cont("break");

              case "continue":
                return break_cont("continue");

              case "debugger":
                semicolon();
                return as("debugger");

              case "do":
                return (function(body){
                    expect_token("keyword", "while");
                    return as("do", prog1(parenthesised, semicolon), body);
                })(in_loop(statement));

              case "for":
                return for_();

              case "function":
                return function_(true);

              case "if":
                return if_();

              case "return":
                if (S.in_function == 0)
                    croak("'return' outside of function");
                return as("return",
                          is("punc", ";")
                          ? (next(), null)
                          : can_insert_semicolon()
                          ? null
                          : prog1(expression, semicolon));

              case "switch":
                return as("switch", parenthesised(), switch_block_());

              case "throw":
                if (S.token.nlb)
                    croak("Illegal newline after 'throw'");
                return as("throw", prog1(expression, semicolon));

              case "try":
                return try_();

              case "var":
                return prog1(var_, semicolon);

              case "const":
                return prog1(const_, semicolon);

              case "while":
                return as("while", parenthesised(), in_loop(statement));

              case "with":
                return as("with", parenthesised(), statement());

              default:
                unexpected();
            }
        }
    });

    function labeled_statement(label) {
        S.labels.push(label);
        var start = S.token, stat = statement();
        if (exigent_mode && !HOP(STATEMENTS_WITH_LABELS, stat[0]))
            unexpected(start);
        S.labels.pop();
        return as("label", label, stat);
    };

    function simple_statement() {
        return as("stat", prog1(expression, semicolon));
    };

    function break_cont(type) {
        var name;
        if (!can_insert_semicolon()) {
            name = is("name") ? S.token.value : null;
        }
        if (name != null) {
            next();
            if (!member(name, S.labels))
                croak("Label " + name + " without matching loop or statement");
        }
        else if (S.in_loop == 0)
            croak(type + " not inside a loop or switch");
        semicolon();
        return as(type, name);
    };

    function for_() {
        expect("(");
        var init = null;
        if (!is("punc", ";")) {
            init = is("keyword", "var")
                ? (next(), var_(true))
                : expression(true, true);
            if (is("operator", "in")) {
                if (init[0] == "var" && init[1].length > 1)
                    croak("Only one variable declaration allowed in for..in loop");
                return for_in(init);
            }
        }
        return regular_for(init);
    };

    function regular_for(init) {
        expect(";");
        var test = is("punc", ";") ? null : expression();
        expect(";");
        var step = is("punc", ")") ? null : expression();
        expect(")");
        return as("for", init, test, step, in_loop(statement));
    };

    function for_in(init) {
        var lhs = init[0] == "var" ? as("name", init[1][0]) : init;
        next();
        var obj = expression();
        expect(")");
        return as("for-in", init, lhs, obj, in_loop(statement));
    };

    var function_ = function(in_statement) {
        var name = is("name") ? prog1(S.token.value, next) : null;
        if (in_statement && !name)
            unexpected();
        expect("(");
        return as(in_statement ? "defun" : "function",
                  name,
                  // arguments
                  (function(first, a){
                      while (!is("punc", ")")) {
                          if (first) first = false; else expect(",");
                          if (!is("name")) unexpected();
                          a.push(S.token.value);
                          next();
                      }
                      next();
                      return a;
                  })(true, []),
                  // body
                  (function(){
                      ++S.in_function;
                      var loop = S.in_loop;
                      S.in_directives = true;
                      S.in_loop = 0;
                      var a = block_();
                      --S.in_function;
                      S.in_loop = loop;
                      return a;
                  })());
    };

    function if_() {
        var cond = parenthesised(), body = statement(), belse;
        if (is("keyword", "else")) {
            next();
            belse = statement();
        }
        return as("if", cond, body, belse);
    };

    function block_() {
        expect("{");
        var a = [];
        while (!is("punc", "}")) {
            if (is("eof")) unexpected();
            a.push(statement());
        }
        next();
        return a;
    };

    var switch_block_ = curry(in_loop, function(){
        expect("{");
        var a = [], cur = null;
        while (!is("punc", "}")) {
            if (is("eof")) unexpected();
            if (is("keyword", "case")) {
                next();
                cur = [];
                a.push([ expression(), cur ]);
                expect(":");
            }
            else if (is("keyword", "default")) {
                next();
                expect(":");
                cur = [];
                a.push([ null, cur ]);
            }
            else {
                if (!cur) unexpected();
                cur.push(statement());
            }
        }
        next();
        return a;
    });

    function try_() {
        var body = block_(), bcatch, bfinally;
        if (is("keyword", "catch")) {
            next();
            expect("(");
            if (!is("name"))
                croak("Name expected");
            var name = S.token.value;
            next();
            expect(")");
            bcatch = [ name, block_() ];
        }
        if (is("keyword", "finally")) {
            next();
            bfinally = block_();
        }
        if (!bcatch && !bfinally)
            croak("Missing catch/finally blocks");
        return as("try", body, bcatch, bfinally);
    };

    function vardefs(no_in) {
        var a = [];
        for (;;) {
            if (!is("name"))
                unexpected();
            var name = S.token.value;
            next();
            if (is("operator", "=")) {
                next();
                a.push([ name, expression(false, no_in) ]);
            } else {
                a.push([ name ]);
            }
            if (!is("punc", ","))
                break;
            next();
        }
        return a;
    };

    function var_(no_in) {
        return as("var", vardefs(no_in));
    };

    function const_() {
        return as("const", vardefs());
    };

    function new_() {
        var newexp = expr_atom(false), args;
        if (is("punc", "(")) {
            next();
            args = expr_list(")");
        } else {
            args = [];
        }
        return subscripts(as("new", newexp, args), true);
    };

    var expr_atom = maybe_embed_tokens(function(allow_calls) {
        if (is("operator", "new")) {
            next();
            return new_();
        }
        if (is("punc")) {
            switch (S.token.value) {
              case "(":
                next();
                return subscripts(prog1(expression, curry(expect, ")")), allow_calls);
              case "[":
                next();
                return subscripts(array_(), allow_calls);
              case "{":
                next();
                return subscripts(object_(), allow_calls);
            }
            unexpected();
        }
        if (is("keyword", "function")) {
            next();
            return subscripts(function_(false), allow_calls);
        }
        if (HOP(ATOMIC_START_TOKEN, S.token.type)) {
            var atom = S.token.type == "regexp"
                ? as("regexp", S.token.value[0], S.token.value[1])
                : as(S.token.type, S.token.value);
            return subscripts(prog1(atom, next), allow_calls);
        }
        unexpected();
    });

    function expr_list(closing, allow_trailing_comma, allow_empty) {
        var first = true, a = [];
        while (!is("punc", closing)) {
            if (first) first = false; else expect(",");
            if (allow_trailing_comma && is("punc", closing)) break;
            if (is("punc", ",") && allow_empty) {
                a.push([ "atom", "undefined" ]);
            } else {
                a.push(expression(false));
            }
        }
        next();
        return a;
    };

    function array_() {
        return as("array", expr_list("]", !exigent_mode, true));
    };

    function object_() {
        var first = true, a = [];
        while (!is("punc", "}")) {
            if (first) first = false; else expect(",");
            if (!exigent_mode && is("punc", "}"))
                // allow trailing comma
                break;
            var type = S.token.type;
            var name = as_property_name();
            if (type == "name" && (name == "get" || name == "set") && !is("punc", ":")) {
                a.push([ as_name(), function_(false), name ]);
            } else {
                expect(":");
                a.push([ name, expression(false) ]);
            }
        }
        next();
        return as("object", a);
    };

    function as_property_name() {
        switch (S.token.type) {
          case "num":
          case "string":
            return prog1(S.token.value, next);
        }
        return as_name();
    };

    function as_name() {
        switch (S.token.type) {
          case "name":
          case "operator":
          case "keyword":
          case "atom":
            return prog1(S.token.value, next);
          default:
            unexpected();
        }
    };

    function subscripts(expr, allow_calls) {
        if (is("punc", ".")) {
            next();
            return subscripts(as("dot", expr, as_name()), allow_calls);
        }
        if (is("punc", "[")) {
            next();
            return subscripts(as("sub", expr, prog1(expression, curry(expect, "]"))), allow_calls);
        }
        if (allow_calls && is("punc", "(")) {
            next();
            return subscripts(as("call", expr, expr_list(")")), true);
        }
        return expr;
    };

    function maybe_unary(allow_calls) {
        if (is("operator") && HOP(UNARY_PREFIX, S.token.value)) {
            return make_unary("unary-prefix",
                              prog1(S.token.value, next),
                              maybe_unary(allow_calls));
        }
        var val = expr_atom(allow_calls);
        while (is("operator") && HOP(UNARY_POSTFIX, S.token.value) && !S.token.nlb) {
            val = make_unary("unary-postfix", S.token.value, val);
            next();
        }
        return val;
    };

    function make_unary(tag, op, expr) {
        if ((op == "++" || op == "--") && !is_assignable(expr))
            croak("Invalid use of " + op + " operator");
        return as(tag, op, expr);
    };

    function expr_op(left, min_prec, no_in) {
        var op = is("operator") ? S.token.value : null;
        if (op && op == "in" && no_in) op = null;
        var prec = op != null ? PRECEDENCE[op] : null;
        if (prec != null && prec > min_prec) {
            next();
            var right = expr_op(maybe_unary(true), prec, no_in);
            return expr_op(as("binary", op, left, right), min_prec, no_in);
        }
        return left;
    };

    function expr_ops(no_in) {
        return expr_op(maybe_unary(true), 0, no_in);
    };

    function maybe_conditional(no_in) {
        var expr = expr_ops(no_in);
        if (is("operator", "?")) {
            next();
            var yes = expression(false);
            expect(":");
            return as("conditional", expr, yes, expression(false, no_in));
        }
        return expr;
    };

    function is_assignable(expr) {
        if (!exigent_mode) return true;
        switch (expr[0]+"") {
          case "dot":
          case "sub":
          case "new":
          case "call":
            return true;
          case "name":
            return expr[1] != "this";
        }
    };

    function maybe_assign(no_in) {
        var left = maybe_conditional(no_in), val = S.token.value;
        if (is("operator") && HOP(ASSIGNMENT, val)) {
            if (is_assignable(left)) {
                next();
                return as("assign", ASSIGNMENT[val], left, maybe_assign(no_in));
            }
            croak("Invalid assignment");
        }
        return left;
    };

    var expression = maybe_embed_tokens(function(commas, no_in) {
        if (arguments.length == 0)
            commas = true;
        var expr = maybe_assign(no_in);
        if (commas && is("punc", ",")) {
            next();
            return as("seq", expr, expression(true, no_in));
        }
        return expr;
    });

    function in_loop(cont) {
        try {
            ++S.in_loop;
            return cont();
        } finally {
            --S.in_loop;
        }
    };

    return as("toplevel", (function(a){
        while (!is("eof"))
            a.push(statement());
        return a;
    })([]));

};

/* -----[ Utilities ]----- */

function curry(f) {
    var args = slice(arguments, 1);
    return function() { return f.apply(this, args.concat(slice(arguments))); };
};

function prog1(ret) {
    if (ret instanceof Function)
        ret = ret();
    for (var i = 1, n = arguments.length; --n > 0; ++i)
        arguments[i]();
    return ret;
};

function array_to_hash(a) {
    var ret = {};
    for (var i = 0; i < a.length; ++i)
        ret[a[i]] = true;
    return ret;
};

function slice(a, start) {
    return Array.prototype.slice.call(a, start || 0);
};

function characters(str) {
    return str.split("");
};

function member(name, array) {
    for (var i = array.length; --i >= 0;)
        if (array[i] == name)
            return true;
    return false;
};

function HOP(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
};

var warn = function() {};

/* -----[ Exports ]----- */

exports.tokenizer = tokenizer;
exports.parse = parse;
exports.slice = slice;
exports.curry = curry;
exports.member = member;
exports.array_to_hash = array_to_hash;
exports.PRECEDENCE = PRECEDENCE;
exports.KEYWORDS_ATOM = KEYWORDS_ATOM;
exports.RESERVED_WORDS = RESERVED_WORDS;
exports.KEYWORDS = KEYWORDS;
exports.ATOMIC_START_TOKEN = ATOMIC_START_TOKEN;
exports.OPERATORS = OPERATORS;
exports.is_alphanumeric_char = is_alphanumeric_char;
exports.is_identifier_start = is_identifier_start;
exports.is_identifier_char = is_identifier_char;
exports.set_logger = function(logger) {
    warn = logger;
};

// Local variables:
// js-indent-level: 4
// End:

},{}],122:[function(require,module,exports){
(function(){/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.

  This version is suitable for Node.js.  With minimal changes (the
  exports stuff) it should work on any JS platform.

  This file implements some AST processors.  They work on data built
  by parse-js.

  Exported functions:

    - ast_mangle(ast, options) -- mangles the variable/function names
      in the AST.  Returns an AST.

    - ast_squeeze(ast) -- employs various optimizations to make the
      final generated code even smaller.  Returns an AST.

    - gen_code(ast, options) -- generates JS code from the AST.  Pass
      true (or an object, see the code for some options) as second
      argument to get "pretty" (indented) code.

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2010 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

var jsp = require("./parse-js"),
    curry = jsp.curry,
    slice = jsp.slice,
    member = jsp.member,
    is_identifier_char = jsp.is_identifier_char,
    PRECEDENCE = jsp.PRECEDENCE,
    OPERATORS = jsp.OPERATORS;

/* -----[ helper for AST traversal ]----- */

function ast_walker() {
    function _vardefs(defs) {
        return [ this[0], MAP(defs, function(def){
            var a = [ def[0] ];
            if (def.length > 1)
                a[1] = walk(def[1]);
            return a;
        }) ];
    };
    function _block(statements) {
        var out = [ this[0] ];
        if (statements != null)
            out.push(MAP(statements, walk));
        return out;
    };
    var walkers = {
        "string": function(str) {
            return [ this[0], str ];
        },
        "num": function(num) {
            return [ this[0], num ];
        },
        "name": function(name) {
            return [ this[0], name ];
        },
        "toplevel": function(statements) {
            return [ this[0], MAP(statements, walk) ];
        },
        "block": _block,
        "splice": _block,
        "var": _vardefs,
        "const": _vardefs,
        "try": function(t, c, f) {
            return [
                this[0],
                MAP(t, walk),
                c != null ? [ c[0], MAP(c[1], walk) ] : null,
                f != null ? MAP(f, walk) : null
            ];
        },
        "throw": function(expr) {
            return [ this[0], walk(expr) ];
        },
        "new": function(ctor, args) {
            return [ this[0], walk(ctor), MAP(args, walk) ];
        },
        "switch": function(expr, body) {
            return [ this[0], walk(expr), MAP(body, function(branch){
                return [ branch[0] ? walk(branch[0]) : null,
                         MAP(branch[1], walk) ];
            }) ];
        },
        "break": function(label) {
            return [ this[0], label ];
        },
        "continue": function(label) {
            return [ this[0], label ];
        },
        "conditional": function(cond, t, e) {
            return [ this[0], walk(cond), walk(t), walk(e) ];
        },
        "assign": function(op, lvalue, rvalue) {
            return [ this[0], op, walk(lvalue), walk(rvalue) ];
        },
        "dot": function(expr) {
            return [ this[0], walk(expr) ].concat(slice(arguments, 1));
        },
        "call": function(expr, args) {
            return [ this[0], walk(expr), MAP(args, walk) ];
        },
        "function": function(name, args, body) {
            return [ this[0], name, args.slice(), MAP(body, walk) ];
        },
        "debugger": function() {
            return [ this[0] ];
        },
        "defun": function(name, args, body) {
            return [ this[0], name, args.slice(), MAP(body, walk) ];
        },
        "if": function(conditional, t, e) {
            return [ this[0], walk(conditional), walk(t), walk(e) ];
        },
        "for": function(init, cond, step, block) {
            return [ this[0], walk(init), walk(cond), walk(step), walk(block) ];
        },
        "for-in": function(vvar, key, hash, block) {
            return [ this[0], walk(vvar), walk(key), walk(hash), walk(block) ];
        },
        "while": function(cond, block) {
            return [ this[0], walk(cond), walk(block) ];
        },
        "do": function(cond, block) {
            return [ this[0], walk(cond), walk(block) ];
        },
        "return": function(expr) {
            return [ this[0], walk(expr) ];
        },
        "binary": function(op, left, right) {
            return [ this[0], op, walk(left), walk(right) ];
        },
        "unary-prefix": function(op, expr) {
            return [ this[0], op, walk(expr) ];
        },
        "unary-postfix": function(op, expr) {
            return [ this[0], op, walk(expr) ];
        },
        "sub": function(expr, subscript) {
            return [ this[0], walk(expr), walk(subscript) ];
        },
        "object": function(props) {
            return [ this[0], MAP(props, function(p){
                return p.length == 2
                    ? [ p[0], walk(p[1]) ]
                    : [ p[0], walk(p[1]), p[2] ]; // get/set-ter
            }) ];
        },
        "regexp": function(rx, mods) {
            return [ this[0], rx, mods ];
        },
        "array": function(elements) {
            return [ this[0], MAP(elements, walk) ];
        },
        "stat": function(stat) {
            return [ this[0], walk(stat) ];
        },
        "seq": function() {
            return [ this[0] ].concat(MAP(slice(arguments), walk));
        },
        "label": function(name, block) {
            return [ this[0], name, walk(block) ];
        },
        "with": function(expr, block) {
            return [ this[0], walk(expr), walk(block) ];
        },
        "atom": function(name) {
            return [ this[0], name ];
        },
        "directive": function(dir) {
            return [ this[0], dir ];
        }
    };

    var user = {};
    var stack = [];
    function walk(ast) {
        if (ast == null)
            return null;
        try {
            stack.push(ast);
            var type = ast[0];
            var gen = user[type];
            if (gen) {
                var ret = gen.apply(ast, ast.slice(1));
                if (ret != null)
                    return ret;
            }
            gen = walkers[type];
            return gen.apply(ast, ast.slice(1));
        } finally {
            stack.pop();
        }
    };

    function dive(ast) {
        if (ast == null)
            return null;
        try {
            stack.push(ast);
            return walkers[ast[0]].apply(ast, ast.slice(1));
        } finally {
            stack.pop();
        }
    };

    function with_walkers(walkers, cont){
        var save = {}, i;
        for (i in walkers) if (HOP(walkers, i)) {
            save[i] = user[i];
            user[i] = walkers[i];
        }
        var ret = cont();
        for (i in save) if (HOP(save, i)) {
            if (!save[i]) delete user[i];
            else user[i] = save[i];
        }
        return ret;
    };

    return {
        walk: walk,
        dive: dive,
        with_walkers: with_walkers,
        parent: function() {
            return stack[stack.length - 2]; // last one is current node
        },
        stack: function() {
            return stack;
        }
    };
};

/* -----[ Scope and mangling ]----- */

function Scope(parent) {
    this.names = {};        // names defined in this scope
    this.mangled = {};      // mangled names (orig.name => mangled)
    this.rev_mangled = {};  // reverse lookup (mangled => orig.name)
    this.cname = -1;        // current mangled name
    this.refs = {};         // names referenced from this scope
    this.uses_with = false; // will become TRUE if with() is detected in this or any subscopes
    this.uses_eval = false; // will become TRUE if eval() is detected in this or any subscopes
    this.directives = [];   // directives activated from this scope
    this.parent = parent;   // parent scope
    this.children = [];     // sub-scopes
    if (parent) {
        this.level = parent.level + 1;
        parent.children.push(this);
    } else {
        this.level = 0;
    }
};

function base54_digits() {
    if (typeof DIGITS_OVERRIDE_FOR_TESTING != "undefined")
        return DIGITS_OVERRIDE_FOR_TESTING;
    else
        return "etnrisouaflchpdvmgybwESxTNCkLAOM_DPHBjFIqRUzWXV$JKQGYZ0516372984";
}

var base54 = (function(){
    var DIGITS = base54_digits();
    return function(num) {
        var ret = "", base = 54;
        do {
            ret += DIGITS.charAt(num % base);
            num = Math.floor(num / base);
            base = 64;
        } while (num > 0);
        return ret;
    };
})();

Scope.prototype = {
    has: function(name) {
        for (var s = this; s; s = s.parent)
            if (HOP(s.names, name))
                return s;
    },
    has_mangled: function(mname) {
        for (var s = this; s; s = s.parent)
            if (HOP(s.rev_mangled, mname))
                return s;
    },
    toJSON: function() {
        return {
            names: this.names,
            uses_eval: this.uses_eval,
            uses_with: this.uses_with
        };
    },

    next_mangled: function() {
        // we must be careful that the new mangled name:
        //
        // 1. doesn't shadow a mangled name from a parent
        //    scope, unless we don't reference the original
        //    name from this scope OR from any sub-scopes!
        //    This will get slow.
        //
        // 2. doesn't shadow an original name from a parent
        //    scope, in the event that the name is not mangled
        //    in the parent scope and we reference that name
        //    here OR IN ANY SUBSCOPES!
        //
        // 3. doesn't shadow a name that is referenced but not
        //    defined (possibly global defined elsewhere).
        for (;;) {
            var m = base54(++this.cname), prior;

            // case 1.
            prior = this.has_mangled(m);
            if (prior && this.refs[prior.rev_mangled[m]] === prior)
                continue;

            // case 2.
            prior = this.has(m);
            if (prior && prior !== this && this.refs[m] === prior && !prior.has_mangled(m))
                continue;

            // case 3.
            if (HOP(this.refs, m) && this.refs[m] == null)
                continue;

            // I got "do" once. :-/
            if (!is_identifier(m))
                continue;

            return m;
        }
    },
    set_mangle: function(name, m) {
        this.rev_mangled[m] = name;
        return this.mangled[name] = m;
    },
    get_mangled: function(name, newMangle) {
        if (this.uses_eval || this.uses_with) return name; // no mangle if eval or with is in use
        var s = this.has(name);
        if (!s) return name; // not in visible scope, no mangle
        if (HOP(s.mangled, name)) return s.mangled[name]; // already mangled in this scope
        if (!newMangle) return name;                      // not found and no mangling requested
        return s.set_mangle(name, s.next_mangled());
    },
    references: function(name) {
        return name && !this.parent || this.uses_with || this.uses_eval || this.refs[name];
    },
    define: function(name, type) {
        if (name != null) {
            if (type == "var" || !HOP(this.names, name))
                this.names[name] = type || "var";
            return name;
        }
    },
    active_directive: function(dir) {
        return member(dir, this.directives) || this.parent && this.parent.active_directive(dir);
    }
};

function ast_add_scope(ast) {

    var current_scope = null;
    var w = ast_walker(), walk = w.walk;
    var having_eval = [];

    function with_new_scope(cont) {
        current_scope = new Scope(current_scope);
        current_scope.labels = new Scope();
        var ret = current_scope.body = cont();
        ret.scope = current_scope;
        current_scope = current_scope.parent;
        return ret;
    };

    function define(name, type) {
        return current_scope.define(name, type);
    };

    function reference(name) {
        current_scope.refs[name] = true;
    };

    function _lambda(name, args, body) {
        var is_defun = this[0] == "defun";
        return [ this[0], is_defun ? define(name, "defun") : name, args, with_new_scope(function(){
            if (!is_defun) define(name, "lambda");
            MAP(args, function(name){ define(name, "arg") });
            return MAP(body, walk);
        })];
    };

    function _vardefs(type) {
        return function(defs) {
            MAP(defs, function(d){
                define(d[0], type);
                if (d[1]) reference(d[0]);
            });
        };
    };

    function _breacont(label) {
        if (label)
            current_scope.labels.refs[label] = true;
    };

    return with_new_scope(function(){
        // process AST
        var ret = w.with_walkers({
            "function": _lambda,
            "defun": _lambda,
            "label": function(name, stat) { current_scope.labels.define(name) },
            "break": _breacont,
            "continue": _breacont,
            "with": function(expr, block) {
                for (var s = current_scope; s; s = s.parent)
                    s.uses_with = true;
            },
            "var": _vardefs("var"),
            "const": _vardefs("const"),
            "try": function(t, c, f) {
                if (c != null) return [
                    this[0],
                    MAP(t, walk),
                    [ define(c[0], "catch"), MAP(c[1], walk) ],
                    f != null ? MAP(f, walk) : null
                ];
            },
            "name": function(name) {
                if (name == "eval")
                    having_eval.push(current_scope);
                reference(name);
            }
        }, function(){
            return walk(ast);
        });

        // the reason why we need an additional pass here is
        // that names can be used prior to their definition.

        // scopes where eval was detected and their parents
        // are marked with uses_eval, unless they define the
        // "eval" name.
        MAP(having_eval, function(scope){
            if (!scope.has("eval")) while (scope) {
                scope.uses_eval = true;
                scope = scope.parent;
            }
        });

        // for referenced names it might be useful to know
        // their origin scope.  current_scope here is the
        // toplevel one.
        function fixrefs(scope, i) {
            // do children first; order shouldn't matter
            for (i = scope.children.length; --i >= 0;)
                fixrefs(scope.children[i]);
            for (i in scope.refs) if (HOP(scope.refs, i)) {
                // find origin scope and propagate the reference to origin
                for (var origin = scope.has(i), s = scope; s; s = s.parent) {
                    s.refs[i] = origin;
                    if (s === origin) break;
                }
            }
        };
        fixrefs(current_scope);

        return ret;
    });

};

/* -----[ mangle names ]----- */

function ast_mangle(ast, options) {
    var w = ast_walker(), walk = w.walk, scope;
    options = defaults(options, {
        mangle       : true,
        toplevel     : false,
        defines      : null,
        except       : null,
        no_functions : false
    });

    function get_mangled(name, newMangle) {
        if (!options.mangle) return name;
        if (!options.toplevel && !scope.parent) return name; // don't mangle toplevel
        if (options.except && member(name, options.except))
            return name;
        if (options.no_functions && HOP(scope.names, name) &&
            (scope.names[name] == 'defun' || scope.names[name] == 'lambda'))
            return name;
        return scope.get_mangled(name, newMangle);
    };

    function get_define(name) {
        if (options.defines) {
            // we always lookup a defined symbol for the current scope FIRST, so declared
            // vars trump a DEFINE symbol, but if no such var is found, then match a DEFINE value
            if (!scope.has(name)) {
                if (HOP(options.defines, name)) {
                    return options.defines[name];
                }
            }
            return null;
        }
    };

    function _lambda(name, args, body) {
        if (!options.no_functions && options.mangle) {
            var is_defun = this[0] == "defun", extra;
            if (name) {
                if (is_defun) name = get_mangled(name);
                else if (body.scope.references(name)) {
                    extra = {};
                    if (!(scope.uses_eval || scope.uses_with))
                        name = extra[name] = scope.next_mangled();
                    else
                        extra[name] = name;
                }
                else name = null;
            }
        }
        body = with_scope(body.scope, function(){
            args = MAP(args, function(name){ return get_mangled(name) });
            return MAP(body, walk);
        }, extra);
        return [ this[0], name, args, body ];
    };

    function with_scope(s, cont, extra) {
        var _scope = scope;
        scope = s;
        if (extra) for (var i in extra) if (HOP(extra, i)) {
            s.set_mangle(i, extra[i]);
        }
        for (var i in s.names) if (HOP(s.names, i)) {
            get_mangled(i, true);
        }
        var ret = cont();
        ret.scope = s;
        scope = _scope;
        return ret;
    };

    function _vardefs(defs) {
        return [ this[0], MAP(defs, function(d){
            return [ get_mangled(d[0]), walk(d[1]) ];
        }) ];
    };

    function _breacont(label) {
        if (label) return [ this[0], scope.labels.get_mangled(label) ];
    };

    return w.with_walkers({
        "function": _lambda,
        "defun": function() {
            // move function declarations to the top when
            // they are not in some block.
            var ast = _lambda.apply(this, arguments);
            switch (w.parent()[0]) {
              case "toplevel":
              case "function":
              case "defun":
                return MAP.at_top(ast);
            }
            return ast;
        },
        "label": function(label, stat) {
            if (scope.labels.refs[label]) return [
                this[0],
                scope.labels.get_mangled(label, true),
                walk(stat)
            ];
            return walk(stat);
        },
        "break": _breacont,
        "continue": _breacont,
        "var": _vardefs,
        "const": _vardefs,
        "name": function(name) {
            return get_define(name) || [ this[0], get_mangled(name) ];
        },
        "try": function(t, c, f) {
            return [ this[0],
                     MAP(t, walk),
                     c != null ? [ get_mangled(c[0]), MAP(c[1], walk) ] : null,
                     f != null ? MAP(f, walk) : null ];
        },
        "toplevel": function(body) {
            var self = this;
            return with_scope(self.scope, function(){
                return [ self[0], MAP(body, walk) ];
            });
        },
        "directive": function() {
            return MAP.at_top(this);
        }
    }, function() {
        return walk(ast_add_scope(ast));
    });
};

/* -----[
   - compress foo["bar"] into foo.bar,
   - remove block brackets {} where possible
   - join consecutive var declarations
   - various optimizations for IFs:
   - if (cond) foo(); else bar();  ==>  cond?foo():bar();
   - if (cond) foo();  ==>  cond&&foo();
   - if (foo) return bar(); else return baz();  ==> return foo?bar():baz(); // also for throw
   - if (foo) return bar(); else something();  ==> {if(foo)return bar();something()}
   ]----- */

var warn = function(){};

function best_of(ast1, ast2) {
    return gen_code(ast1).length > gen_code(ast2[0] == "stat" ? ast2[1] : ast2).length ? ast2 : ast1;
};

function last_stat(b) {
    if (b[0] == "block" && b[1] && b[1].length > 0)
        return b[1][b[1].length - 1];
    return b;
}

function aborts(t) {
    if (t) switch (last_stat(t)[0]) {
      case "return":
      case "break":
      case "continue":
      case "throw":
        return true;
    }
};

function boolean_expr(expr) {
    return ( (expr[0] == "unary-prefix"
              && member(expr[1], [ "!", "delete" ])) ||

             (expr[0] == "binary"
              && member(expr[1], [ "in", "instanceof", "==", "!=", "===", "!==", "<", "<=", ">=", ">" ])) ||

             (expr[0] == "binary"
              && member(expr[1], [ "&&", "||" ])
              && boolean_expr(expr[2])
              && boolean_expr(expr[3])) ||

             (expr[0] == "conditional"
              && boolean_expr(expr[2])
              && boolean_expr(expr[3])) ||

             (expr[0] == "assign"
              && expr[1] === true
              && boolean_expr(expr[3])) ||

             (expr[0] == "seq"
              && boolean_expr(expr[expr.length - 1]))
           );
};

function empty(b) {
    return !b || (b[0] == "block" && (!b[1] || b[1].length == 0));
};

function is_string(node) {
    return (node[0] == "string" ||
            node[0] == "unary-prefix" && node[1] == "typeof" ||
            node[0] == "binary" && node[1] == "+" &&
            (is_string(node[2]) || is_string(node[3])));
};

var when_constant = (function(){

    var $NOT_CONSTANT = {};

    // this can only evaluate constant expressions.  If it finds anything
    // not constant, it throws $NOT_CONSTANT.
    function evaluate(expr) {
        switch (expr[0]) {
          case "string":
          case "num":
            return expr[1];
          case "name":
          case "atom":
            switch (expr[1]) {
              case "true": return true;
              case "false": return false;
              case "null": return null;
            }
            break;
          case "unary-prefix":
            switch (expr[1]) {
              case "!": return !evaluate(expr[2]);
              case "typeof": return typeof evaluate(expr[2]);
              case "~": return ~evaluate(expr[2]);
              case "-": return -evaluate(expr[2]);
              case "+": return +evaluate(expr[2]);
            }
            break;
          case "binary":
            var left = expr[2], right = expr[3];
            switch (expr[1]) {
              case "&&"         : return evaluate(left) &&         evaluate(right);
              case "||"         : return evaluate(left) ||         evaluate(right);
              case "|"          : return evaluate(left) |          evaluate(right);
              case "&"          : return evaluate(left) &          evaluate(right);
              case "^"          : return evaluate(left) ^          evaluate(right);
              case "+"          : return evaluate(left) +          evaluate(right);
              case "*"          : return evaluate(left) *          evaluate(right);
              case "/"          : return evaluate(left) /          evaluate(right);
              case "%"          : return evaluate(left) %          evaluate(right);
              case "-"          : return evaluate(left) -          evaluate(right);
              case "<<"         : return evaluate(left) <<         evaluate(right);
              case ">>"         : return evaluate(left) >>         evaluate(right);
              case ">>>"        : return evaluate(left) >>>        evaluate(right);
              case "=="         : return evaluate(left) ==         evaluate(right);
              case "==="        : return evaluate(left) ===        evaluate(right);
              case "!="         : return evaluate(left) !=         evaluate(right);
              case "!=="        : return evaluate(left) !==        evaluate(right);
              case "<"          : return evaluate(left) <          evaluate(right);
              case "<="         : return evaluate(left) <=         evaluate(right);
              case ">"          : return evaluate(left) >          evaluate(right);
              case ">="         : return evaluate(left) >=         evaluate(right);
              case "in"         : return evaluate(left) in         evaluate(right);
              case "instanceof" : return evaluate(left) instanceof evaluate(right);
            }
        }
        throw $NOT_CONSTANT;
    };

    return function(expr, yes, no) {
        try {
            var val = evaluate(expr), ast;
            switch (typeof val) {
              case "string": ast =  [ "string", val ]; break;
              case "number": ast =  [ "num", val ]; break;
              case "boolean": ast =  [ "name", String(val) ]; break;
              default:
                if (val === null) { ast = [ "atom", "null" ]; break; }
                throw new Error("Can't handle constant of type: " + (typeof val));
            }
            return yes.call(expr, ast, val);
        } catch(ex) {
            if (ex === $NOT_CONSTANT) {
                if (expr[0] == "binary"
                    && (expr[1] == "===" || expr[1] == "!==")
                    && ((is_string(expr[2]) && is_string(expr[3]))
                        || (boolean_expr(expr[2]) && boolean_expr(expr[3])))) {
                    expr[1] = expr[1].substr(0, 2);
                }
                else if (no && expr[0] == "binary"
                         && (expr[1] == "||" || expr[1] == "&&")) {
                    // the whole expression is not constant but the lval may be...
                    try {
                        var lval = evaluate(expr[2]);
                        expr = ((expr[1] == "&&" && (lval ? expr[3] : lval))    ||
                                (expr[1] == "||" && (lval ? lval    : expr[3])) ||
                                expr);
                    } catch(ex2) {
                        // IGNORE... lval is not constant
                    }
                }
                return no ? no.call(expr, expr) : null;
            }
            else throw ex;
        }
    };

})();

function warn_unreachable(ast) {
    if (!empty(ast))
        warn("Dropping unreachable code: " + gen_code(ast, true));
};

function prepare_ifs(ast) {
    var w = ast_walker(), walk = w.walk;
    // In this first pass, we rewrite ifs which abort with no else with an
    // if-else.  For example:
    //
    // if (x) {
    //     blah();
    //     return y;
    // }
    // foobar();
    //
    // is rewritten into:
    //
    // if (x) {
    //     blah();
    //     return y;
    // } else {
    //     foobar();
    // }
    function redo_if(statements) {
        statements = MAP(statements, walk);

        for (var i = 0; i < statements.length; ++i) {
            var fi = statements[i];
            if (fi[0] != "if") continue;

            if (fi[3]) continue;

            var t = fi[2];
            if (!aborts(t)) continue;

            var conditional = walk(fi[1]);

            var e_body = redo_if(statements.slice(i + 1));
            var e = e_body.length == 1 ? e_body[0] : [ "block", e_body ];

            return statements.slice(0, i).concat([ [
                fi[0],          // "if"
                conditional,    // conditional
                t,              // then
                e               // else
            ] ]);
        }

        return statements;
    };

    function redo_if_lambda(name, args, body) {
        body = redo_if(body);
        return [ this[0], name, args, body ];
    };

    function redo_if_block(statements) {
        return [ this[0], statements != null ? redo_if(statements) : null ];
    };

    return w.with_walkers({
        "defun": redo_if_lambda,
        "function": redo_if_lambda,
        "block": redo_if_block,
        "splice": redo_if_block,
        "toplevel": function(statements) {
            return [ this[0], redo_if(statements) ];
        },
        "try": function(t, c, f) {
            return [
                this[0],
                redo_if(t),
                c != null ? [ c[0], redo_if(c[1]) ] : null,
                f != null ? redo_if(f) : null
            ];
        }
    }, function() {
        return walk(ast);
    });
};

function for_side_effects(ast, handler) {
    var w = ast_walker(), walk = w.walk;
    var $stop = {}, $restart = {};
    function stop() { throw $stop };
    function restart() { throw $restart };
    function found(){ return handler.call(this, this, w, stop, restart) };
    function unary(op) {
        if (op == "++" || op == "--")
            return found.apply(this, arguments);
    };
    function binary(op) {
        if (op == "&&" || op == "||")
            return found.apply(this, arguments);
    };
    return w.with_walkers({
        "try": found,
        "throw": found,
        "return": found,
        "new": found,
        "switch": found,
        "break": found,
        "continue": found,
        "assign": found,
        "call": found,
        "if": found,
        "for": found,
        "for-in": found,
        "while": found,
        "do": found,
        "return": found,
        "unary-prefix": unary,
        "unary-postfix": unary,
        "conditional": found,
        "binary": binary,
        "defun": found
    }, function(){
        while (true) try {
            walk(ast);
            break;
        } catch(ex) {
            if (ex === $stop) break;
            if (ex === $restart) continue;
            throw ex;
        }
    });
};

function ast_lift_variables(ast) {
    var w = ast_walker(), walk = w.walk, scope;
    function do_body(body, env) {
        var _scope = scope;
        scope = env;
        body = MAP(body, walk);
        var hash = {}, names = MAP(env.names, function(type, name){
            if (type != "var") return MAP.skip;
            if (!env.references(name)) return MAP.skip;
            hash[name] = true;
            return [ name ];
        });
        if (names.length > 0) {
            // looking for assignments to any of these variables.
            // we can save considerable space by moving the definitions
            // in the var declaration.
            for_side_effects([ "block", body ], function(ast, walker, stop, restart) {
                if (ast[0] == "assign"
                    && ast[1] === true
                    && ast[2][0] == "name"
                    && HOP(hash, ast[2][1])) {
                    // insert the definition into the var declaration
                    for (var i = names.length; --i >= 0;) {
                        if (names[i][0] == ast[2][1]) {
                            if (names[i][1]) // this name already defined, we must stop
                                stop();
                            names[i][1] = ast[3]; // definition
                            names.push(names.splice(i, 1)[0]);
                            break;
                        }
                    }
                    // remove this assignment from the AST.
                    var p = walker.parent();
                    if (p[0] == "seq") {
                        var a = p[2];
                        a.unshift(0, p.length);
                        p.splice.apply(p, a);
                    }
                    else if (p[0] == "stat") {
                        p.splice(0, p.length, "block"); // empty statement
                    }
                    else {
                        stop();
                    }
                    restart();
                }
                stop();
            });
            body.unshift([ "var", names ]);
        }
        scope = _scope;
        return body;
    };
    function _vardefs(defs) {
        var ret = null;
        for (var i = defs.length; --i >= 0;) {
            var d = defs[i];
            if (!d[1]) continue;
            d = [ "assign", true, [ "name", d[0] ], d[1] ];
            if (ret == null) ret = d;
            else ret = [ "seq", d, ret ];
        }
        if (ret == null && w.parent()[0] != "for") {
            if (w.parent()[0] == "for-in")
                return [ "name", defs[0][0] ];
            return MAP.skip;
        }
        return [ "stat", ret ];
    };
    function _toplevel(body) {
        return [ this[0], do_body(body, this.scope) ];
    };
    return w.with_walkers({
        "function": function(name, args, body){
            for (var i = args.length; --i >= 0 && !body.scope.references(args[i]);)
                args.pop();
            if (!body.scope.references(name)) name = null;
            return [ this[0], name, args, do_body(body, body.scope) ];
        },
        "defun": function(name, args, body){
            if (!scope.references(name)) return MAP.skip;
            for (var i = args.length; --i >= 0 && !body.scope.references(args[i]);)
                args.pop();
            return [ this[0], name, args, do_body(body, body.scope) ];
        },
        "var": _vardefs,
        "toplevel": _toplevel
    }, function(){
        return walk(ast_add_scope(ast));
    });
};

function ast_squeeze(ast, options) {
    ast = squeeze_1(ast, options);
    ast = squeeze_2(ast, options);
    return ast;
};

function squeeze_1(ast, options) {
    options = defaults(options, {
        make_seqs   : true,
        dead_code   : true,
        no_warnings : false,
        keep_comps  : true,
        unsafe      : false
    });

    var w = ast_walker(), walk = w.walk, scope;

    function negate(c) {
        var not_c = [ "unary-prefix", "!", c ];
        switch (c[0]) {
          case "unary-prefix":
            return c[1] == "!" && boolean_expr(c[2]) ? c[2] : not_c;
          case "seq":
            c = slice(c);
            c[c.length - 1] = negate(c[c.length - 1]);
            return c;
          case "conditional":
            return best_of(not_c, [ "conditional", c[1], negate(c[2]), negate(c[3]) ]);
          case "binary":
            var op = c[1], left = c[2], right = c[3];
            if (!options.keep_comps) switch (op) {
              case "<="  : return [ "binary", ">", left, right ];
              case "<"   : return [ "binary", ">=", left, right ];
              case ">="  : return [ "binary", "<", left, right ];
              case ">"   : return [ "binary", "<=", left, right ];
            }
            switch (op) {
              case "=="  : return [ "binary", "!=", left, right ];
              case "!="  : return [ "binary", "==", left, right ];
              case "===" : return [ "binary", "!==", left, right ];
              case "!==" : return [ "binary", "===", left, right ];
              case "&&"  : return best_of(not_c, [ "binary", "||", negate(left), negate(right) ]);
              case "||"  : return best_of(not_c, [ "binary", "&&", negate(left), negate(right) ]);
            }
            break;
        }
        return not_c;
    };

    function make_conditional(c, t, e) {
        var make_real_conditional = function() {
            if (c[0] == "unary-prefix" && c[1] == "!") {
                return e ? [ "conditional", c[2], e, t ] : [ "binary", "||", c[2], t ];
            } else {
                return e ? best_of(
                    [ "conditional", c, t, e ],
                    [ "conditional", negate(c), e, t ]
                ) : [ "binary", "&&", c, t ];
            }
        };
        // shortcut the conditional if the expression has a constant value
        return when_constant(c, function(ast, val){
            warn_unreachable(val ? e : t);
            return          (val ? t : e);
        }, make_real_conditional);
    };

    function rmblock(block) {
        if (block != null && block[0] == "block" && block[1]) {
            if (block[1].length == 1)
                block = block[1][0];
            else if (block[1].length == 0)
                block = [ "block" ];
        }
        return block;
    };

    function _lambda(name, args, body) {
        return [ this[0], name, args, tighten(body, "lambda") ];
    };

    // this function does a few things:
    // 1. discard useless blocks
    // 2. join consecutive var declarations
    // 3. remove obviously dead code
    // 4. transform consecutive statements using the comma operator
    // 5. if block_type == "lambda" and it detects constructs like if(foo) return ... - rewrite like if (!foo) { ... }
    function tighten(statements, block_type) {
        statements = MAP(statements, walk);

        statements = statements.reduce(function(a, stat){
            if (stat[0] == "block") {
                if (stat[1]) {
                    a.push.apply(a, stat[1]);
                }
            } else {
                a.push(stat);
            }
            return a;
        }, []);

        statements = (function(a, prev){
            statements.forEach(function(cur){
                if (prev && ((cur[0] == "var" && prev[0] == "var") ||
                             (cur[0] == "const" && prev[0] == "const"))) {
                    prev[1] = prev[1].concat(cur[1]);
                } else {
                    a.push(cur);
                    prev = cur;
                }
            });
            return a;
        })([]);

        if (options.dead_code) statements = (function(a, has_quit){
            statements.forEach(function(st){
                if (has_quit) {
                    if (st[0] == "function" || st[0] == "defun") {
                        a.push(st);
                    }
                    else if (st[0] == "var" || st[0] == "const") {
                        if (!options.no_warnings)
                            warn("Variables declared in unreachable code");
                        st[1] = MAP(st[1], function(def){
                            if (def[1] && !options.no_warnings)
                                warn_unreachable([ "assign", true, [ "name", def[0] ], def[1] ]);
                            return [ def[0] ];
                        });
                        a.push(st);
                    }
                    else if (!options.no_warnings)
                        warn_unreachable(st);
                }
                else {
                    a.push(st);
                    if (member(st[0], [ "return", "throw", "break", "continue" ]))
                        has_quit = true;
                }
            });
            return a;
        })([]);

        if (options.make_seqs) statements = (function(a, prev) {
            statements.forEach(function(cur){
                if (prev && prev[0] == "stat" && cur[0] == "stat") {
                    prev[1] = [ "seq", prev[1], cur[1] ];
                } else {
                    a.push(cur);
                    prev = cur;
                }
            });
            if (a.length >= 2
                && a[a.length-2][0] == "stat"
                && (a[a.length-1][0] == "return" || a[a.length-1][0] == "throw")
                && a[a.length-1][1])
            {
                a.splice(a.length - 2, 2,
                         [ a[a.length-1][0],
                           [ "seq", a[a.length-2][1], a[a.length-1][1] ]]);
            }
            return a;
        })([]);

        // this increases jQuery by 1K.  Probably not such a good idea after all..
        // part of this is done in prepare_ifs anyway.
        // if (block_type == "lambda") statements = (function(i, a, stat){
        //         while (i < statements.length) {
        //                 stat = statements[i++];
        //                 if (stat[0] == "if" && !stat[3]) {
        //                         if (stat[2][0] == "return" && stat[2][1] == null) {
        //                                 a.push(make_if(negate(stat[1]), [ "block", statements.slice(i) ]));
        //                                 break;
        //                         }
        //                         var last = last_stat(stat[2]);
        //                         if (last[0] == "return" && last[1] == null) {
        //                                 a.push(make_if(stat[1], [ "block", stat[2][1].slice(0, -1) ], [ "block", statements.slice(i) ]));
        //                                 break;
        //                         }
        //                 }
        //                 a.push(stat);
        //         }
        //         return a;
        // })(0, []);

        return statements;
    };

    function make_if(c, t, e) {
        return when_constant(c, function(ast, val){
            if (val) {
                t = walk(t);
                warn_unreachable(e);
                return t || [ "block" ];
            } else {
                e = walk(e);
                warn_unreachable(t);
                return e || [ "block" ];
            }
        }, function() {
            return make_real_if(c, t, e);
        });
    };

    function abort_else(c, t, e) {
        var ret = [ [ "if", negate(c), e ] ];
        if (t[0] == "block") {
            if (t[1]) ret = ret.concat(t[1]);
        } else {
            ret.push(t);
        }
        return walk([ "block", ret ]);
    };

    function make_real_if(c, t, e) {
        c = walk(c);
        t = walk(t);
        e = walk(e);

        if (empty(e) && empty(t))
            return [ "stat", c ];

        if (empty(t)) {
            c = negate(c);
            t = e;
            e = null;
        } else if (empty(e)) {
            e = null;
        } else {
            // if we have both else and then, maybe it makes sense to switch them?
            (function(){
                var a = gen_code(c);
                var n = negate(c);
                var b = gen_code(n);
                if (b.length < a.length) {
                    var tmp = t;
                    t = e;
                    e = tmp;
                    c = n;
                }
            })();
        }
        var ret = [ "if", c, t, e ];
        if (t[0] == "if" && empty(t[3]) && empty(e)) {
            ret = best_of(ret, walk([ "if", [ "binary", "&&", c, t[1] ], t[2] ]));
        }
        else if (t[0] == "stat") {
            if (e) {
                if (e[0] == "stat")
                    ret = best_of(ret, [ "stat", make_conditional(c, t[1], e[1]) ]);
                else if (aborts(e))
                    ret = abort_else(c, t, e);
            }
            else {
                ret = best_of(ret, [ "stat", make_conditional(c, t[1]) ]);
            }
        }
        else if (e && t[0] == e[0] && (t[0] == "return" || t[0] == "throw") && t[1] && e[1]) {
            ret = best_of(ret, [ t[0], make_conditional(c, t[1], e[1] ) ]);
        }
        else if (e && aborts(t)) {
            ret = [ [ "if", c, t ] ];
            if (e[0] == "block") {
                if (e[1]) ret = ret.concat(e[1]);
            }
            else {
                ret.push(e);
            }
            ret = walk([ "block", ret ]);
        }
        else if (t && aborts(e)) {
            ret = abort_else(c, t, e);
        }
        return ret;
    };

    function _do_while(cond, body) {
        return when_constant(cond, function(cond, val){
            if (!val) {
                warn_unreachable(body);
                return [ "block" ];
            } else {
                return [ "for", null, null, null, walk(body) ];
            }
        });
    };

    return w.with_walkers({
        "sub": function(expr, subscript) {
            if (subscript[0] == "string") {
                var name = subscript[1];
                if (is_identifier(name))
                    return [ "dot", walk(expr), name ];
                else if (/^[1-9][0-9]*$/.test(name) || name === "0")
                    return [ "sub", walk(expr), [ "num", parseInt(name, 10) ] ];
            }
        },
        "if": make_if,
        "toplevel": function(body) {
            return [ "toplevel", tighten(body) ];
        },
        "switch": function(expr, body) {
            var last = body.length - 1;
            return [ "switch", walk(expr), MAP(body, function(branch, i){
                var block = tighten(branch[1]);
                if (i == last && block.length > 0) {
                    var node = block[block.length - 1];
                    if (node[0] == "break" && !node[1])
                        block.pop();
                }
                return [ branch[0] ? walk(branch[0]) : null, block ];
            }) ];
        },
        "function": _lambda,
        "defun": _lambda,
        "block": function(body) {
            if (body) return rmblock([ "block", tighten(body) ]);
        },
        "binary": function(op, left, right) {
            return when_constant([ "binary", op, walk(left), walk(right) ], function yes(c){
                return best_of(walk(c), this);
            }, function no() {
                return function(){
                    if(op != "==" && op != "!=") return;
                    var l = walk(left), r = walk(right);
                    if(l && l[0] == "unary-prefix" && l[1] == "!" && l[2][0] == "num")
                        left = ['num', +!l[2][1]];
                    else if (r && r[0] == "unary-prefix" && r[1] == "!" && r[2][0] == "num")
                        right = ['num', +!r[2][1]];
                    return ["binary", op, left, right];
                }() || this;
            });
        },
        "conditional": function(c, t, e) {
            return make_conditional(walk(c), walk(t), walk(e));
        },
        "try": function(t, c, f) {
            return [
                "try",
                tighten(t),
                c != null ? [ c[0], tighten(c[1]) ] : null,
                f != null ? tighten(f) : null
            ];
        },
        "unary-prefix": function(op, expr) {
            expr = walk(expr);
            var ret = [ "unary-prefix", op, expr ];
            if (op == "!")
                ret = best_of(ret, negate(expr));
            return when_constant(ret, function(ast, val){
                return walk(ast); // it's either true or false, so minifies to !0 or !1
            }, function() { return ret });
        },
        "name": function(name) {
            switch (name) {
              case "true": return [ "unary-prefix", "!", [ "num", 0 ]];
              case "false": return [ "unary-prefix", "!", [ "num", 1 ]];
            }
        },
        "while": _do_while,
        "assign": function(op, lvalue, rvalue) {
            lvalue = walk(lvalue);
            rvalue = walk(rvalue);
            var okOps = [ '+', '-', '/', '*', '%', '>>', '<<', '>>>', '|', '^', '&' ];
            if (op === true && lvalue[0] === "name" && rvalue[0] === "binary" &&
                ~okOps.indexOf(rvalue[1]) && rvalue[2][0] === "name" &&
                rvalue[2][1] === lvalue[1]) {
                return [ this[0], rvalue[1], lvalue, rvalue[3] ]
            }
            return [ this[0], op, lvalue, rvalue ];
        },
        "call": function(expr, args) {
            expr = walk(expr);
            if (options.unsafe && expr[0] == "dot" && expr[1][0] == "string" && expr[2] == "toString") {
                return expr[1];
            }
            return [ this[0], expr,  MAP(args, walk) ];
        },
        "num": function (num) {
            if (!isFinite(num))
                return [ "binary", "/", num === 1 / 0
                         ? [ "num", 1 ] : num === -1 / 0
                         ? [ "unary-prefix", "-", [ "num", 1 ] ]
                         : [ "num", 0 ], [ "num", 0 ] ];

            return [ this[0], num ];
        }
    }, function() {
        return walk(prepare_ifs(walk(prepare_ifs(ast))));
    });
};

function squeeze_2(ast, options) {
    var w = ast_walker(), walk = w.walk, scope;
    function with_scope(s, cont) {
        var save = scope, ret;
        scope = s;
        ret = cont();
        scope = save;
        return ret;
    };
    function lambda(name, args, body) {
        return [ this[0], name, args, with_scope(body.scope, curry(MAP, body, walk)) ];
    };
    return w.with_walkers({
        "directive": function(dir) {
            if (scope.active_directive(dir))
                return [ "block" ];
            scope.directives.push(dir);
        },
        "toplevel": function(body) {
            return [ this[0], with_scope(this.scope, curry(MAP, body, walk)) ];
        },
        "function": lambda,
        "defun": lambda
    }, function(){
        return walk(ast_add_scope(ast));
    });
};

/* -----[ re-generate code from the AST ]----- */

var DOT_CALL_NO_PARENS = jsp.array_to_hash([
    "name",
    "array",
    "object",
    "string",
    "dot",
    "sub",
    "call",
    "regexp",
    "defun"
]);

function make_string(str, ascii_only) {
    var dq = 0, sq = 0;
    str = str.replace(/[\\\b\f\n\r\t\x22\x27\u2028\u2029\0]/g, function(s){
        switch (s) {
          case "\\": return "\\\\";
          case "\b": return "\\b";
          case "\f": return "\\f";
          case "\n": return "\\n";
          case "\r": return "\\r";
          case "\u2028": return "\\u2028";
          case "\u2029": return "\\u2029";
          case '"': ++dq; return '"';
          case "'": ++sq; return "'";
          case "\0": return "\\0";
        }
        return s;
    });
    if (ascii_only) str = to_ascii(str);
    if (dq > sq) return "'" + str.replace(/\x27/g, "\\'") + "'";
    else return '"' + str.replace(/\x22/g, '\\"') + '"';
};

function to_ascii(str) {
    return str.replace(/[\u0080-\uffff]/g, function(ch) {
        var code = ch.charCodeAt(0).toString(16);
        while (code.length < 4) code = "0" + code;
        return "\\u" + code;
    });
};

var SPLICE_NEEDS_BRACKETS = jsp.array_to_hash([ "if", "while", "do", "for", "for-in", "with" ]);

function gen_code(ast, options) {
    options = defaults(options, {
        indent_start : 0,
        indent_level : 4,
        quote_keys   : false,
        space_colon  : false,
        beautify     : false,
        ascii_only   : false,
        inline_script: false
    });
    var beautify = !!options.beautify;
    var indentation = 0,
    newline = beautify ? "\n" : "",
    space = beautify ? " " : "";

    function encode_string(str) {
        var ret = make_string(str, options.ascii_only);
        if (options.inline_script)
            ret = ret.replace(/<\x2fscript([>\/\t\n\f\r ])/gi, "<\\/script$1");
        return ret;
    };

    function make_name(name) {
        name = name.toString();
        if (options.ascii_only)
            name = to_ascii(name);
        return name;
    };

    function indent(line) {
        if (line == null)
            line = "";
        if (beautify)
            line = repeat_string(" ", options.indent_start + indentation * options.indent_level) + line;
        return line;
    };

    function with_indent(cont, incr) {
        if (incr == null) incr = 1;
        indentation += incr;
        try { return cont.apply(null, slice(arguments, 1)); }
        finally { indentation -= incr; }
    };

    function last_char(str) {
        str = str.toString();
        return str.charAt(str.length - 1);
    };

    function first_char(str) {
        return str.toString().charAt(0);
    };

    function add_spaces(a) {
        if (beautify)
            return a.join(" ");
        var b = [];
        for (var i = 0; i < a.length; ++i) {
            var next = a[i + 1];
            b.push(a[i]);
            if (next &&
                ((is_identifier_char(last_char(a[i])) && (is_identifier_char(first_char(next))
                                                          || first_char(next) == "\\")) ||
                 (/[\+\-]$/.test(a[i].toString()) && /^[\+\-]/.test(next.toString()) ||
                 last_char(a[i]) == "/" && first_char(next) == "/"))) {
                b.push(" ");
            }
        }
        return b.join("");
    };

    function add_commas(a) {
        return a.join("," + space);
    };

    function parenthesize(expr) {
        var gen = make(expr);
        for (var i = 1; i < arguments.length; ++i) {
            var el = arguments[i];
            if ((el instanceof Function && el(expr)) || expr[0] == el)
                return "(" + gen + ")";
        }
        return gen;
    };

    function best_of(a) {
        if (a.length == 1) {
            return a[0];
        }
        if (a.length == 2) {
            var b = a[1];
            a = a[0];
            return a.length <= b.length ? a : b;
        }
        return best_of([ a[0], best_of(a.slice(1)) ]);
    };

    function needs_parens(expr) {
        if (expr[0] == "function" || expr[0] == "object") {
            // dot/call on a literal function requires the
            // function literal itself to be parenthesized
            // only if it's the first "thing" in a
            // statement.  This means that the parent is
            // "stat", but it could also be a "seq" and
            // we're the first in this "seq" and the
            // parent is "stat", and so on.  Messy stuff,
            // but it worths the trouble.
            var a = slice(w.stack()), self = a.pop(), p = a.pop();
            while (p) {
                if (p[0] == "stat") return true;
                if (((p[0] == "seq" || p[0] == "call" || p[0] == "dot" || p[0] == "sub" || p[0] == "conditional") && p[1] === self) ||
                    ((p[0] == "binary" || p[0] == "assign" || p[0] == "unary-postfix") && p[2] === self)) {
                    self = p;
                    p = a.pop();
                } else {
                    return false;
                }
            }
        }
        return !HOP(DOT_CALL_NO_PARENS, expr[0]);
    };

    function make_num(num) {
        var str = num.toString(10), a = [ str.replace(/^0\./, ".").replace('e+', 'e') ], m;
        if (Math.floor(num) === num) {
            if (num >= 0) {
                a.push("0x" + num.toString(16).toLowerCase(), // probably pointless
                       "0" + num.toString(8)); // same.
            } else {
                a.push("-0x" + (-num).toString(16).toLowerCase(), // probably pointless
                       "-0" + (-num).toString(8)); // same.
            }
            if ((m = /^(.*?)(0+)$/.exec(num))) {
                a.push(m[1] + "e" + m[2].length);
            }
        } else if ((m = /^0?\.(0+)(.*)$/.exec(num))) {
            a.push(m[2] + "e-" + (m[1].length + m[2].length),
                   str.substr(str.indexOf(".")));
        }
        return best_of(a);
    };

    var w = ast_walker();
    var make = w.walk;
    return w.with_walkers({
        "string": encode_string,
        "num": make_num,
        "name": make_name,
        "debugger": function(){ return "debugger;" },
        "toplevel": function(statements) {
            return make_block_statements(statements)
                .join(newline + newline);
        },
        "splice": function(statements) {
            var parent = w.parent();
            if (HOP(SPLICE_NEEDS_BRACKETS, parent)) {
                // we need block brackets in this case
                return make_block.apply(this, arguments);
            } else {
                return MAP(make_block_statements(statements, true),
                           function(line, i) {
                               // the first line is already indented
                               return i > 0 ? indent(line) : line;
                           }).join(newline);
            }
        },
        "block": make_block,
        "var": function(defs) {
            return "var " + add_commas(MAP(defs, make_1vardef)) + ";";
        },
        "const": function(defs) {
            return "const " + add_commas(MAP(defs, make_1vardef)) + ";";
        },
        "try": function(tr, ca, fi) {
            var out = [ "try", make_block(tr) ];
            if (ca) out.push("catch", "(" + ca[0] + ")", make_block(ca[1]));
            if (fi) out.push("finally", make_block(fi));
            return add_spaces(out);
        },
        "throw": function(expr) {
            return add_spaces([ "throw", make(expr) ]) + ";";
        },
        "new": function(ctor, args) {
            args = args.length > 0 ? "(" + add_commas(MAP(args, function(expr){
                return parenthesize(expr, "seq");
            })) + ")" : "";
            return add_spaces([ "new", parenthesize(ctor, "seq", "binary", "conditional", "assign", function(expr){
                var w = ast_walker(), has_call = {};
                try {
                    w.with_walkers({
                        "call": function() { throw has_call },
                        "function": function() { return this }
                    }, function(){
                        w.walk(expr);
                    });
                } catch(ex) {
                    if (ex === has_call)
                        return true;
                    throw ex;
                }
            }) + args ]);
        },
        "switch": function(expr, body) {
            return add_spaces([ "switch", "(" + make(expr) + ")", make_switch_block(body) ]);
        },
        "break": function(label) {
            var out = "break";
            if (label != null)
                out += " " + make_name(label);
            return out + ";";
        },
        "continue": function(label) {
            var out = "continue";
            if (label != null)
                out += " " + make_name(label);
            return out + ";";
        },
        "conditional": function(co, th, el) {
            return add_spaces([ parenthesize(co, "assign", "seq", "conditional"), "?",
                                parenthesize(th, "seq"), ":",
                                parenthesize(el, "seq") ]);
        },
        "assign": function(op, lvalue, rvalue) {
            if (op && op !== true) op += "=";
            else op = "=";
            return add_spaces([ make(lvalue), op, parenthesize(rvalue, "seq") ]);
        },
        "dot": function(expr) {
            var out = make(expr), i = 1;
            if (expr[0] == "num") {
                if (!/[a-f.]/i.test(out))
                    out += ".";
            } else if (expr[0] != "function" && needs_parens(expr))
                out = "(" + out + ")";
            while (i < arguments.length)
                out += "." + make_name(arguments[i++]);
            return out;
        },
        "call": function(func, args) {
            var f = make(func);
            // cannot simply test the first and/or the last characters in the genetic case,
            // because the called expression might look like e.g. `(x || y) && (u || v)`.
            var already_wrapped = (func[0] == "function" && f.charAt(0) == "(");
            if (!already_wrapped && needs_parens(func))
                f = "(" + f + ")";
            return f + "(" + add_commas(MAP(args, function(expr){
                return parenthesize(expr, "seq");
            })) + ")";
        },
        "function": make_function,
        "defun": make_function,
        "if": function(co, th, el) {
            var out = [ "if", "(" + make(co) + ")", el ? make_then(th) : make(th) ];
            if (el) {
                out.push("else", make(el));
            }
            return add_spaces(out);
        },
        "for": function(init, cond, step, block) {
            var out = [ "for" ];
            init = (init != null ? make(init) : "").replace(/;*\s*$/, ";" + space);
            cond = (cond != null ? make(cond) : "").replace(/;*\s*$/, ";" + space);
            step = (step != null ? make(step) : "").replace(/;*\s*$/, "");
            var args = init + cond + step;
            if (args == "; ; ") args = ";;";
            out.push("(" + args + ")", make(block));
            return add_spaces(out);
        },
        "for-in": function(vvar, key, hash, block) {
            return add_spaces([ "for", "(" +
                                (vvar ? make(vvar).replace(/;+$/, "") : make(key)),
                                "in",
                                make(hash) + ")", make(block) ]);
        },
        "while": function(condition, block) {
            return add_spaces([ "while", "(" + make(condition) + ")", make(block) ]);
        },
        "do": function(condition, block) {
            return add_spaces([ "do", make(block), "while", "(" + make(condition) + ")" ]) + ";";
        },
        "return": function(expr) {
            var out = [ "return" ];
            if (expr != null) out.push(make(expr));
            return add_spaces(out) + ";";
        },
        "binary": function(operator, lvalue, rvalue) {
            var left = make(lvalue), right = make(rvalue);
            // XXX: I'm pretty sure other cases will bite here.
            //      we need to be smarter.
            //      adding parens all the time is the safest bet.
            if (member(lvalue[0], [ "assign", "conditional", "seq" ]) ||
                lvalue[0] == "binary" && PRECEDENCE[operator] > PRECEDENCE[lvalue[1]] ||
                lvalue[0] == "function" && needs_parens(this)) {
                left = "(" + left + ")";
            }
            if (member(rvalue[0], [ "assign", "conditional", "seq" ]) ||
                rvalue[0] == "binary" && PRECEDENCE[operator] >= PRECEDENCE[rvalue[1]] &&
                !(rvalue[1] == operator && member(operator, [ "&&", "||", "*" ]))) {
                right = "(" + right + ")";
            }
            else if (!beautify && options.inline_script && (operator == "<" || operator == "<<")
                     && rvalue[0] == "regexp" && /^script/i.test(rvalue[1])) {
                right = " " + right;
            }
            return add_spaces([ left, operator, right ]);
        },
        "unary-prefix": function(operator, expr) {
            var val = make(expr);
            if (!(expr[0] == "num" || (expr[0] == "unary-prefix" && !HOP(OPERATORS, operator + expr[1])) || !needs_parens(expr)))
                val = "(" + val + ")";
            return operator + (jsp.is_alphanumeric_char(operator.charAt(0)) ? " " : "") + val;
        },
        "unary-postfix": function(operator, expr) {
            var val = make(expr);
            if (!(expr[0] == "num" || (expr[0] == "unary-postfix" && !HOP(OPERATORS, operator + expr[1])) || !needs_parens(expr)))
                val = "(" + val + ")";
            return val + operator;
        },
        "sub": function(expr, subscript) {
            var hash = make(expr);
            if (needs_parens(expr))
                hash = "(" + hash + ")";
            return hash + "[" + make(subscript) + "]";
        },
        "object": function(props) {
            var obj_needs_parens = needs_parens(this);
            if (props.length == 0)
                return obj_needs_parens ? "({})" : "{}";
            var out = "{" + newline + with_indent(function(){
                return MAP(props, function(p){
                    if (p.length == 3) {
                        // getter/setter.  The name is in p[0], the arg.list in p[1][2], the
                        // body in p[1][3] and type ("get" / "set") in p[2].
                        return indent(make_function(p[0], p[1][2], p[1][3], p[2], true));
                    }
                    var key = p[0], val = parenthesize(p[1], "seq");
                    if (options.quote_keys) {
                        key = encode_string(key);
                    } else if ((typeof key == "number" || !beautify && +key + "" == key)
                               && parseFloat(key) >= 0) {
                        key = make_num(+key);
                    } else if (!is_identifier(key)) {
                        key = encode_string(key);
                    }
                    return indent(add_spaces(beautify && options.space_colon
                                             ? [ key, ":", val ]
                                             : [ key + ":", val ]));
                }).join("," + newline);
            }) + newline + indent("}");
            return obj_needs_parens ? "(" + out + ")" : out;
        },
        "regexp": function(rx, mods) {
            if (options.ascii_only) rx = to_ascii(rx);
            return "/" + rx + "/" + mods;
        },
        "array": function(elements) {
            if (elements.length == 0) return "[]";
            return add_spaces([ "[", add_commas(MAP(elements, function(el, i){
                if (!beautify && el[0] == "atom" && el[1] == "undefined") return i === elements.length - 1 ? "," : "";
                return parenthesize(el, "seq");
            })), "]" ]);
        },
        "stat": function(stmt) {
            return stmt != null
                ? make(stmt).replace(/;*\s*$/, ";")
                : ";";
        },
        "seq": function() {
            return add_commas(MAP(slice(arguments), make));
        },
        "label": function(name, block) {
            return add_spaces([ make_name(name), ":", make(block) ]);
        },
        "with": function(expr, block) {
            return add_spaces([ "with", "(" + make(expr) + ")", make(block) ]);
        },
        "atom": function(name) {
            return make_name(name);
        },
        "directive": function(dir) {
            return make_string(dir) + ";";
        }
    }, function(){ return make(ast) });

    // The squeezer replaces "block"-s that contain only a single
    // statement with the statement itself; technically, the AST
    // is correct, but this can create problems when we output an
    // IF having an ELSE clause where the THEN clause ends in an
    // IF *without* an ELSE block (then the outer ELSE would refer
    // to the inner IF).  This function checks for this case and
    // adds the block brackets if needed.
    function make_then(th) {
        if (th == null) return ";";
        if (th[0] == "do") {
            // https://github.com/mishoo/UglifyJS/issues/#issue/57
            // IE croaks with "syntax error" on code like this:
            //     if (foo) do ... while(cond); else ...
            // we need block brackets around do/while
            return make_block([ th ]);
        }
        var b = th;
        while (true) {
            var type = b[0];
            if (type == "if") {
                if (!b[3])
                    // no else, we must add the block
                    return make([ "block", [ th ]]);
                b = b[3];
            }
            else if (type == "while" || type == "do") b = b[2];
            else if (type == "for" || type == "for-in") b = b[4];
            else break;
        }
        return make(th);
    };

    function make_function(name, args, body, keyword, no_parens) {
        var out = keyword || "function";
        if (name) {
            out += " " + make_name(name);
        }
        out += "(" + add_commas(MAP(args, make_name)) + ")";
        out = add_spaces([ out, make_block(body) ]);
        return (!no_parens && needs_parens(this)) ? "(" + out + ")" : out;
    };

    function must_has_semicolon(node) {
        switch (node[0]) {
          case "with":
          case "while":
            return empty(node[2]) || must_has_semicolon(node[2]);
          case "for":
          case "for-in":
            return empty(node[4]) || must_has_semicolon(node[4]);
          case "if":
            if (empty(node[2]) && !node[3]) return true; // `if' with empty `then' and no `else'
            if (node[3]) {
                if (empty(node[3])) return true; // `else' present but empty
                return must_has_semicolon(node[3]); // dive into the `else' branch
            }
            return must_has_semicolon(node[2]); // dive into the `then' branch
          case "directive":
            return true;
        }
    };

    function make_block_statements(statements, noindent) {
        for (var a = [], last = statements.length - 1, i = 0; i <= last; ++i) {
            var stat = statements[i];
            var code = make(stat);
            if (code != ";") {
                if (!beautify && i == last && !must_has_semicolon(stat)) {
                    code = code.replace(/;+\s*$/, "");
                }
                a.push(code);
            }
        }
        return noindent ? a : MAP(a, indent);
    };

    function make_switch_block(body) {
        var n = body.length;
        if (n == 0) return "{}";
        return "{" + newline + MAP(body, function(branch, i){
            var has_body = branch[1].length > 0, code = with_indent(function(){
                return indent(branch[0]
                              ? add_spaces([ "case", make(branch[0]) + ":" ])
                              : "default:");
            }, 0.5) + (has_body ? newline + with_indent(function(){
                return make_block_statements(branch[1]).join(newline);
            }) : "");
            if (!beautify && has_body && i < n - 1)
                code += ";";
            return code;
        }).join(newline) + newline + indent("}");
    };

    function make_block(statements) {
        if (!statements) return ";";
        if (statements.length == 0) return "{}";
        return "{" + newline + with_indent(function(){
            return make_block_statements(statements).join(newline);
        }) + newline + indent("}");
    };

    function make_1vardef(def) {
        var name = def[0], val = def[1];
        if (val != null)
            name = add_spaces([ make_name(name), "=", parenthesize(val, "seq") ]);
        return name;
    };

};

function split_lines(code, max_line_length) {
    var splits = [ 0 ];
    jsp.parse(function(){
        var next_token = jsp.tokenizer(code);
        var last_split = 0;
        var prev_token;
        function current_length(tok) {
            return tok.pos - last_split;
        };
        function split_here(tok) {
            last_split = tok.pos;
            splits.push(last_split);
        };
        function custom(){
            var tok = next_token.apply(this, arguments);
            out: {
                if (prev_token) {
                    if (prev_token.type == "keyword") break out;
                }
                if (current_length(tok) > max_line_length) {
                    switch (tok.type) {
                      case "keyword":
                      case "atom":
                      case "name":
                      case "punc":
                        split_here(tok);
                        break out;
                    }
                }
            }
            prev_token = tok;
            return tok;
        };
        custom.context = function() {
            return next_token.context.apply(this, arguments);
        };
        return custom;
    }());
    return splits.map(function(pos, i){
        return code.substring(pos, splits[i + 1] || code.length);
    }).join("\n");
};

/* -----[ Utilities ]----- */

function repeat_string(str, i) {
    if (i <= 0) return "";
    if (i == 1) return str;
    var d = repeat_string(str, i >> 1);
    d += d;
    if (i & 1) d += str;
    return d;
};

function defaults(args, defs) {
    var ret = {};
    if (args === true)
        args = {};
    for (var i in defs) if (HOP(defs, i)) {
        ret[i] = (args && HOP(args, i)) ? args[i] : defs[i];
    }
    return ret;
};

function is_identifier(name) {
    return /^[a-z_$][a-z0-9_$]*$/i.test(name)
        && name != "this"
        && !HOP(jsp.KEYWORDS_ATOM, name)
        && !HOP(jsp.RESERVED_WORDS, name)
        && !HOP(jsp.KEYWORDS, name);
};

function HOP(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
};

// some utilities

var MAP;

(function(){
    MAP = function(a, f, o) {
        var ret = [], top = [], i;
        function doit() {
            var val = f.call(o, a[i], i);
            if (val instanceof AtTop) {
                val = val.v;
                if (val instanceof Splice) {
                    top.push.apply(top, val.v);
                } else {
                    top.push(val);
                }
            }
            else if (val != skip) {
                if (val instanceof Splice) {
                    ret.push.apply(ret, val.v);
                } else {
                    ret.push(val);
                }
            }
        };
        if (a instanceof Array) for (i = 0; i < a.length; ++i) doit();
        else for (i in a) if (HOP(a, i)) doit();
        return top.concat(ret);
    };
    MAP.at_top = function(val) { return new AtTop(val) };
    MAP.splice = function(val) { return new Splice(val) };
    var skip = MAP.skip = {};
    function AtTop(val) { this.v = val };
    function Splice(val) { this.v = val };
})();

/* -----[ Exports ]----- */

exports.ast_walker = ast_walker;
exports.ast_mangle = ast_mangle;
exports.ast_squeeze = ast_squeeze;
exports.ast_lift_variables = ast_lift_variables;
exports.gen_code = gen_code;
exports.ast_add_scope = ast_add_scope;
exports.set_logger = function(logger) { warn = logger };
exports.make_string = make_string;
exports.split_lines = split_lines;
exports.MAP = MAP;

// keep this last!
exports.ast_squeeze_more = require("./squeeze-more").ast_squeeze_more;

// Local variables:
// js-indent-level: 4
// End:

})()
},{"./parse-js":121,"./squeeze-more":123}],123:[function(require,module,exports){
(function(){var jsp = require("./parse-js"),
    pro = require("./process"),
    slice = jsp.slice,
    member = jsp.member,
    curry = jsp.curry,
    MAP = pro.MAP,
    PRECEDENCE = jsp.PRECEDENCE,
    OPERATORS = jsp.OPERATORS;

function ast_squeeze_more(ast) {
    var w = pro.ast_walker(), walk = w.walk, scope;
    function with_scope(s, cont) {
        var save = scope, ret;
        scope = s;
        ret = cont();
        scope = save;
        return ret;
    };
    function _lambda(name, args, body) {
        return [ this[0], name, args, with_scope(body.scope, curry(MAP, body, walk)) ];
    };
    return w.with_walkers({
        "toplevel": function(body) {
            return [ this[0], with_scope(this.scope, curry(MAP, body, walk)) ];
        },
        "function": _lambda,
        "defun": _lambda,
        "new": function(ctor, args) {
            if (ctor[0] == "name") {
                if (ctor[1] == "Array" && !scope.has("Array")) {
                    if (args.length != 1) {
                        return [ "array", args ];
                    } else {
                        return walk([ "call", [ "name", "Array" ], args ]);
                    }
                } else if (ctor[1] == "Object" && !scope.has("Object")) {
                    if (!args.length) {
                        return [ "object", [] ];
                    } else {
                        return walk([ "call", [ "name", "Object" ], args ]);
                    }
                } else if ((ctor[1] == "RegExp" || ctor[1] == "Function" || ctor[1] == "Error") && !scope.has(ctor[1])) {
                    return walk([ "call", [ "name", ctor[1] ], args]);
                }
            }
        },
        "call": function(expr, args) {
            if (expr[0] == "dot" && expr[1][0] == "string" && args.length == 1
                && (args[0][1] > 0 && expr[2] == "substring" || expr[2] == "substr")) {
                return [ "call", [ "dot", expr[1], "slice"], args];
            }
            if (expr[0] == "dot" && expr[2] == "toString" && args.length == 0) {
                // foo.toString()  ==>  foo+""
                if (expr[1][0] == "string") return expr[1];
                return [ "binary", "+", expr[1], [ "string", "" ]];
            }
            if (expr[0] == "name") {
                if (expr[1] == "Array" && args.length != 1 && !scope.has("Array")) {
                    return [ "array", args ];
                }
                if (expr[1] == "Object" && !args.length && !scope.has("Object")) {
                    return [ "object", [] ];
                }
                if (expr[1] == "String" && !scope.has("String")) {
                    return [ "binary", "+", args[0], [ "string", "" ]];
                }
            }
        }
    }, function() {
        return walk(pro.ast_add_scope(ast));
    });
};

exports.ast_squeeze_more = ast_squeeze_more;

// Local variables:
// js-indent-level: 4
// End:

})()
},{"./parse-js":121,"./process":122}],124:[function(require,module,exports){
(function(){//convienence function(src, [options]);
function uglify(orig_code, options){
  options || (options = {});
  var jsp = uglify.parser;
  var pro = uglify.uglify;

  var ast = jsp.parse(orig_code, options.strict_semicolons); // parse code and get the initial AST
  ast = pro.ast_mangle(ast, options.mangle_options); // get a new AST with mangled names
  ast = pro.ast_squeeze(ast, options.squeeze_options); // get an AST with compression optimizations
  var final_code = pro.gen_code(ast, options.gen_options); // compressed code here
  return final_code;
};

uglify.parser = require("./lib/parse-js");
uglify.uglify = require("./lib/process");
uglify.consolidator = require("./lib/consolidator");

module.exports = uglify

})()
},{"./lib/consolidator":120,"./lib/parse-js":121,"./lib/process":122}],125:[function(require,module,exports){
(function(){//     Underscore.js 1.4.4
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.4.4';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? null : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See: https://bugs.webkit.org/show_bug.cgi?id=80797
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        index : index,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index < right.index ? -1 : 1;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(obj, value, context, behavior) {
    var result = {};
    var iterator = lookupIterator(value || _.identity);
    each(obj, function(value, index) {
      var key = iterator.call(context, value, index, obj);
      behavior(result, key, value);
    });
    return result;
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key, value) {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });
  };

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key) {
      if (!_.has(result, key)) result[key] = 0;
      result[key]++;
    });
  };

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    each(input, function(value) {
      if (_.isArray(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(concat.apply(ArrayProto, arguments));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(args, "" + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, l = list.length; i < l; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, l = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < l; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    var args = slice.call(arguments, 2);
    return function() {
      return func.apply(context, args.concat(slice.call(arguments)));
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, result;
    var previous = 0;
    var later = function() {
      previous = new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) result = func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var values = [];
    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var pairs = [];
    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] == null) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent, but `Object`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
        return false;
      }
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(n);
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);

})()
},{}],126:[function(require,module,exports){
var pc    = require(".."),
expect    = require("expect.js"),
bindable  = require("bindable"),
utils     = require("./utils");

/**
 * tests for sections. For instance:
 * {{ html: subView }}
 */

describe("conditional sections", function() {

  it("don't show up with an undefined value", function() {
    var v = pc.template("hello{{#if:undefined}} world{{/}}!").bind();

    expect(String(v)).to.be("hello!");
  });

  it("show up with a true statement", function() {
    var v = pc.template("hello{{#if:true}} world{{/}}!").bind();
    expect(String(v)).to.be("hello world!");
  });

  

  describe("with else statements", function() {
    it("are shown if 'if' is false", function() {
      var v = pc.template("hello{{#if:undefined}} world{{/else}} blah{{/}}!").bind();
      expect(String(v)).to.be("hello blah!");
    });

    it("waterfalls down conditional statements", function() {

      var v = pc.template("\
        {{#if: color == 'red' }} \
          {{color}} is an intimidating color. \
        {{/elseif: color == 'yellow' }} \
          {{color}} is a warning color. \
        {{/else}} \
          I don't know the color {{color}}. \
        {{/}} \
      ").bind({
        color: "red"
      });

      expect(utils.trim(v)).to.be("red is an intimidating color.");
      v.context.set("color", "yellow");
      expect(utils.trim(v)).to.be("yellow is a warning color.");
      v.context.set("color", "black");
      expect(utils.trim(v)).to.be("I don't know the color black.");
      v.context.set("color", "yellow");
      expect(utils.trim(v)).to.be("yellow is a warning color.");
      v.context.set("color", "red");
      expect(utils.trim(v)).to.be("red is an intimidating color.");


    });
  });
});
},{"..":4,"./utils":128,"bindable":84,"expect.js":103}],127:[function(require,module,exports){
/*!
  * Bowser - a browser detector
  * https://github.com/ded/bowser
  * MIT License | (c) Dustin Diaz 2011
  */
!function (name, definition) {
  if(typeof window == "undefined") return module.exports = {browser:{node:true}};
  if (typeof define == 'function') define(definition)
  else if (typeof module != 'undefined' && module.exports) module.exports['browser'] = definition()
  else this[name] = definition()
}('bowser', function () {
  /**
    * navigator.userAgent =>
    * Chrome:  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_7) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.57 Safari/534.24"
    * Opera:   "Opera/9.80 (Macintosh; Intel Mac OS X 10.6.7; U; en) Presto/2.7.62 Version/11.01"
    * Safari:  "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_7; en-us) AppleWebKit/533.21.1 (KHTML, like Gecko) Version/5.0.5 Safari/533.21.1"
    * IE:      "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C)"
    * Firefox: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0) Gecko/20100101 Firefox/4.0"
    * iPhone:  "Mozilla/5.0 (iPhone Simulator; U; CPU iPhone OS 4_3_2 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8H7 Safari/6533.18.5"
    * iPad:    "Mozilla/5.0 (iPad; U; CPU OS 4_3_2 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8H7 Safari/6533.18.5",
    * Android: "Mozilla/5.0 (Linux; U; Android 2.3.4; en-us; T-Mobile G2 Build/GRJ22) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1"
    * Touchpad: "Mozilla/5.0 (hp-tabled;Linux;hpwOS/3.0.5; U; en-US)) AppleWebKit/534.6 (KHTML, like Gecko) wOSBrowser/234.83 Safari/534.6 TouchPad/1.0"
    * PhantomJS: "Mozilla/5.0 (Macintosh; Intel Mac OS X) AppleWebKit/534.34 (KHTML, like Gecko) PhantomJS/1.5.0 Safari/534.34"
    */

  var ua = navigator.userAgent
    , t = true
    , ie = /msie/i.test(ua)
    , chrome = /chrome/i.test(ua)
    , phantom = /phantom/i.test(ua)
    , safari = /safari/i.test(ua) && !chrome && !phantom
    , iphone = /iphone/i.test(ua)
    , ipad = /ipad/i.test(ua)
    , touchpad = /touchpad/i.test(ua)
    , android = /android/i.test(ua)
    , opera = /opera/i.test(ua)
    , firefox = /firefox/i.test(ua)
    , gecko = /gecko\//i.test(ua)
    , seamonkey = /seamonkey\//i.test(ua)
    , webkitVersion = /version\/(\d+(\.\d+)?)/i
    , o

  function detect() {

    if (ie) return {
        msie: t
      , version: ua.match(/msie (\d+(\.\d+)?);/i)[1]
    }
    if (chrome) return {
        webkit: t
      , chrome: t
      , version: ua.match(/chrome\/(\d+(\.\d+)?)/i)[1]
    }
    if (phantom) return {
        webkit: t
      , phantom: t
      , version: ua.match(/phantomjs\/(\d+(\.\d+)+)/i)[1]
    }
    if (touchpad) return {
        webkit: t
      , touchpad: t
      , version : ua.match(/touchpad\/(\d+(\.\d+)?)/i)[1]
    }
    if (iphone || ipad) {
      o = {
          webkit: t
        , mobile: t
        , ios: t
        , iphone: iphone
        , ipad: ipad
      }
      // WTF: version is not part of user agent in web apps
      if (webkitVersion.test(ua)) {
        o.version = ua.match(webkitVersion)[1]
      }
      return o
    }
    if (android) return {
        webkit: t
      , android: t
      , mobile: t
      , version: ua.match(webkitVersion)[1]
    }
    if (safari) return {
        webkit: t
      , safari: t
      , version: ua.match(webkitVersion)[1]
    }
    if (opera) return {
        opera: t
      , version: ua.match(webkitVersion)[1]
    }
    if (gecko) {
      o = {
          gecko: t
        , mozilla: t
        , version: ua.match(/firefox\/(\d+(\.\d+)?)/i)[1]
      }
      if (firefox) o.firefox = t
      return o
    }
    if (seamonkey) return {
        seamonkey: t
      , version: ua.match(/seamonkey\/(\d+(\.\d+)?)/i)[1]
    }
  }

  var bowser = detect()

  // Graded Browser Support
  // http://developer.yahoo.com/yui/articles/gbs
  if ((bowser.msie && bowser.version >= 7) ||
      (bowser.chrome && bowser.version >= 10) ||
      (bowser.firefox && bowser.version >= 4.0) ||
      (bowser.safari && bowser.version >= 5) ||
      (bowser.opera && bowser.version >= 10.0)) {
    bowser.a = t;
  }

  else if ((bowser.msie && bowser.version < 7) ||
      (bowser.chrome && bowser.version < 10) ||
      (bowser.firefox && bowser.version < 4.0) ||
      (bowser.safari && bowser.version < 5) ||
      (bowser.opera && bowser.version < 10.0)) {
    bowser.c = t
  } else bowser.x = t

  return bowser
})
},{}],128:[function(require,module,exports){
module.exports = {
  trim: function(str) {
    return String(str).replace(/^\s+|\s+$/g, "");
  },
  browser: require("./browser").browser,
  trimEl: function(str) {
    return String(str).replace(/:\s*/g,":").replace(/;\s*/g,";").replace(' style=""',"")
  }
}
},{"./browser":127}]},{},[126])
;